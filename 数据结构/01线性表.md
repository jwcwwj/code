# 1.线性表：

线性表（linear list）是n个具有相同特性的数据元素的有限序列。 线性表是一种在实际中广泛使用的数据结
构，常见的线性表：顺序表、链表、栈、队列、字符串(字符数组)。
线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，线性表在物
理上存储时，通常以数组和链式结构的形式存储。  （逻辑上只要连续就叫线性表）

# 2.顺序表：

逻辑上连续，物理上连续，只有数据。

顺序表是用一段**物理地址连续**的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。在数组上完成数据的增删查改。
顺序表一般可以分为：1.静态顺序表：使用定长数组存储。		动态顺序表：使用动态开辟的数组存储。  

```c
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

//顺序表
/*
//顺序表的静态存储：空间不可变  在栈上开辟	不能开太大，容易造成栈溢出 结构体大小包含数据的大小
#define N 100
typedef int SLDateType;

typedef struct SeqList
{
	SLDateType array[N];	//定长数组
	size_t size;			//有效数据的个数
	size_t _capacity;		//当前可以存放的最大元素个数
}SeqList;
*/

//顺序表的动态存储：空间可变	在堆上开辟	结构体大小不包含数据的大小	
typedef int SLDateType;

typedef struct SeqList
{	
	SLDateType* _data;	//需要动态开辟的数组
	size_t _size;		//有效元素的个数
	size_t _capacity;	//当前可以存放的最大元素个数
}SeqList;

//初始化
void initSeqList(SeqList* s)
{
	assert(s);			//等价于if(s == NULL) return;  区别是assert只用于debug，在release下是没有作用的
	s->_data = NULL;
	s->_capacity = s->_size = 0;
}

//数据拷贝
void *memcpy(void *dest, const void *src, size_t count)
{
	//assert(dest && src);
	char* pdest = (char*)dest;
	const char* psrc = (const char*)src;
	while (count--)
	{
		*pdest++ = *psrc++;
	}
	return dest;
}

//检查容量
void checkCapacity(SeqList* s)
{
	if (s->_size == s->_capacity)			//空间满了，需要扩容
	{
		//下面的malloc操作可以用realloc替代：SLDateType* tmp = (SLDateType*)realloc(s->_data,sizeof(SLDateType) * newCapacity);	参数：数据 大小
		//开辟一个更大的空间，拷贝原来已有的数据，释放原来的空间
		
		int newCapacity = (s->_capacity == 0 ? 1 : 2 * s->_capacity);
		SLDateType * tmp = (SLDateType*)malloc(sizeof(SLDateType)*newCapacity);
		memcpy(tmp, s->_data, sizeof(SLDateType)*s->_size);		//字节拷贝	参数：新的空间 原有空间 拷贝的字节大小
		//SLDateType* tmp = (SLDateType*)realloc(s->_data, sizeof(SLDateType) * newCapacity);
		free(s->_data);		//释放
		//更新
		s->_data = tmp;
		s->_capacity = newCapacity; 
	}
}

//尾插数据	不考虑增容时间复杂度是O(1)
void pushBack(SeqList* s, SLDateType val)
{
	checkCapacity(s);
	s->_data[s->_size] = val;
	s->_size++;
}

//尾删数据	不考虑增容时间复杂度是O(1)
void popBack(SeqList* s)
{
	//并不是真正的删除数据，只是修改访问权限
	if (s == NULL)
		return;
	if (s->_size)	//s->_size > 0
	{
		s->_size--;
	}
}

//头插数据	 不考虑增容时间复杂度是O(n)
void pushFront(SeqList* s,SLDateType val)
{
	assert(s);
	checkCapacity(s);
	//移动元素：从后向前移动
	int end = s->_size;
	while (end > 0)
	{
		s->_data[end] = s->_data[end - 1];
		end--;
	}
	s->_data[0] = val;
	s->_size++;
} 

//头删数据	不考虑增容时间复杂度是O(n)
void popFront(SeqList* s)
{
	//assert(s && s->_size);	后者下面的
	if (s == NULL || s->_size == 0)
		return;
	int begin = 0;
	while (begin < s->_size - 1)
	{
		s->_data[begin] = s->_data[begin + 1];
		begin++;
	}
	s->_size--;
}

//任意位置的插入数据
void insert(SeqList* s, int pos, SLDateType val)
{
	if (s == NULL)
		return;
	if (pos >= 0 && pos <= s->_size)	//有效区间	0：头插	size：尾插
	{
		checkCapacity(s);
		int end = s->_size;
		while (end > pos)
		{
			s->_data[end] = s->_data[end - 1];
			end--;
		}
		s->_data[pos] = val;
		s->_size++;
	}
}

//任意位置的删除数据
void erase(SeqList* s, int pos)
{
	if (s == NULL || s->_size == 0)
		return;
	if (pos >= 0 && pos < s->_size)	//有效区间	0：头删	size - 1：尾删
	{
		int begin = pos;
		while (begin < s->_size - 1)
		{
			s->_data[begin] = s->_data[begin + 1];
			begin++;
		}
		s->_size--;
	}
}

//打印数据
void printSeqList(SeqList* s)
{
	for (int i = 0; i < s->_size; i++)
	{
		printf("%d ", s->_data[i]);
	}
	printf("\n");
}

//判断顺序表是否为空
int emptySeqList(SeqList* s)
{
	if (s == NULL || s->_size == 0)
		return 1;
	return 0;
}

//顺序表的大小
int sizeSeqList(SeqList* s)
{
	if (s == NULL)
		return 0;
	return s->_size;
}

//查找某一个元素
int findSeqList(SeqList* s,SLDateType val)
{
	for (int i = 0; i < s->_size; i++)
	{
		if (s->_data[i] == val)
			return i;	//返回找到的索引
	}
	return -1;	//没找到返回-1   因为0是合理返回之内的
}

//获取某一个位置的元素
SLDateType getSeqList(SeqList* s, int pos)
{
	//假定调用这个接口就是一个正确的操作
	return s->_data[pos];
}

//顺序表销毁  销毁手动申请的堆上的空间
//不销毁的话这个程序（进程）结束，资源会返还给系统。（系统进行释放）	内存泄漏严重的是程序在不间断运行（比如服务器）
void destroySeqList(SeqList* s)		 {
	if (s)
	{
		if (s->_data)
		{
			free(s->_data);		//释放堆上的空间	
			s->_data = NULL;	//避免是个野指针
		}
	}
}

int main()
{
	SeqList s1;			
	initSeqList(&s1);  
	pushBack(&s1, 1);
	pushBack(&s1, 2);
	pushBack(&s1, 3);
	pushBack(&s1, 4);
	pushBack(&s1, 5);
	printSeqList(&s1);	//1 2 3 4 5
	popBack(&s1);
	printSeqList(&s1);	//1 2 3 4
	pushFront(&s1, 8);
	pushFront(&s1, 7);
	printSeqList(&s1);	//7 8 1 2 3 4
	popFront(&s1);
	popFront(&s1);
	popFront(&s1);		
	printSeqList(&s1);	//2 3 4
	insert(&s1, s1._size, 10);
	insert(&s1, 0, 11);
	printSeqList(&s1);	//11 2 3 4 10
	erase(&s1, 0);
	erase(&s1, s1._size - 1);
	printSeqList(&s1);	//2 3 4
	return 0;
}
```

顺序表的特点：
1.空间连续，优点是获取某一个位置的数据比较方便，不需要搜索，可以做到随机访问，获取任意一个位置数据的时间复杂度是O(1)；
2.尾插和尾删的效率高，时间复杂度是O(1)，其他位置的插入和删除效率低，时间复杂度是O(n)，要移动元素；
3.增容的代价比较大，要向系统重新申请空间，拷贝新的数据；
4.空间利用率比较高，申请的空间每次都是一块一块的申请，可以使用很长时间，申请的空间大返还给系统可以使用，小的话容易造成内存碎片；
5.顺序表适用于访问和保存数据，不适合修改（频繁的插入和删除）数据；

# 3.链表：

逻辑上连续，物理上不连续，除了有数据还有指针，指针指向下一个数据。

含义不同，逻辑结构的意思是对数据之间关系的描述，而物理结构的意思是数据结构在计算机里面的表示。

任务不同，逻辑结构的主要任务是把基本的概念模型图变成和选中的数据模型相吻合的逻辑结构。而物理结构的主要任务则是通过计算机系统的特点 ，为选定的数据模型确定一个合理的存储结构以及存取方法。

反应数据成分不同。逻辑结构反映的是数据之间的逻辑关系。而物理结构反映的是数据在计算机里面的存储安排。

```c
#include <stdio.h>
#include <stdlib.h>

//无头单向非循环单链表
typedef int LDataType;

//节点
typedef struct listNode
{
	LDataType _data;
	struct listNode* _next;
}listNode;

//单链表
typedef struct list
{
	//存放第一个节点的地址
	listNode* _head;
}list;

//初始化
void initList(list* l)
{
	if (l == NULL)
		return;
	//初始化为空的链表
	l->_head = NULL;
}

//创建节点
listNode* createNode(LDataType val)
{
	listNode* node = (listNode*)malloc(sizeof(listNode));
	node->_data = val;
	node->_next = NULL;
	return node;
}

//尾插
void pushBackList(list* l,LDataType val)
{
	if (l == NULL)
		return;
	//第一种情况：空链表插入第一个数据
	if (l->_head == NULL)
	{
		l->_head = createNode(val);
	}
	//第二种情况： 不是空链表
	else
	{
		//遍历找到最后一个节点
		listNode* tail = l->_head;
		while (tail->_next)
		{
			tail = tail->_next;
		}
		//插入
		tail->_next = createNode(val);
	}
}

//尾删
void popBackList(list* l)
{
	if (l == NULL || l->_head == NULL)
		return;
	listNode* tail = l->_head;
	listNode* prev = NULL;
	while (tail->_next)
	{
		prev = tail;
		tail = tail->_next;
	}
	//删除节点
	free(tail);
	//连接
	if (prev == NULL)	//删除的为头结点，更新头结点
		l->_head == NULL;
	else
		prev->_next = NULL;
}

//头插
void pushFrontList(list* l,LDataType val)
{
	if (l == NULL)
		return;
	if (l->_head == NULL)
	{
		//空链表
		l->_head == createNode(val);
	}
	else
	{
		listNode* node = createNode(val);
		node->_next = l->_head;
		l->_head = node;
	}
}

//头删
void popFrontList(list* l)
{
	if (l == NULL || l->_head == NULL)
		return;
	listNode* next = l->_head->_next;
	free(l->_head);
	l->_head = next;
}

//查找数据
listNode* findList(list* l, LDataType val)
{
	if (l == NULL || l->_head == NULL)
		return NULL;
	listNode* cur = l->_head;
	while (cur)
	{
		if (cur->_data == val)
			return cur;
		cur = cur->_next;
	}
	//循环之后还是没有找到
	return NULL;
}

//任意位置的插入	给一个节点的后面插入一个数据	时间复杂度O(1)
void insertAfterList(listNode* cur, LDataType val)
{
	if (cur == NULL)
		return;
	listNode* node = createNode(val);
	node->_next = cur->_next;
	cur->_next = node;
}

//任意位置的删除	删除一个节点的下一个节点	时间复杂度O(1)
void eraseAfterList(listNode* cur)
{
	if (cur == NULL)
		return;
	listNode* next = cur->_next;
	if (next == NULL)	//不存在直接fanhui 
		return;
	cur->_next = next->_next;
	free(next);
}

//打印
void printList(list* l)
{
	if (l == NULL)
		return;
	listNode* cur = l->_head;
	while (cur)
	{
		printf("%d ", cur->_data);
		cur = cur->_next;
	}
	printf("\n");
}

//链表的长度
int sizeList(list* l)
{
	if (l == NULL || l->_head == NULL)
		return 0;
	listNode* cur = l->_head;
	int len = 0;
	while (cur)
	{
		++len;
		cur = cur->_next;
	}
	return len;
}

//链表的销毁
void destroyList(list* l)
{
	if (l == NULL || l->_head == NULL)
		return;
	listNode* cur = l->_head;
	while (cur)
	{
		listNode* next = cur->_next;
		free(cur);
		cur = next;
	}
	l->_head = NULL;
}

int main()
{
	list lst;
	initList(&lst);
	pushBackList(&lst, 1);
	pushBackList(&lst, 2);
	pushBackList(&lst, 3);
	pushBackList(&lst, 4);
	pushBackList(&lst, 5);
	printList(&lst);	//1 2 3 4 5
	popBackList(&lst);
	popBackList(&lst);
	printList(&lst);	//1 2 3 
	pushFrontList(&lst, 10);
	pushFrontList(&lst, 8);
	printList(&lst);	//8 10 1 2 3 
	popFrontList(&lst);
	popFrontList(&lst);
	popFrontList(&lst);
	printList(&lst);	//2 3
	listNode* ret = findList(&lst, 3);
	insertAfterList(ret, 5);
	printList(&lst);	//2 3 5
	ret = findList(&lst, 2);
	eraseAfterList(ret);
	printList(&lst);	//2 5
	printf("%d\n", sizeList(&lst));		//2
	return 0;
}
```

```c
#include <stdio.h>
#include <stdlib.h>

//带头双向循环链表
typedef int LDataType;

typedef struct ListNode
{
	LDataType _data;
	struct listNode* _next;		//指向下一个节点的起始位置
	struct listNode* _prev;		//指向上一个节点的起始位置
}listNode;

typedef struct List
{
	listNode* _head;
}list;

//创建节点
listNode* createListNode(LDataType val)
{
	listNode* node = (listNode*)malloc(sizeof(listNode));
	node->_data = val;
	node->_next = NULL;
	node->_prev = NULL;
	return node;
}

//初始化	创建头
void initList(list* l)
{
	if (l == NULL)
		return;
	//空链表 创建一个环状结构
	l->_head = createListNode(0);
	l->_head->_next = l->_head->_prev = l->_head;
}

//尾插	时间复杂度O(1)
void pushBackList(list* l, LDataType val)
{
	if (l == NULL)
		return;
	listNode* last = l->_head->_prev;	//尾节点
	listNode* newNode = createListNode(val);
	//连接
	last->_next = newNode;
	newNode->_prev = last;
	newNode->_next = l->_head;
	l->_head->_prev = newNode;
}

//尾删
void popBackList(list* l)
{
	if (l == NULL)
		return;
	//空链表
	if (l->_head->_next == l->_head->_prev)
		return;
	listNode* last = l->_head->_prev;
	listNode* prev = last->_prev;
	free(last);
	prev->_next = l->_head;
	l->_head->_prev = prev;
}

//头插
void pushFrontList(list* l, LDataType val)
{
	if (l == NULL)
		return;
	listNode* next = l->_head->_next;
	listNode* newNode = createListNode(val);
	l->_head->_next = newNode;
	newNode->_prev = l->_head;
	newNode->_next = next;
	next->_prev = newNode;
}

//头删
void popFrontList(list* l)
{
	if (l == NULL || l->_head->_next == l->_head)
		return;
	listNode* next = l->_head->_next;
	listNode* nextnext = next->_next;
	nextnext->_prev = l->_head;
	l->_head->_next = nextnext;
	free(next);
}

//删除任意节点，不能删除头结点
void eraseList(list* l,listNode* node)
{
	//不能删除head节点
	if (l == NULL || l->_head == node)
		return;
	listNode* prev = node->_prev;
	listNode* next = node->_next;
	free(node);
	prev->_next = next;
	next->_prev = prev;

}

//在任意节点的前面插入数据
void insertList(list*l, listNode* node, LDataType val)
{
	if (l == NULL)
		return;
	listNode* prev = node->_prev;
	listNode* newNode = createListNode(val);
	prev->_next = newNode;
	newNode->_prev = prev;
	newNode->_next = node;
	node->_prev = newNode;
}

//打印
void printList(list* l)
{
	listNode* cur = l->_head->_next;
	while (cur != l->_head)
	{
		printf("%d ", cur->_data);
		cur = cur->_next;
	}
	printf("\n");
}

//销毁
void destroyList(list* l)
{
	if (l)
	{
		if (l->_head)
		{
			listNode* cur = l->_head->_next;
			while (cur != l->_head)
			{
				listNode* next = cur->_next;
				free(cur);
				cur = next;
			}
		}
		free(l->_head);
	}
}

int main()
{
	list lst;
	initList(&lst);
	pushBackList(&lst, 1);
	pushBackList(&lst, 2);
	pushBackList(&lst, 3);
	pushBackList(&lst, 4);
	pushBackList(&lst, 5);	//1 2 3 4 5
	printList(&lst);
	popBackList(&lst);
	popBackList(&lst);
	printList(&lst);		//1 2 3
	pushFrontList(&lst, 2);
	pushFrontList(&lst, 3);
	printList(&lst);		//3 2 1 2 3
	popFrontList(&lst);
	popFrontList(&lst);
	printList(&lst);		//1 2 3
	insertList(&lst, lst._head, 4);	//尾插
	insertList(&lst, lst._head, 5);
	printList(&lst);		//1 2 3 4 5
	insertList(&lst, lst._head->_next, 6);	//头插
	insertList(&lst, lst._head->_next, 7);
	printList(&lst);		//7 6 1 2 3 4 5
	eraseList(&lst, lst._head);		//无效，不能删除头结点
	eraseList(&lst, lst._head->_next);	//头删
	eraseList(&lst, lst._head->_prev);	//尾删
	printList(&lst);		//6 1 2 3 4 
	return;
}
```

顺序表：

优点：

1.空间连续；

2.支持随机访问；

3.空间利用率高，不容易造成内存碎片；

4.尾插尾删效率高。

缺点：
1.头插头删和中间插入删除效率低，不适合这些位置的插入和删除；

2.增容代价高：申请、拷贝和释放。

链表

优点：任意位置插入和删除效率高，时间复杂度都是O(1)。

缺点：
1.空间不连续；

2.不支持随机访问；

3.空间利用率低，容易造成内存碎片。
