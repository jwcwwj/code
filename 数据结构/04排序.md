# 1.排序的概念

排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。
稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。（稳定性：排序前后，数值相同的数据，它们的相对没有发生变化。）
内部排序：数据元素全部放在内存中的排序。
外部排序（是一个思想）：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序  

# 2.常见的排序算法及实现

## 2.1插入排序：

### 2.1.1直接插入排序

思路：插入排序是一种简单的排序算法，其基本思路是将待排序的序列分为已排序区间和未排序区间，初始已排序区间只有一个元素，即第一个元素。然后依次从未排序区间中取出元素插入到已排序区间中的正确位置，直到所有元素都排序完成。

具体的实现过程如下：

1.假设第一个数据有序，从第二个元素开始向后遍历待排序数组，假设当前要插入的元素为 a。

2.将 a 与已经排序的最后一个元素比较，如果 a大于已排序的最后一个元素，则直接将 a 插入到已排序数组的末尾。

3.如果 a 小于等于已排序的最后一个元素，则从已排序数组的末尾开始向前遍历找到第一个小于等于 a 的元素，并将该元素后面的元素全部后移一位。

4.将 a 插入到该元素的后面，此时已排序数组长度加一。

5.重复步骤1到步骤4，直到整个数组排序完成。

```c
//插入排序	参数：数组	数组元素个数	假设是升序的
void insertionSort(int* arr, int n) {
	//从第二个元素开始向后遍历待排序数组
	for (int i = 1; i < n; i++) {	
		//取出当前要插入的元素，避免被覆盖
		int data = arr[i];	 
		int j = i;
		//比较并移动
		//j > 0避免的是要插入的元素比已经排好序的数组中的最小的元素还小，避免下标越界
		while (j > 0 && arr[j - 1] > data)		//这里不要写成arr[j - 1] >= data，会改变相等元素的相对位置，会使插入排序变得不稳定 
		{
			//arr[j - 1]是排好序的最后一个元素
			arr[j] = arr[j - 1];
			j--;
		}
		//将元素插入到正确位置
		arr[j] = data;
	}
}

int main() {
	int arr[10] = { 5,8,9,4,3,6,7,10,2,1 };
	int n = sizeof(arr) / sizeof(arr[0]);
	insertionSort(arr, n);
	printf("排序后的数组：\n");
	for (int i = 0; i < n; i++)
		printf("%d ", arr[i]);	//1 2 3 4 5 6 7 8 9 10
	return 0;
}
```

时间复杂度：O(n^2)，n是数组中的元素的个数，最好的情况是要插入部分是有序的，时间复杂度是O(n)，最坏的情况是数组是逆序的，时间复杂度是O(n^2)。

最好情况下待排序数组已经有序，此时只需要进行 n−1 次比较操作和0次交换操作，因此时间复杂度是 O(n)。

而最坏情况下待排序数组是逆序的，此时需要进行 (n−1) + (n−2) + ⋯ + 1 = n  * (n − 1) / 2次比较操作和交换操作，因此时间复杂度是O(n^2)。

在平均情况下，假设每个元素被插入到数组中的任意位置的概率相同，那么对于一个长度为 n 的数组，平均需要进行 (n − 1)  * n  / 4次比较操作和交换操作。因此插入排序的平均时间复杂度可以近似地看作O(n^2)。

虽然该算法的时间复杂度较高，但由于它实现简单且常数项小，所以对于小规模的数据来说，插入排序算法也可以达到很好的效果。

空间复杂度：O(1)，没有使用额外空间。

稳定性：插入排序是一种稳定的排序算法。 

在插入排序算法中，如果待排序数组中存在相等元素，那么通过交换相邻元素或移动元素而进行排序时，只有前一个元素大于后一个元素才会发生元素交换或者元素移动。这意味着相等元素的相对顺序不会发生改变，因此插入排序是一种稳定的排序算法。

因为插入排序算法的具体实现过程中，它比较元素的同时也会考虑它们的位置，所以在排序过程中不会改变相等元素的相对顺序，从而保证了排序算法的稳定性。

总结：

1.元素集合越接近有序，直接插入排序算法的时间效率越高；

2.时间复杂度：O(n^2)；

3.空间复杂度：O(1)，它是一种稳定的排序算法；

4.稳定性：稳定 。 

### 2.1.2希尔排序

思路：



选择排序：选择排序和堆排序

交换排序：冒泡排序和快速排序

快速排序：

具体的实现过程：排序后的序列是递增的

1.选取一个基准值，从剩余元素中开始遍历；

2.从后往前找到第一个小于基准值的数据；

3.从前往后找到第一个大于基准值额数据；

4.交换好到的两个值；

5.从交换的位置分别开始继续执行第2步到第4步；

6.用相遇位置的数据和基准值进行交换；

7.分割的小序列继续执行前面的步骤直到全部有序。



归并排序：

计数排序