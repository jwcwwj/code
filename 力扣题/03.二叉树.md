# 965.单值二叉树

题目：如果二叉树每个节点都具有相同的值，那么该二叉树就是*单值*二叉树。

只有给定的树是单值二叉树时，才返回 `true`；否则返回 `false`。

<img src="C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230519073706507.png" alt="image-20230519073706507" style="zoom:67%;" />

<img src="C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230519073735410.png" alt="image-20230519073735410" style="zoom:67%;" />

```c
示例1：
输入：[1,1,1,1,1,null,1]
输出：true

示例2：
输入：[2,2,2,5,2]
输出：false

提示：
给定树的节点数范围是 [1, 100]。
每个节点的值都是整数，范围为 [0, 99] 。
```

```c
方法1：中序遍历递归
1.树中的所有节点和根节点的值进行比较，相等就是单值二叉树，有一个不相等就不是单值二叉树；
2.单值二叉树需要满足左子树的所有节点和右子树的所有节点都和当前节点的值相等。
bool _isUnivalTree(struct TreeNode* root,int val)
{
    if(root)
    {
        return root->val == val && _isUnivalTree(root->left,val) && _isUnivalTree(root->right,val);
    }
    return true;    
}

bool isUnivalTree(struct TreeNode* root)
{
    return _isUnivalTree(root,root->val);
}
时间复杂度：O(n)，n是二叉树的节点个数。我们遍历二叉树的每个节点至多一次。
空间复杂度：O(n)，即为深度优先搜索中需要使用的栈空间。

方法2：深度优先搜索(DFS)	先一路走到底，再回头搜索
bool isUnivalTree(struct TreeNode* root){
    if (root->left) {
        if (root->val != root->left->val || !isUnivalTree(root->left)) {
            return false;
        }
    }
    if (root->right) {
        if (root->val != root->right->val || !isUnivalTree(root->right)) {
            return false;
        }
    }
    return true;
}
时间复杂度：O(n)，n是二叉树的节点个数。我们遍历二叉树的每个节点至多一次。
空间复杂度：O(n)，即为深度优先搜索中需要使用的栈空间。

方法3：分情况递归
bool _isUnivalTree(struct TreeNode* root,int val)
{
    if(!root)
        return true;
    
    //当头结点相等的情况下判断左子树和右子树的头节点
    if(root->val == val)
    {   
        return _isUnivalTree(root->left,val) == 1 && _isUnivalTree(root->right,val) == 1;
    }
    else
        return false; 
}

bool isUnivalTree(struct TreeNode* root){
    return _isUnivalTree(root,root->val); 
}
时间复杂度：O(n)，n是二叉树的节点个数。我们遍历二叉树的每个节点至多一次。
空间复杂度：O(n)，即为深度优先搜索中需要使用的栈空间。

方法4：广度优先搜索（BFS）	借助队列实现层序遍历
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

//队列
typedef struct TreeNode* QDataType;

//节点
typedef struct QNode
{
	struct QNode* _next;
	QDataType _data;
}qnode;

//队列	含有首尾指针的链表
typedef struct Queue
{
	qnode* _front;
	qnode* _rear;
	int _size;		//一般不给这个元素，需要自己遍历	
}queue;

//队列初始化
void initQueue(queue* q)
{
	//初始化空队列
	q->_front = q->_rear = NULL;
	q->_size = 0;
}

//创建队列节点
qnode* createNode(QDataType val)
{
	qnode* node = (qnode*)malloc(sizeof(qnode));
	node->_data = val;
	node->_next = NULL;		//这里表明q._rear的下一个节点是NULL
	return node;
}

//入队	尾插
void pushBackQueue(queue* q, QDataType val)
{
	qnode* node = createNode(val);
	//空队列
	if (q->_front == NULL)
		q->_front = q->_rear = node;
	else
	{
		q->_rear->_next = node;
		q->_rear = node;
	}
	++q->_size;
}

//出队	头删 
void popFrontQueue(queue* q)
{
	if (q == NULL || q->_front == NULL)
		return;
	qnode* cur = q->_front;
	q->_front = q->_front->_next;
	if (q->_front == NULL)
		q->_rear = NULL;	//如果q->_front是NULL，表明是最后一个元素的删除，改变q._rear的指向为NULL
	free(cur);
	--q->_size;
}

//获取队头元素
QDataType getFrontQueue(queue* q)
{
	return q->_front->_data;
}

//获取队尾元素
QDataType getBackQueue(queue* q)
{
	return q->_rear->_data;
}

//获取队列大小
int sizeQueue(queue* q)
{
	//return q->_size;
	int len = 0;
	qnode* cur = q->_front;
	while (cur)
	{
		++len;
		cur = cur->_next;
	}
	return len;
}

//队列是否为空
int emptyQueue(queue* q)
{
	if (sizeQueue(q))
		return 0;
	return 1;
}

//销毁
void destoryQueue(queue* q)
{
	//销毁也可以循环出队列
	qnode* cur = q->_front;
	while (cur)
	{
		qnode* next = cur->_next;
		free(cur);
		cur = next;
	}
	//释放完之后重置队列
	q->_front = q->_rear = NULL;
	q->_size = 0;
}

bool isUnivalTree(struct TreeNode* root)
{
    queue q;
    initQueue(&q);
    int x = root->val;
    //根节点入队列
    pushBackQueue(&q, root);
    //队列不为空
    while(!emptyQueue(&q))
    {
        //记录当前节点，出队列
        struct TreeNode* front = getFrontQueue(&q);
		if(front->val != x)
            return false;
        //出队
		popFrontQueue(&q);
        //左右节点存在，不为空入队列
        if(front->left)
            pushBackQueue(&q,front->left);
        if(front->right)
            pushBackQueue(&q,front->right); 
    }
    return true;
}
时间复杂度：O(n)，n是二叉树的节点个数。我们遍历二叉树的每个节点至多一次。
空间复杂度：O(n)，队列空间。
```

# 104.二叉树的最大深度

题目：给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

<img src="C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230519074424889.png" alt="image-20230519074424889" style="zoom:150%;" />

```c
示例1：
输入：[3,9,20,null,null,15,7]
输出：返回它的最大深度3。
```

```c
方法1：深度优先搜索
1.当前节点的深度取决于左右孩子节点的深度中大的一个 + 1。
int maxDepth(struct TreeNode* root){
    if(root == NULL)
        return 0;
    int leftheight = maxDepth(root->left);
    int rightheight = maxDepth(root->right);
    return leftheight > rightheight ? leftheight + 1 : rightheight + 1;
    //下面一行的代码超出时间限制，因为计算变多了
    //return maxDepth(root->left) > maxDepth(root->right) ? maxDepth(root->left) + 1 : maxDepth(root->right) + 1;
}
时间复杂度：O(n)，n为二叉树节点的个数，每个节点在递归中只被遍历一次。
空间复杂度：O(n)，n位二叉树节点的个数，递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的个数。

方法2：广度优先搜索 借助队列层序遍历
1.广度优先搜索的队列里存放的是当前层的所有节点；
2.当前层的所有节点遍历的时候将当前层的所有节点的不为空的左右孩子节点入队，将当前层遍历完二叉树的深度 + 1；
3.重复步骤2的做法，直到队列为空，返回二叉树的最大深度。
c++代码实现：
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr) 
            return 0;
        //创建队列
        queue<TreeNode*> q;
        //根节点入队
        q.push(root);
        int height = 0;
        while (!q.empty())
        {
            //当前队列的大小 = 当前行的个数
            int size = q.size();
            while (size > 0) {
                //当前行的遍历
                TreeNode* front = q.front();
                q.pop();
                if (front->left) 
                    q.push(front->left);
                if (front->right) 
                    q.push(front->right);
                size--;
            }
            height++;
        } 
        return height;
    }
};

c语言实现：
//队列
typedef struct TreeNode* QDataType;

//节点
typedef struct QNode
{
	struct QNode* _next;
	QDataType _data;
}qnode;

//队列	含有首尾指针的链表
typedef struct Queue
{
	qnode* _front;
	qnode* _rear;
	int _size;		//一般不给这个元素，需要自己遍历	
}queue;

//队列初始化
void initQueue(queue* q)
{
	//初始化空队列
	q->_front = q->_rear = NULL;
	q->_size = 0;
}

//创建队列节点
qnode* createNode(QDataType val)
{
	qnode* node = (qnode*)malloc(sizeof(qnode));
	node->_data = val;
	node->_next = NULL;		//这里表明q._rear的下一个节点是NULL
	return node;
}

//入队	尾插
void pushBackQueue(queue* q, QDataType val)
{
	qnode* node = createNode(val);
	//空队列
	if (q->_front == NULL)
		q->_front = q->_rear = node;
	else
	{
		q->_rear->_next = node;
		q->_rear = node;
	}
	++q->_size;
}

//出队	头删 
void popFrontQueue(queue* q)
{
	if (q == NULL || q->_front == NULL)
		return;
	qnode* cur = q->_front;
	q->_front = q->_front->_next;
	if (q->_front == NULL)
		q->_rear = NULL;	//如果q->_front是NULL，表明是最后一个元素的删除，改变q._rear的指向为NULL
	free(cur);
	--q->_size;
}

//获取队头元素
QDataType getFrontQueue(queue* q)
{
	return q->_front->_data;
}

//获取队尾元素
QDataType getBackQueue(queue* q)
{
	return q->_rear->_data;
}

//获取队列大小
int sizeQueue(queue* q)
{
	//return q->_size;
	int len = 0;
	qnode* cur = q->_front;
	while (cur)
	{
		++len;
		cur = cur->_next;
	}
	return len;
}

//队列是否为空
int emptyQueue(queue* q)
{
	if (sizeQueue(q))
		return 0;
	return 1;
}

//销毁
void destoryQueue(queue* q)
{
	//销毁也可以循环出队列
	qnode* cur = q->_front;
	while (cur)
	{
		qnode* next = cur->_next;
		free(cur);
		cur = next;
	}
	//释放完之后重置队列
	q->_front = q->_rear = NULL;
	q->_size = 0;
}

int maxDepth(struct TreeNode* root)
{
    //初始化队列
    queue q;
    initQueue(&q);
    //根节点入队列
    if(root)
        pushBackQueue(&q,root);
    int height = 0;
    while(!emptyQueue(&q))
    {
        int size = sizeQueue(&q);
        while(size > 0)
        {
            //获取队列队头元素
            struct TreeNode* front = getFrontQueue(&q);
            //出队
            popFrontQueue(&q);
            //左右节点存在，不为空入队列
            if(front->left)
                pushBackQueue(&q,front->left);
            if(front->right)
                pushBackQueue(&q,front->right);
            size--;
        }
        height++;
    }
    return height;
}
时间复杂度：O(n)，n为二叉树节点的个数，每个节点都会被遍历一次。
空间复杂度：O(n)，n位二叉树节点的个数，队列空间存储至多是树的节点个数。

方法3：Morris算法java实现代码	空间复杂度是O(1)。
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        TreeNode pre = null;
        int depth = 1;
        int maxDepth = Integer.MIN_VALUE;
        while (root != null) {
            if ((pre = root.left) != null) {
                int n = 1;
                while (pre.right != null && pre.right != root) {
                    pre = pre.right;
                    n++;
                }
                if (pre.right == null) {
                    maxDepth = Math.max(maxDepth, depth);
                    pre.right = root;
                    root = root.left;
                    depth++;
                } else {
                    pre.right = null;
                    root = root.right;
                    depth = depth - n;
                }
            } else {
                maxDepth = Math.max(maxDepth, depth);
                root = root.right;
                depth++;
            }
        }
        return maxDepth;
    }
}
```

# 226.翻转二叉树

题目：给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

![image-20230519074714163](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230519074714163.png)

```c
示例1：
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]

示例2：
输入：root = [2,1,3]
输出：[2,3,1]

示例3：
输入：root = []
输出：[]

提示：
树中节点数目范围在 [0, 100] 内
-100 <= Node.val <= 100
```

```c
深度优先遍历
方法1：自顶向下交换
struct TreeNode* invertTree(struct TreeNode* root){
    if(root == NULL)
        return NULL;
    //左右孩子节点交换，改变连接
    struct TreeNode* temp = root->left;
    root->left = root->right;
    root->right = temp;
    //交换当前节点的左孩子节点的左右孩子节点
    root->left = invertTree(root->left);
    //invertTree(root->left);   //可以写成这样，因为改变方向就是一种连接
    //交换当前节点的右孩子节点的左右孩子节点
    root->right = invertTree(root->right);
    //invertTree(root->right);
    //函数返回时表示当前节点和左右子树节点都已经交换完了
    return root;
}
时间复杂度：O(N)，N为二叉树节点的数目，我们会遍历二叉树中的每一个节点。
空间复杂度：O(N)，使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即O(logN)。而在最坏情况下，树形成链状，空间复杂度为O(N)。

方法2：自底向上交换
struct TreeNode* invertTree(struct TreeNode* root) {
    if (root == NULL) {
        return NULL;
    }
    struct TreeNode* left = invertTree(root->left);
    struct TreeNode* right = invertTree(root->right);
    root->left = right;
    root->right = left;
    return root;
}
时间复杂度：O(N)，N为二叉树节点的数目，我们会遍历二叉树中的每一个节点。
空间复杂度：O(N)，使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即O(logN)。而在最坏情况下，树形成链状，空间复杂度为O(N)。

方法3：广度优先遍历	借助队列层序遍历实现
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr)
            return root;
        //创建队列
        queue<TreeNode*> q;
        //根节点入队
        q.push(root);
        while(!q.empty())
        {
            //获取队头元素
            TreeNode* front = q.front();
            //队头元素出队
            q.pop();
            //交换左右孩子节点
            if(front->left || front->right)
            {
                //只要左右孩子节点有一个不为空就要交换，有一个为空就不交换
                TreeNode* temp = front->left;
                front->left = front->right;
                front->right = temp;
            }
            //如果左孩子节点存在，入队
            if(front->left)
                q.push(front->left);
            //如果右孩子节点存在，入队
            if(front->right)
                q.push(front->right);
        }
        return root;
    }
};
时间复杂度：同样每个节点都需要入队列/出队列一次，所以是O(n)。
空间复杂度：最坏的情况下会包含所有的叶子节点，叶子节点(完全二叉树的时候最多)最多是 n/2个，所以时间复杂度是O(n)。 
  
方法4：方法1和方法2的总结
struct TreeNode* invertTree(struct TreeNode* root)
{
    if(root)
    {
        struct TreeNode* temp = root->left;
        root->left = invertTree(root->right);
        root->right = invertTree(temp);
    }
    return root;
}
时间复杂度：O(n)，n是树的节点个数，每个节点都要遍历一次。
空间复杂度：O(h)，h是树的高度，要递归h层。
```

# 100.相同的树

题目：给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

![image-20230519091259155](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230519091259155.png)

![image-20230519091319501](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230519091319501.png)

![image-20230519091343159](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230519091343159.png)

```c
方法1：
输入：p = [1,2,3], q = [1,2,3]
输出：true

方法2：
输入：p = [1,2], q = [1,null,2]
输出：false

方法3：
输入：p = [1,2,1], q = [1,1,2]
输出：false
 
提示：
两棵树上的节点数目都在范围 [0, 100] 内
-104 <= Node.val <= 104
```

```c
方法1：深度优先搜索
1.两个二叉树相同，当且仅当两个二叉树的结构完全相同，且所有对应节点的值相同；
2.如果两个二叉树都为空，则两个二叉树相同；
3.如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同；
4.如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。
bool isSameTree(struct TreeNode* p, struct TreeNode* q){
    //如果两棵树同时到达空，两颗树就相同
    if(p == NULL && q == NULL)
        return true;
    //如果一棵树到达空，另一颗树没有到达空，两棵树就不相同
    if(p == NULL || q == NULL)
        return false;
    return p->val == q->val && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);
}
时间复杂度：O(min(m,n))，m和n分别是两个二叉树的节点数，对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。
空间复杂度：O(min(m,n))，m和n分别是两个二叉树的节点数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。
   
方法2：广度优先搜索	借助队列进行层序遍历
1.和深度优先搜索的判断方法一样，广度优先搜索使用了两个队列对数进行了层序遍历。
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        //如果两颗树的根节点都为空，说明两棵树相同
        if (p == nullptr && q == nullptr) 
            return true;
        //如果两棵树的根节点一个为空，一个不为空，说明两棵树不相同
        if (p == nullptr || q == nullptr) 
            return false;
        //创建两个队列，层序遍历两棵树的节点
        queue <TreeNode*> queue1, queue2;
        queue1.push(p);
        queue2.push(q);
        //两个队列中都有元素
        while (!queue1.empty() && !queue2.empty()) {
            //获取队列中的队头元素，队头元素出队
            auto front1 = queue1.front();
            queue1.pop();
            auto front2 = queue2.front();
            queue2.pop();
            if (front1->val != front2->val) 
                return false;
            auto left1 = front1->left, right1 = front1->right, left2 = front2->left, right2 = front2->right;
            //队头元素的左右节点一个为空的同时一个不为空，说明不是相同的树
            if ((left1 == nullptr) ^ (left2 == nullptr)) 
                return false;
            if ((right1 == nullptr) ^ (right2 == nullptr)) 
                return false;
            //上面判断过left1为空，left2为空，left1不为空，left2不为空，right同理
            if (left1) 
            {
                queue1.push(left1); 
                queue2.push(left2);
            } 
            if (right1)
            {
                queue1.push(right1);
                queue2.push(right2);
            } 
        }
        return true;
        //不用写成下面这样，因为结构已经在上面的入队出队循环中判断过了
        //return queue1.empty() && queue2.empty();
    }
};
时间复杂度：O(min(m,n))，m和n分别是两个二叉树的节点数，对两个二叉树同时进行广度优先搜索，遍历较小树的每一个节点，最坏情况下，直到较小树的每一个节点遍历完时结束。 
空间复杂度：O(min(m,n))，m和n分别是两个二叉树的叶子节点数。空间复杂度取决于队列中的元素个数，队列中的元素个数不会超过较小的二叉树的叶子节点个数。
```

# 101.对称二叉树

题目：给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

![image-20230519091812557](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230519091812557.png)

![image-20230519091828349](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230519091828349.png)

```c
示例1：
输入：root = [1,2,2,3,4,4,3]
输出：true

示例2：
输入：root = [1,2,2,null,3,null,3]
输出：false
 
提示：
树中节点数目在范围 [1, 1000] 内
-100 <= Node.val <= 100
```

```c
方法1：深度优先搜素
1.如果左右节点都是NULL，是对称二叉树；
2.如果左右节点只有一个是NULL，另一个不是NULL，就不是对称二叉树；
3.左右节点的val相等的同时还要确保左节点的左节点和右节点的右节点val相等以及左节点的右节点和右节点的左节点的val相等，才是对称二叉树。
bool _isSymmetric(struct TreeNode* left, struct TreeNode* right)
{
    //如果左右节点都是NULL，是对称二叉树
    /*
    if(left == NULL && right == NULL)
        return true;
    //如果左右节点只有一个是NULL，另一个不是NULL，就不是对称二叉树
    if(left == NULL || right == NULL)
        return false;
    */
    //上面的可以总结为
    if(left == NULL || right == NULL)
        return left == right;
    return left->val == right->val
    && _isSymmetric(left->left, right->right)
    && _isSymmetric(left->right, right->left);
}

bool isSymmetric(struct TreeNode* root){
    return _isSymmetric(root->left, root->right); 
}
时间复杂度：O(n)，n是二叉树的节点数，最坏的情况是遍历了二叉树的所有节点。
空间复杂度：O(n)，这里的空间复杂度和递归使用的栈空间有关，最坏的情况下是二叉树的左节点和右节点都是链表形式，递归层数就是n/2。

方法2：广度优先搜索	借助队列层序遍历
1.对称的节点每次两个入队列为一组，进行比较；
2.两个节点都为空说明当前结构是对称的，就比较下一组；
3.一个为空一个不为空或者两个节点的val不相等就说明不是对称二叉树，返回false。
class Solution {
public:
    bool _isSymmetric(TreeNode *left, TreeNode *right) 
    {
        //创建队列容器
        queue <TreeNode*> q;
        //根节点的左孩子节点和右孩子节点入队列
        q.push(left); 
        q.push(right);
        while (!q.empty()) {
            //获取队列的队头元素和队头元素的下一个元素
            left = q.front(); 
            q.pop();
            right = q.front(); 
            q.pop();
            //两个都为空，表示树的左右结构是对称的，没有孩子节点入队，需要判断队列中下面两个元素
            if (left == NULL && right == NULL) 
                continue;
            //一个为空，一个不为空说明结构不对称，不是对称二叉树，或者值不相等也不是对称二叉树
            if ((left == NULL || right == NULL) || (left->val != right->val)) 
                return false;
            //左节点的左节点入队，右节点的右节点入队，是要两个一起比较的节点
            q.push(left->left); 
            q.push(right->right);
            //左节点的右节点入队，右节点的左节点入队，是要两个一起比较的节点
            q.push(left->right); 
            q.push(right->left);
        }
        return true;
    }

    bool isSymmetric(TreeNode* root) 
    {
        return _isSymmetric(root->left, root->right);
    }
};
时间复杂度：O(n)，n是二叉树节点的个数，最坏情况层序遍历需要遍历每个节点一次。
空间复杂度：O(n)，n是二叉树的叶子节点的个数，这里需要用一个队列来维护节点，每个节点最多进队一次，出队一次，最坏情况下队列中的元素不会超过叶子节点的个数。

还有一个比较麻烦的就是创建两个队列，一个正着层序遍历一次，一个反着层序遍历一次，进行比较，但这样每个空间遍历了两遍，消耗的时间和空间变得多了。
```

# 144.二叉树的前序遍历

题目：给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

![image-20230521085244640](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230521085244640.png)

![image-20230521085304824](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230521085304824.png)

![image-20230521085335349](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230521085335349.png)

```c
示例1：
输入：root = [1,null,2,3]
输出：[1,2,3]

示例 2：
输入：root = []
输出：[]

示例 3：
输入：root = [1]
输出：[1]

示例4：
输入：root = [1,2]
输出：[1,2]

示例5：
输入：root = [1,null,2]
输出：[1,2]

提示：
树中节点数目在范围 [0, 100] 内
-100 <= Node.val <= 100
进阶：递归算法很简单，你可以通过迭代算法完成吗？
```

```c
方法1：:
```

# 94.二叉树的中序遍历

题目：给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

![image-20230521095428571](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230521095428571.png)

```c
示例1：
输入：root = [1,null,2,3]
输出：[1,3,2]

示例 2：
输入：root = []
输出：[]

示例 3：
输入：root = [1]
输出：[1]
 
提示：
树中节点数目在范围 [0, 100] 内
-100 <= Node.val <= 100
进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 
```

```c
方法1：

```

# 145.二叉树的后序遍历

![image-20230521095623507](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230521095623507.png)

```c
示例1：
输入：root = [1,null,2,3]
输出：[3,2,1]

示例2：
输入：root = []
输出：[]

示例3：
输入：root = [1]
输出：[1]

提示：
树中节点的数目在范围 [0, 100] 内
-100 <= Node.val <= 100
进阶：递归算法很简单，你可以通过迭代算法完成吗？
```

```c
方法1：
```

# 572.另一棵树的子树

题目：给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。

二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。

![image-20230521095939938](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230521095939938.png)

![image-20230521095956406](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230521095956406.png)

```c
示例1：
输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true

示例2：
输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
输出：false

提示：
root 树上的节点数量范围是 [1, 2000]
subRoot 树上的节点数量范围是 [1, 1000]
-104 <= root.val <= 104
-104 <= subRoot.val <= 104
```

```c
方法1：
```

# 110.平衡二叉树

题目：给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

![image-20230521100427135](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230521100427135.png)

![image-20230521100446286](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230521100446286.png)

```c
示例1：
输入：root = [3,9,20,null,null,15,7]
输出：true

示例2：
输入：root = [1,2,2,3,3,null,null,4,4]
输出：false

示例3：
输入：root = []
输出：true

提示：
树中的节点数在范围 [0, 5000] 内
-104 <= Node.val <= 104
```

```c
深度优先搜索
方法1：自顶向下的递归
1.根节点满足平衡二叉树的规定，左右子树也满足二叉树的规定就是平衡二叉树;
2.最小化如果根节点是空的就满足平衡二叉树。
//求一个节点的高度
int getHeight(struct TreeNode* root)
{
    if(root)
    {
        int leftheight = getHeight(root->left);
        int rightheight = getHeight(root->right);
        return leftheight > rightheight ? leftheight + 1 : rightheight + 1;
    }
    //如果节点是NULL，高度为0
    return 0;
}

bool isBalanced(struct TreeNode* root){
    //如果是空树，是平衡二叉树
    if(root == NULL)
        return true;
    //获取左右子树的高度
    int leftheight = getHeight(root->left);
    int rightheight = getHeight(root->right);
    return abs(leftheight - rightheight) < 2 && isBalanced(root->left) && isBalanced(root->right);
}
时间复杂度：O(n^2)，n是二叉树中的节点个数，最坏情况下，二叉树是完全二叉树，需要遍历二叉树中的所有节点，时间复杂度是O(n)。树的高度是logn,遍历输的，所以总时间复杂度为O(nlogn)，最坏情况是树是链式的，时间复杂度是O(n^2)。 

空间复杂度：O(n)，n是二叉树中的节点个数，空间复杂度主要取决于递归调用的层数，最坏情况是树的链式的，递归调用的层数不会超过n。

方法2：自底向上的递归
1.判断子结构是否满足平衡二叉树的性质，当子结构满足平衡二叉树的性质再判断大的结构是否满足平衡二叉树的性质。
int getHeight(struct TreeNode* root)
{
    //如果root为空，树的高度为0
    if(root == NULL)
        return 0;
    //root节点的左孩子节点的高度和右孩子节点的高度
    int leftheight = getHeight(root->left);
    int rightheight = getHeight(root->right);
    //高度差不符合小于等于1就不是平衡二叉树，就返回-1，向上层递归返回到左孩子节点或有孩子节点，以后都会返回-1
    if(leftheight == -1 || rightheight == -1 || (fabs(leftheight - rightheight) > 1))
        return -1;
    //满足平衡二叉树的性质，左右孩子节点的树的高度差小于2
    //当前节点为根节点满足平衡二叉树的性质，递归判断当前节点的父节点是否满足平衡二叉树的性质
    return fmax(leftheight,rightheight) + 1;
}

bool isBalanced(struct TreeNode* root){
    //如果满足平衡二叉树的性质返回就是树的实际高度，不可能是-1，不满足平衡二叉树的性质返回就是-1
    return getHeight(root) != -1;
}
    
方法3：针对方法2自底向上递归进行剪枝
//自底向上递归
int getHeight(struct TreeNode* root)
{
    //如果root为空，树的高度为0
    if(root == NULL)
        return 0;
    //root节点的左孩子节点的高度和右孩子节点的高度
    int leftheight,rightheight;
    //高度差不符合小于等于1就不是平衡二叉树，就返回-1，向上层递归返回到左孩子节点或有孩子节点，以后都会返回-1
    if((leftheight = getHeight(root->left)) == -1 || (rightheight = getHeight(root->right)) == -1 || (fabs(leftheight - rightheight) > 1))
        return -1;
    //满足平衡二叉树的性质，左右孩子节点的树的高度差小于2
    //当前节点为根节点满足平衡二叉树的性质，递归判断当前节点的父节点是否满足平衡二叉树的性质
    return fmax(leftheight,rightheight) + 1;
}

bool isBalanced(struct TreeNode* root){
    //如果满足平衡二叉树的性质返回就是树的实际高度，不可能是-1，不满足平衡二叉树的性质返回就是-1
    return getHeight(root) != -1;
}
优点：不满足平衡二叉树就不判断右边。
缺点：二次赋值更消耗时间。
//上面代码修改一下：
int getheight(struct TreeNode* root) {
    if (root == NULL) 
        return 0;
    int leftHeight = getheight(root->left);
    if (leftHeight == -1) 
        return -1; // 左子树不平衡，直接返回
    int rightHeight = getheight(root->right);
    if (rightHeight == -1 || fabs(leftHeight - rightHeight) > 1) 
        return -1; // 右子树不平衡或左右子树高度差超过1，直接返回
    return fmax(leftHeight, rightHeight) + 1;
}

bool isBalanced(struct TreeNode* root) {
    return getheight(root) != -1;
}
该实现方式的优点是：
1.递归实现简洁易懂，代码的可读性较高；
2.可以在计算节点高度的过程中同时判断子树是否平衡，避免了重复计算；
3.时间复杂度为 O(n)，其中 n 表示二叉树的节点数，在大多数情况下可以满足要求。
该实现方式的缺点是：
1.实现方式较为基础，可能无法处理一些特殊情况；
2.需要使用递归，会消耗一定的内存空间，可能导致栈溢出等问题；
3.在 C 语言中，需要手动实现一些基本函数，如求绝对值和最大值，增加代码量和维护难度。
综上所述，该实现方式简单易懂，可以满足一般情况下的需求；但对于复杂情况或对性能有要求的场景，可能需要考虑其他实现方式。

该实现方式的时间复杂度为 O(n)，其中 n 表示二叉树的节点数。具体分析如下：
1.在 getheight() 函数中，每个节点会被访问一次，且每次访问都需要进行常数时间的计算，因此总时间复杂度为 O(n)；
2.在 isBalanced() 函数中，只需要调用一次 getheight() 函数，因此其时间复杂度也为 O(n)。
该实现方式的空间复杂度也为 O(n)，具体分析如下：
1.在 getheight() 函数中，每个递归调用会开辟一个新的栈帧，保存局部变量和参数信息。最坏情况下，二叉树的高度为 n，此时递归深度也为 n，因此需要 O(n) 的栈空间；
2.在 isBalanced() 函数中，只需保存一个 getheight() 函数的返回值，因此空间复杂度为 O(1)。
综上所述，该实现方式的时间复杂度和空间复杂度均为 O(n)，在大多数情况下可以满足要求。但需要注意，在 C 语言中，递归深度过大可能导致栈溢出等问题。

方法4：自底向上全局变量进行剪枝	c++实现，因为在力扣c测试出问题，同样的代码c++是好的。
1.首先声明一个全局变量flag ，初始化为 true，表示当前二叉树是平衡二叉树；
2.定义一个函数getheight ，用于递归求解二叉树每个节点的高度，同时判断该节点的左右子树高度差是否超过 1，如果超过 1，就将全局变量  设为 false。 如果没有超过 1，就返回该节点的高度（左右子树高度的最大值加一）。
3.在函数中调用函数，得到整棵二叉树的高度并更新全局变量 ，最后返回即可，如果为true，表示二叉树是平衡二叉树； 如果为false，表示二叉树不是平衡二叉树。
class Solution {
public:
//自底向上递归进行剪枝
    bool flag = true;
    int getHeight(struct TreeNode* root)
    {
        //如果root为空，树的高度为0
        if(root == NULL || !flag)
            return 0;
        //root节点的左孩子节点的高度和右孩子节点的高度
        int leftheight = getHeight(root->left);
        int rightheight = getHeight(root->right);
        //高度差不符合小于等于1就不是平衡二叉树，就修改flag为false
        if((fabs(leftheight - rightheight) > 1))
            flag = false;
        //满足平衡二叉树的性质，左右孩子节点的树的高度差小于2
        //当前节点为根节点满足平衡二叉树的性质，递归判断当前节点的父节点是否满足平衡二叉树的性质
        return fmax(leftheight,rightheight) + 1;
    }

    bool isBalanced(struct TreeNode* root){
        getHeight(root);
        return flag;
    }
};
其主要的优点在于当发现子树不平衡时就直接剪枝退出，不用继续遍历整棵树的节点，从而优化了时间复杂度。
该实现方式的时间复杂度为 O（n)，其中 n 表示二叉树的节点数。 因为每个节点只会被遍历一次，并且在递归过程中进行了剪枝操作，所以整个递归遍历的时间复杂度等价于遍历二叉树的所有节点一次的时间复杂度。
该实现方式的空间复杂度为 O（h)，其中 h 表示二叉树的高度。 在递归过程中，每次都需要存储当前节点的高度，而递归的最大深度等于二叉树的高度，所以递归过程中会使用 O(h) 的额外空间。 由于是自底向上的递归，每次递归返回时都会释放之前开辟的空间，所以空间复杂度不会出现累加的情况。

方法5：借助队列层序遍历
class Solution {
public:
    bool isBalanced(TreeNode* root) {
    if (root == NULL) {
        return true; // 空树也算作一棵平衡二叉树
    }

    queue<TreeNode*> q;
    q.push(root); // 将根节点加入队列

    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();

        int leftHeight = 0, rightHeight = 0;
        if (node->left != NULL) {
            q.push(node->left);
            leftHeight = getHeight(node->left); // 计算左子树高度
        }
        if (node->right != NULL) {
            q.push(node->right);
            rightHeight = getHeight(node->right); // 计算右子树高度
        }

        if (abs(leftHeight - rightHeight) > 1) {
            return false; // 左右子树高度差超过 1，不是平衡二叉树
        }
    }

    return true; // 所有节点的左右子树高度差都不超过 1，是平衡二叉树
}

int getHeight(TreeNode* node) {
    if (node == NULL) {
        return 0;
    }
    return max(getHeight(node->left), getHeight(node->right)) + 1;
}
};
时间复杂度是O(n^2)，n是二叉树节点的个数，层序遍历是O(n)，求高度最坏时间复杂度压实O(n)，总的是O(n^2)。
空间复杂度是O(n)，n是二叉树节点的个数，栈最大是二叉树叶子节点的个数，但求高度最差的情况是链式结构，是O(n)。
```

# 1028.从先序遍历还原二叉树

题目：我们从二叉树的根节点 root 开始进行深度优先搜索。

在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。

如果节点只有一个子节点，那么保证该子节点为左子节点。

给出遍历输出 S，还原树并返回其根节点 root。 

![image-20230521101021569](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230521101021569.png)

![image-20230521101037274](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230521101037274.png)

![image-20230521101117666](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230521101117666.png)

```c
示例1：
输入："1-2--3--4-5--6--7"
输出：[1,2,5,3,4,6,7]

示例2：
输入："1-2--3---4-5--6---7"
输出：[1,2,5,3,null,6,null,4,null,7]

示例3：
输入："1-401--349---90--88"
输出：[1,401,null,349,88,90]

提示：
原始树中的节点数介于 1 和 1000 之间。
每个节点的值介于 1 和 10 ^ 9 之间。
```

```c
方法1：

```

