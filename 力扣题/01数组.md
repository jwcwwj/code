# 27.移除元素

题目：给你一个数组nums和一个值val，你需要原地移除所有数值等于val的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用O(1)额外空间并原地修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

```c
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);
// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
} 
```

```c
示例1：
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度2, 并且nums中的前两个元素均为2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为2，而nums = [2,2,3,3]或nums = [2,2,0,0]，也会被视作正确答案。
示例2：
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度5,并且nums中的前五个元素为0,1,3,0,4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。

提示：    
0 <= nums.length <= 100
0 <= nums[i] <= 50
0 <= val <= 100
```

```c
方法1：快慢指针
1.i是要返回的索引，j是遍历的索引；
2.和val相等就遍历下一个，不相等就存储在数组以i为索引的数组。
int removeElement(int* nums, int numsSize, int val) {
    int i = 0;
    for(int j = 0; j < numsSize; j++)
    {
        if(nums[j] != val)
             nums[i++] = nums[j];
    }
    return i;
}
时间复杂度：O(n)其中为序列的长度，我们只需要遍历该序列至多两次。（最坏情况下是两个索引各自都遍历了一遍）

方法2：首尾交换
1.遍历索引i，如果索引i的值和val相等就和最后一个元素（索引下标为numsSize - 1）进行交换，numsSize减1，不相等就遍历下一个元素；
2.交换之后索引不变，再重复步骤1。
int removeElement(int* nums, int numsSize, int val) {
    int i = 0;
    while(i < numsSize)
    {
        if(nums[i] == val)
            nums[i] = nums[--numsSize];
        else
            i++;
    }
    return numsSize;		//return i;
}
时间复杂度：O(n)，其中n为序列的长度，我们只需要遍历该序列至多一次。
```

# 26.删除有序数组中的重复项

题目：给你一个升序排列的数组nums，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。然后返回nums中唯一元素的个数。

考虑nums的唯一元素的数量为k，你需要做以下事情确保你的题解可以被通过：

更改数组nums，使nums的前k个元素包含唯一元素，并按照它们最初在nums中出现的顺序排列。nums的其余元素与nums的大小不重要。
返回 k 。

```c
系统会用下面的代码来测试你的题解:
int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案
int k = removeDuplicates(nums); // 调用
assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
如果所有断言都通过，那么您的题解将被通过。
```

```c
示例1：
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度2，并且原数组nums的前两个元素被修改为1,2。不需要考虑数组中超出新长度后面的元素。
示例2：
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度5，并且原数组nums的前五个元素被修改为0,1,2,3,4。不需要考虑数组中超出新长度后面的元素。

提示：
1 <= nums.length <= 3 * 104
-104 <= nums[i] <= 104
nums已按升序排列
```

```c
方法1：三指针
1.idx是要返回的数组的长度，i是要赋值元素的索引，j是要遍历元素的索引；
2.如果i索引和j索引的值不相等就往后加1，把i的值赋值给idx索引的值；
3.如果i索引和j索引的值相等就往后遍历j索引，找到第一个不相等的值，把i索引移动到j索引的位置，再把j索引后移一位，再把i索引的值赋值给idx索引的值；
4.重复上面的工作知道遍历完所有元素；
5.有可能倒数第二个元素之前有相同的，会造成j越界的情况，需要判断i索引是否在numsSize之前，是的话就把i索引的值赋值给idx索引的值。
int removeDuplicates(int* nums, int numsSize){
    int idx = 0, i = 0, j = 1;
    while(j < numsSize)
    { 
        nums[idx++] = nums[i];
        if(nums[i] == nums[j])
        {
            while(j < numsSize && nums[i] == nums[j])
            {
                ++j;	//找到一个相等的区间
            }
            i = j;		//这里是第一个不相等的元素   
            j++;
        }
        else
        {
            ++i;
            ++j;
        }
    }
    if(i < numsSize)
        nums[idx++] = nums[i];		//为了防止1 1 2这种2不进数组的情况
    return idx;
}
时间复杂度：O(n)其中为序列的长度，我们只需要遍历该序列至多两次。（最坏情况下是三个索引各自都遍历了一遍）

方法2：快慢指针
1.相等的元素在数组中的下标一定是连续的，并且是有序的，相等具有传递性（重复的元素一定会相邻）；
2.最少要返回一个元素，所以slow和fast都从索引为1的位置开始；
3.fast和fast - 1的位置的值进行比较，不相等的话就赋值给slow，赋值完slow + 1，不管想不想等fast的位置都加1；
4.fast和fast - 1的位置的值进行比较，相等的话就利用有序的传递性重复步骤3。
int removeDuplicates(int* nums, int numsSize) {
    int fast = 1, slow = 1;
    while (fast < numsSize) {
        if (nums[fast] != nums[fast - 1]) {
            nums[slow++] = nums[fast];
        }
        ++fast;
    }
    return slow;
}
时间复杂度：O(n)其中为序列的长度，我们只需要遍历该序列至多两次。（最坏情况下是2个索引各自都遍历了一遍）
```

# 88.合并两个有序数组

题目：给你两个按非递减顺序排列的整数数组nums1和nums2，另有两个整数m和n，分别表示nums1和nums2中的元素数目。

请你合并nums2到nums1中，使合并后的数组同样按非递减顺序排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组nums1中。为了应对这种情况，nums1的初始长度为m + n，其中前m个元素表示应合并的元素，后n个元素为0，应忽略nums2的长度为n。 

```c
示例1：
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] ，合并结果是 [1,2,2,3,5,6]。 
示例2：
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 []，合并结果是 [1]。
示例3：
输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1]，合并结果是 [1] 。
注意，因为 m = 0 ，所以nums1中没有元素。nums1中仅存的0仅仅是为了确保合并结果可以顺利存放到nums1中。

提示：
nums1.length == m + n
nums2.length == n
0 <= m, n <= 200
1 <= m + n <= 200
-109 <= nums1[i], nums2[j] <= 109
```

```c
方法1：合并后直接进行排序（先将数组nums2放进数组nums1的尾部，然后直接对整个数组进行排序。）
int cmp(int* a, int* b) {
    return *a - *b;
}

void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {
    for (int i = 0; i < n; ++i) {
        nums1[m + i] = nums2[i];
    }
    qsort(nums1, nums1Size, sizeof(int), cmp);
}
时间复杂度：O((m + n)log(m + n))，排序序列长度为m + n，套用快速排序的时间复杂度即可，平均情况为O((m + n)log(m + n))。
空间复杂度：O(log(m + n)),排序序列长度为m + n，套用快速排序的空间复杂度即可，平均情况为O(log(m + n))。

方法2：双指针（将两个数组看成队列）
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {
    int p1 = 0, p2 = 0;
    int nums3[m + n];
    while (p1 < m || p2 < n) {
        if (p1 == m) {
            nums3[p1 + p2 - 1] = nums2[p2++];
        } else if (p2 == n) {
            nums3[p1 + p2 - 1] = nums1[p1++];
        } else if (nums1[p1] < nums2[p2]) {
            nums3[p1 + p2 - 1] = nums1[p1++];
        } else {
            nums3[p1 + p2 - 1] = nums2[p2++];
        }
    }
    for (int i = 0; i < m + n; ++i) {
        nums1[i] = nums3[i];
    }
}
时间复杂度：O(m + n)，指针移动单调递增，最多移动m + n次。
空间复杂度：O(m + n)，需要建立长度为m + n的中间数组nums3。
    

方法3：反向双指针（避免正向双指针的覆盖）
nums1的后半部分是空的，可以直接覆盖而不会影响结果。因此可以指针设置为从后向前遍历，每次取两者之中的较大者放进nums1的最后面。
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {
    int p1 = m - 1, p2 = n - 1;
    int tail = m + n - 1;
    while (p1 >= 0 || p2 >= 0) {
        if (p1 == -1) {
            nums1[tail--] = nums2[p2--];
        } else if (p2 == -1) {
            break;
        } else if (nums1[p1] > nums2[p2]) {
            nums1[tail--] = nums1[p1--];
        } else {
            nums1[tail--] = nums2[p2--];
        }
    }
} 
时间复杂度：O(m + n)，指针移动单调递减，最多移动m + n次。
空间复杂度：O(1)，原地修改，不需要额外空间。

void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){
    int i = m - 1;
    int j = n - 1;
    int tail = nums1Size - 1;
    while((i + 1) && (j + 1))
    {
        if(nums1[i] > nums2[j])
            nums1[tail--] = nums1[i--];
        else
            nums1[tail--] = nums2[j--];
    }

    if(j >= 0)
    {
        memcpy(nums1,nums2,(j + 1) * sizeof(int));
    }
}

void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){
    int i = m - 1;
    int j = n - 1;
    int tail = nums1Size - 1;
    while((i + 1) && (j + 1))
    {
        if(nums1[i] > nums2[j])
            nums1[tail--] = nums1[i--];
        else
            nums1[tail--] = nums2[j--];
    }

    while(j >= 0)
    {
        nums1[j] = nums2[j];
        --j;
    }
}
```

# 189.轮转数组

题目：给定一个整数数组nums，将数组中的元素向右轮转 k个位置，其中k是非负数。

```c
示例1:
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
示例2:
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]

提示：
1 <= nums.length <= 105
-231 <= nums[i] <= 231 - 1
0 <= k <= 105
```

```c
方法1：暴力解法（超出时间限制）
1.先记录下最后一个元素，将前边的元素移动到后面进行逐个替换（倒着替换），再讲记录的最后一个元素放在第一个上面；
2.步骤1执行k次。
void rotate(int* nums, int numsSize, int k){
    k %= numsSize;
    for(int i = 0; i < k; i++)
    {
        int temp = nums[numsSize - 1];
        for(int j = numsSize - 2; j >= 0 ; j--)
        {
            nums[j + 1] = nums[j];
        }
        nums[0] = temp;
    }
}
时间复杂度：O(n*n)，替换k轮，每次执行numsSize - 1次。
空间复杂度：O(1),没有使用凝额外空间。

方法2：使用额外空间
使用一块和数组一样大的中间数组，将数组中的值进行按newArr[(i + k) % numsSize] = nums[i]规律赋值，然后拷贝回原数组。
void rotate(int* nums, int numsSize, int k) {
    int newArr[numsSize];
    for (int i = 0; i < numsSize; ++i) {
        newArr[(i + k) % numsSize] = nums[i];
    }
    for (int i = 0; i < numsSize; ++i) {
        nums[i] = newArr[i];
    }
}
时间复杂度：O(n)，进行了两次numsSize循环。
空间复杂度：O(n),使用了和数组长度一样的数组。

方法3：环状替换
1.使用一个变量作为中间交换的桥梁，每次交换完的值可以再次使用；（前面的值赋值给后面的值要记录下后面的值，防止被覆盖）
2.最多执行k轮，每轮之间值相差k个，当本轮循环到和起始条件一样就执行下一轮，直到数组中的全部元素遍历完结束；
3.结束条件：当遍历的元素个数和数组中的个数相等时，表明每个元素都被遍历了一次，就跳出结束循环。
void swap(int* a, int* b)
{
    int t;
    t = *a;
    *a = *b;
    *b = t;
}
void rotate(int* nums, int numsSize, int k)
{
    int count = 0;        //记录遍历的元素的个数
    int temp, p;        //
    k %= numsSize;
    for (int start = 0; start < k; start++)
    {
        temp = nums[start];
        p = start;
        do
        {
            p = (p + k) % numsSize; //更新
            swap(&temp, &nums[p]);
            cnt++;                  //统计遍历的元素的个数
        } while (p != start);
    if (count == numsSize)    break;
    }
}
时间复杂度：O(n),看起来是双层循环但每个元素只遍历了一次，n是数组的长度。
空间复杂度：O(1),只需要1个常数空间。
    
方法4：数组翻转
由于翻转的对称性质，先将前半段翻转，再将后半段进行翻转，最后翻转整个数组；
//交换
void my_swap(int* a,int* b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

//翻转
void exchange(int* nums,int start,int end)
{
    while(start < end)
    {
        my_swap(&nums[start],&nums[end]);
        ++start;
        --end;
    }
}

void rotate(int* nums, int numsSize, int k)
{
    k %= numsSize;
    exchange(nums, 0, numsSize - k - 1);
    exchange(nums, numsSize - k, numsSize - 1);
    exchange(nums, 0, numsSize - 1);
}
时间复杂度：O(n)，数组中每个元素被翻转2次，n为数组的长度。
空间复杂度：O(1)，没有使用额外空间。
```

# 989.数组形式的整数加法

题目：整数的数组形式num是按照从左到右的顺序表示其数字的数组。

例如，对于num = 1321 ，数组形式是 [1,3,2,1] 。
给定num，整数的数组形式，和整数k，返回整数num + k的数组形式 。

```c
示例1：
输入：num = [1,2,0,0], k = 34
输出：[1,2,3,4]
解释：1200 + 34 = 1234
示例2：
输入：num = [2,7,4], k = 181
输出：[4,5,5]
解释：274 + 181 = 455
示例3：
输入：num = [2,1,5], k = 806
输出：[1,0,2,1]
解释：215 + 806 = 1021
 
提示：
1 <= num.length <= 104
0 <= num[i] <= 9
num 不包含任何前导零，除了零本身
1 <= k <= 104
```

```c
方法1：逐个位置相加
1.计算要创建数组的长度，长度是数字和字母长度的最大值 + 1；
2.创建好之后数字和字母的低位相加，相加好的值放到从数组索引为0的值开始；
3.由于循环的判断条件是数组长度，可能数字的长度长，最后数字会存在高位还有值没有处理，需要单独加入到要返回的数组中；（这里也可以判断条件设置为两者没有计算完一致计算）
4.最后进行翻转；
注意点：
1.需要注意的是最后的*returnSize决定了要返回几位数字，数字的位数是从前往后数；（数组从索引0开始数）
2.这个要写什么想不起来了。
void exchange(int* num, int start,int end)
{
    while(start < end)
    {
        int temp = num[start];
        num[start] = num[end];
        num[end] = temp;
        ++start;
        --end;
    }
}

int* addToArrayForm(int* num, int numSize, int k, int* returnSize) {
    int temp = k;
    int len = 0;
    while(temp)
    {
        temp /= 10;
        ++len;
    }
    int lenmax = (len > numSize ? (len + 1) : (numSize + 1));
    int* res = (int*)malloc(sizeof(int) * lenmax);
    *returnSize = 0;	//需要注意的是最后的*returnSize决定了要返回几位数字，数字的位数是从前往后数
    //低位的值给高位，最后翻转
    for (int i = numSize - 1; i >= 0; --i) {
        int sum = num[i] + k % 10;
        k /= 10;
        if (sum >= 10) {
            k++;            //进位加1
            sum -= 10;      //减去进位的1，就是10
        }
        res[(*returnSize)++] = sum;    //低位加的值给高位
    }
    //计算k的剩余值
    for (; k > 0; k /= 10) {
        res[(*returnSize)++] = k % 10;
    }
    exchange(res,0,*returnSize - 1);
    return res;
}

方法2：将整个数组k加入数组表示表示数组的最低位逐个计算
例子：123 + 912，我们把它表示成[1,2,3+912]。然后，我们计算3+912=915。5留在当前这一位，将910/10=91 以进位的形式加入下一位。然后，我们再重复这个过程，计算 [1,2+91,5]。我们得到93，3留在当前位，将90/10=9以进位的形式加入下一位。继而又得到[1+9,3,5]，重复这个过程之后，最终得到结果[1,0,3,5]。 
void exchange(int* num, int start,int end)
{
    while(start < end)
    {
        int temp = num[start];
        num[start] = num[end];
        num[end] = temp;
        ++start;
        --end;
    }
}

int* addToArrayForm(int* num, int numSize, int k, int* returnSize) {
	int temp = k;
	int len = 0;
	while (temp)
	{
		temp /= 10;
		++len;
	}
	int lenmax = (len > numSize ? (len + 1) : (numSize + 1));
	int* res = (int*)malloc(sizeof(int) * lenmax);
	*returnSize = 0;
	for (int i = numSize - 1; i >= 0 || k > 0; --i, k /= 10) {
		if (i >= 0) {
			k += num[i];
		}
		res[(*returnSize)++] = k % 10;
	}

	exchange(res, 0, *returnSize - 1);
	return res;
}
时间复杂度：O(max(n,logk))，其中n为数组的长度。（这里理解有问题）
空间复杂度：O(1)，除了返回值之外没有使用额外空间。
```

