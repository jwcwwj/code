# 1.泛型编程

实现一个通用的交换函数。

```c++
//方法1：函数重载
void Swap(int& left, int& right)
{
	int temp = left;
	left = right;	
	right = temp;
}

void Swap(double& left, double& right)
{
	double temp = left;
	left = right;	
	right = temp;
}

void Swap(char& left, char& right)
{
	char temp = left;
	left = right;	
	right = temp;
}
```

使用函数重载虽然可以实现，但是有以下几个不好的地方：  

1.重载的函数仅仅只是类型不同，代码的复用率比较低，只要有新类型出现时，就需要增加对应类型的函数；

2.代码的可维护性比较低，一个出错可能所有的重载均出错。

那能否**告诉编译器一个模子，让编译器根据不同的类型利用该模子来生成代码**呢？

```c++
//方法2：函数模板
template<typename T>
void my_swap(T& a, T& b)
{
	T temp = a;		//这里不能使用引用，使用引用之后改变temp的值就是改变a的值
	a = b;
	b = temp;
}
```

泛型编程概念：编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础。



# 2.函数模板

## 2.1函数模板概念

函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本。



## 2.2函数模板格式

```c++
template<typename T1, typename T2,......,typename Tn>
返回值类型 函数名(参数列表){}

//函数模板实现通用的交换函数
template<typename T>
void Swap( T& left, T& right)
{
	T temp = left;
	left = right;
	right = temp;
}
```

注意：typename是用来定义模板参数关键字，也可以使用class。(切记：不能使用struct代替class) 



## 2.3函数模板的原理 

函数模板是一个蓝图，它本身并不是函数，是编译器用使用方式产生特定具体类型函数的模具。所以其实模板就是

将本来应该我们做的重复的事情交给了编译器。

函数模板产生具体函数的过程：根据传入的参数推演出来函数中的具体类型，根据函数模板和推演出的具体类型产

生实际的函数。

在编译器编译阶段，对于模板函数的使用，编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用。

比如：当用double类型使用函数模板时，编译器通过对实参类型的推演，将T确定为double类型，然后产生一份

专门处理double类型的代码，对于字符类型也是如此。



## 2.4函数模板的实例化

用不同类型的参数使用函数模板时，称为函数模板的实例化。模板参数实例化分为：隐式实例化和显式实例化。



### 2.4.1隐式实例化

隐式实例化概念：让编译器根据实参推演模板参数的实际类型。

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

template<typename T>
void my_swap(T& a, T& b)
{
	T temp = a;		//这里不能使用引用，使用引用之后改变temp的值就是改变a的值
	a = b;
	b = temp;
}

int main()
{
	int a = 10;
	int b = 20;
	my_swap(a, b);
	cout << a << endl;	//20
	cout << b << endl;	//10
	double a1 = 1.2;
	double b1 = 2.3;
	my_swap(a1, b1);
	cout << a1 << endl;	//2.3
	cout << b1 << endl;	//1.2
	return 0;
	//my_swap(a, a1);	//error，报错：没有与参数列表匹配的函数模板"my_swap”实例参数类型为:(int, double)
	//上面语句不能通过编译，因为在编译期间，当编译器看到该实例化时，需要推演其实参类型，
	//通过实参a将T推演为int，通过实参a1将T推演为double类型，但模板参数列表中只有一个T，
	//编译器无法确定此处到底该将T确定为int 或者 double类型而报错
	//注意：在模板中，编译器一般不会进行类型转换操作
}
```

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

//上面问题的解决方案
template<typename T>
T my_add(T a, T b)			//这里形参不能是引用
{
	return a + b;
}

int main()
{
	int a = 10;
	int b = 20;
	double a1 = 1.2;
	double b1 = 2.3;

	//my_add(a, a1);	//error，报错：没有与参数列表匹配的函数模板"my_swap”实例参数类型为:(int, double)
	//解决方案：
	//1.用户自己来强制转化
	cout << my_add(a, (int)a1) << endl;		//11,double转int发生数据丢失
	//2.使用显示实例化
	cout << my_add<int>(a, a1) << endl;		//11
	return 0;
}
```

```c++
//解释为什么模板函数形参不能是引用
//第一个代码：
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

int my_add(int& a, int& b)
{
	return  a + b;
}

int main()
{
	int a = 10;
	double b = 20;
	//cout << my_add(a, (int)b) << endl;	//error，报错：非常量引用的初始值必须为左值
	cout << my_add(a, (int&)b) << endl;		//输出结果错误，应该为30，结果是10
	//原因：浮点数在内存中的存储和整形不一样，double转int发生精度就是
    //验证：修改b的值每次测试出来的值都不一样
    return 0;
}


//第二个代码：
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

int my_add(char& a, char& b)
{
	return  a + b;
}

int main()
{
	int a = 10;
	char b = 20;
	cout << my_add((char&)a, b) << endl;	//输出结果：30
	return 0;
}
//引用作为形参：强制转换为引用实参传递
//引用作为实参：强制转换不是引用进行传参，错误原因：我们不能对一个强制转换后的值进行引用传递。这是因为，强制转换后的值实际上不是一个变量，它只是一个表达式的结果，并没有和任何内存位置绑定。
//如果我们将其作为引用类型的函数参数传递，函数内部会试图将该引用绑定到一个对象上，但由于它没有内存位置，因此会导致编译错误。强制转换之后的值有没有常性是取决于原始表达式或变量是否具有常性。
//如果原始表达式或变量是常量表达式或常量变量，则强制转换后得到的值也具有常性；否则，强制转换后的值不具有常性，可以被修改。
//在C++中，强制转换是否会创建临时变量取决于转换的类型和目标类型。通常情况下，如果转换的结果需要存储在一个新的变量中，则会创建一个临时变量来存储转换后的结果。
```

总结：强制转换不推荐使用，容易出错。（强制转换不同的编译器可能会产生不同的结果，无法确保安全和正确。）



### 2.4.2显示实例化

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

template<typename T>
T my_add(T a, T b)			
{
	return a + b;
}

int main()
{
    int a = 10;
	int b = 20;
	double a1 = 1.2;
	double b1 = 2.3;
    //显示实例化
	cout << my_add<int>(a, a1) << endl;		//11
    return 0;
}
```



## 2.5模板参数的匹配原则

匹配规则：

1.优先匹配普通函数：当模板函数和普通函数都可以实现的时候，选择使用普通函数；

2.如果函数模板可以实例化一个更加匹配的函数，则走实例化：模板实例化没有类型转换，普通函数要是发生类型

转换，选择函数模板；

3.强制实例化：如果指明需要进行实例化，则直接实例化：要是想使用函数模板，进行显示实例化；



解释函数模板存不存在隐式转换：

函数模板和普通函数一样，可以支持隐式转换。如果模板参数的类型和函数参数的类型不匹配，编译器会尝试进行

隐式类型转换，以符合函数的参数要求。

如果类型不匹配，编译器会尝试进行隐式类型转换，如果无法转换成功编译器将会报错。



```c++
//第一种观点：模板函数不可以进行自动类型推导，普通函数可以进行自动类型推导
//第二种观点：模板函数可以进行自动类型推导
//第二种观点代码：
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

template<typename T>
T max(T a, T b)
{
	std::cout << "max(T, T) called." << std::endl;
	return (a > b) ? a : b;
}

template<typename T1, typename T2>
auto max(T1 a, T2 b) -> decltype((a > b) ? a : b)
{
	std::cout << "max(T1, T2) called." << std::endl;
	return (a > b) ? a : b;
}

int main()
{
	int i = 10;
	double d = 3.14;

	std::cout << "max(i, d) = " << max(i, d) << std::endl; // 自动类型转换，输出 10
	std::cout << "max(d, i) = " << max(d, i) << std::endl; // 自动类型转换，输出 10
	return 0;
}
//输出结果：
//max(T1, T2) called.
//max(i, d) = 10
//max(T1, T2) called.
//max(d, i) = 10

//这个之后要查找资料学习
```

总结：普通函数可以进行类型推导，模板函数也可以进行类型推导。



### 2.5.1decltype关键字（这个关键字的字面意思就是类型获取）

`decltype` 是 C++11 引入的一个关键字，用于获取表达式的类型。它可以在编译期间推断出表达式的类型，并将

其作为结果返回。

`decltype` 的语法如下：

```c++
decltype(expression)
```

其中 `expression` 是需要获取类型的表达式。

`decltype` 的工作方式如下：

- 如果 `expression` 是一个标识符，`decltype(expression)` 返回该标识符的类型。

- 如果 `expression` 是一个函数调用，`decltype(expression)` 返回该函数调用表达式的返回类型。

- 如果 `expression` 是一个变量名加上成员选择操作符（`.`或`->`）和成员名，`decltype(expression)` 返回

  该成员的类型。

- 对于其他表达式，`decltype(expression)` 返回表达式的类型。

下面是一些示例说明 `decltype` 的使用：

```c++
int x = 10;
double y = 3.14;

decltype(x) a;  // 推导为 int 类型
decltype(y) b;  // 推导为 double 类型

decltype(x + y) c;  // 推导为 double 类型

struct Foo 
{
    int value;
};

Foo foo;
decltype(foo.value) d;  // 推导为 int 类型

int add(int a, int b);
decltype(add(x, 5)) e;  // 推导为 int 类型，根据函数返回值类型推导

decltype(std::cout << "Hello") f;  // 推导为 std::ostream& 类型
```

在上述示例中，`decltype(x)` 推导为 `int` 类型，`decltype(y)` 推导为 `double` 类型。`decltype(x + y)` 推导

为 `double` 类型，因为在表达式中存在 `double` 类型的变量。`decltype(foo.value)` 推导为 `int` 类型，根据结

构体成员的类型推导。`decltype(add(x, 5))` 根据函数返回值类型进行推导，结果为 `int` 类型。

`decltype(std::cout << "Hello")` 推导为 `std::ostream&` 类型，根据流输出操作的返回类型推导。

通过使用 `decltype`，可以在编译期间获取表达式的类型，方便在模板函数、泛型编程以及迭代器等场景下进行类

型推导和处理。





# 3.类模板

## 3.1类模板的定义格式

```c++
template<class T1, class T2, ..., class Tn>
class 类模板名
{
	// 类内成员定义
};
```



## 3.2类模板的实例化

```c++
//类模板
//动态顺序表
//注意：Vector不是具体的类，是编译器根据被实例化的类型生成具体类的模具
template<class T>
class Vector
{
public:
	Vector(size_t capacity = 10)
		: _pData(new T[capacity])
		, _size(0)
		, _capacity(capacity)
	{}
	// 使用析构函数演示：在类中声明，在类外定义。
	~Vector();
	void PushBack(const T& data)；
	void PopBack()；
	// ...
	size_t Size() { return _size; }
	T& operator[](size_t pos)
	{
		assert(pos < _size);
		return _pData[pos];
	}
private:
	T* _pData;
	size_t _size;
	size_t _capacity;
};
// 注意：类模板中函数放在类外进行定义时，需要加模板参数列表
template <class T>
Vector<T>::~Vector()
{
	if (_pData)
		delete[] _pData;
	_size = _capacity = 0;
}

int main()
{
	// Vector类名，Vector<int>才是类型
	Vector<int> s1(10);
	Vector<double> s2;
}
```

注意点：类模板只存在显示实例化，不存在隐式实例化。



