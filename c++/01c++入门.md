# 1.命名空间namespace

使用命名空间的目的是**对标识符的名称进行本地化**，以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的。  

命名空间定义：使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的。 



##  1.1命名空间定义

```c++
//1.普通的命名空间
namespace N1 	//N1为命名空间的名称
{
	//命名空间中的内容，既可以定义变量，也可以定义函数
	int a = 10;
	int Add(int left, int right)
	{
		return left + right;
	}
}

//2.命名空间可以嵌套
namespace N2
{
	int a = 20;
	int b = 30;
	int Add(int left, int right)
	{
		return left + right;
	}
	namespace N3	//嵌套命名空间
	{
		int c = 40;
		int d = 50;
		int Sub(int left, int right)
		{
			return left - right;
		}
	}
}

//3.同一个工程中允许存在多个相同名称的命名空间,编译器最后会合成同一个命名空间中。
namespace N1
{
	int Mul(int left, int right)
	{
		return left * right;
	}
}
```

注意：一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中。



## 1.2命名空间的使用

```c++
void test1()
{
	//命名空间的三种使用方式：
	//01加命名空间名称及作用域限定符	推荐使用	个人喜欢第一种
    cout << "N1::a = " << N1::a << endl;	//10
	cout << "N2::N3::c - N2::b = " << N2::N3::Sub(N2::N3::c, N2::b) << endl;	//10
	
    //cout << "N2::N3::c - N2::b = " << N2::N3::Sub(c, N2::b) << endl;			//error
	//cout << "N2::N3::c - N2::b = " << N2::N3::Sub(N2::N3::c,b) << endl;		//error
	
    //02使用using将命名空间中成员引入	推荐使用，但一般不使用	在空间嵌套多的时候使用，一般使用第一种
	using N2::N3::c;
	cout << "N2::N3::c - N2::b = " << N2::N3::Sub(c, N2::b) << endl;	//10
	using N2::b;
	cout << "N2::N3::c - N2::b = " << N2::N3::Sub(c, b) << endl;		//10
	using N1::a;
	cout << a << endl;		//10
    
	//03使用using namespace 命名空间;	将名称引入	不推荐使用		在多人合作开发的时候容易产生冲突
	using namespace N1;
	cout << a << endl;	//10
}
```

总结：在使用的时候多使用作用域限定符（::），少使用using将命名空间引入。



# 2.c++输入和输出的使用

cout标准输出（输出到控制台），cin标准输入（从键盘输入）。 

```c++
使用的前提：
#include <iostream>
using namespace std;

//输入：cin >> a;
//输出：cout << a << endl;
```



# 3缺省参数

## 3.1概念

缺省参数是**声明或定义函数时**为函数的**参数指定一个默认值**。在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的实参。  



## 3.2缺省参数分类

```c++
//全缺省参数
void TestFunc(int a = 10, int b = 20, int c = 30)
{
	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	cout << "c = " << c << endl;
}

//半缺省参数
void TestFunc1(int a, int b = 10, int c = 20)
{
	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	cout << "c = " << c << endl;
}
```

注意点：

**1.使用半缺省参数的时候从右到左参数依次给出默认值，不能间隔着给出。**

**2.缺省参数不能在函数声明和定义中同时出现。（在声明和定义中参数一样也是错的）**

```cpp
//测试代码：缺省函数在声明和定义中同时出现的时候
#include <iostream>
using namespace std;

void TestFunc1(int a = 5, int b = 10, int c = 20);

void TestFunc1(int a =5, int b = 10, int c = 20)
{
	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	cout << "c = " << c << endl;
}

int main()
{
	TestFunc1();
	return 0;
}
//上面的代码在运行的时候是错的。
//即使在声明和定义的时候参数是一样的，在运行的时候也会报错，报错为：重定义默认参数。
```

```c++
//a.h
void TestFunc(int a = 10);
// a.c
void TestFunc(int a = 20)
{}
//注意：如果申明与定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确定到底该用哪个缺省值。
```



**3.缺省值必须是常量或全局变量；**

解释：C++ 中函数的缺省参数是指在函数定义时为某些参数指定默认值，在调用该函数时可以不传递这些参数，使得调用者可以更加灵活地使用函数。

在定义函数时，可以为某些参数指定默认值。但需要注意的是，**这个默认值必须是编译时就可以确定其值的表达式，例如常量、全局变量、字符串等值，不能是需要在运行时才能计算出来的表达式或变量，否则会导致编译错误。**

这主要是因为在调用函数时，如果没有传递某些参数，**编译器**会使用函数定义中指定的默认值来初始化这些参数，而**这个默认值需要在编译时就能够决定，因为编译器需要在编译时确定函数的入口地址以及需要分配的栈空间大小等信息**。

**因此，为函数参数指定缺省值时必须使用编译时常量或全局变量，而不能使用需要在运行时才能确定值的表达式或变量。**

```c++
//下面是一个简单的 C++ 函数，其中 num1 和 num2 是函数参数，而 value 是一个使用了缺省值的参数：
int add(int num1, int num2, int value = 0) 
{
    return num1 + num2 + value;
}
//在上述代码中，value 参数使用了缺省值 0。因为编译器需要在编译时确定函数的入口地址及分配的栈空间大小等信息，
//所以在函数定义时指定的缺省值必须是编译时常量或全局变量。
//如果将 value 的缺省值设为非常量或非全局变量的表达式，例如：
int add(int num1, int num2, int value = num1 + num2)
{
    return num1 + num2 + value;
}
//则编译时会报错，提示缺省参数的默认值不是常量或全局变量，无法在编译时确定其值。
//总之，在使用函数缺省值时，为了保证编译能够通过，需要将缺省值设置为编译时能够确定的常量或全局变量。
```

在 C++ 中，编译时可以确定的值主要包括以下几种类型：

1. 字面量：例如整数、浮点数、字符、布尔值等。
2. constexpr 变量：constexpr 指定的变量必须在编译时就能确定其值，因此可以在函数参数缺省值等需要编译时常量的地方使用。
3. 枚举常量：枚举类型中定义的枚举值属于编译时常量，可以用于需要编译时常量的地方。
4. sizeof 运算符：sizeof 运算符可以计算出类型或变量的大小，因此**在大多数情况下**可以在编译时确定。
5. 类型转换：有些类型转换可以在编译时完成，例如将整数常量赋值给浮点数类型。
6. 预处理指令：预处理阶段会替换掉一些符号，例如 #define 定义的宏在编译时被替换成的值就是编译时常量。

总之，在编译时可以确定的值一般是指在编译阶段就可以计算出来的值，而不需要等到程序运行时才能确定的值。这些值可以在函数参数缺省值、数组大小、结构体成员等需要编译时常量的地方使用。 

```cpp
//比如：数组大小
int arr[sizeof(int)];
```

**4.c语言不支持。（编译器不支持）**



## 3.2constexpr 关键字学习（c++11新添加的）

C++11 引入了 constexpr 关键字，用于指定变量或函数在编译时就能够确定其值，并可以用于数组大小、模板参数等需要编译时常量的地方。

constexpr 变量是一种特殊的变量类型，其值必须在编译时就可以确定。可以通过使用 constexpr 关键字来定义一个 constexpr 变量。

```c++
constexpr int n = 10;
//在上述代码中，变量 n 使用了 constexpr 关键字，表示其是一个编译时常量，其值必须在编译时就能够确定。
//因此，可以将 n 用于数组大小、函数参数缺省值等需要编译时常量的地方。
//除了简单的字面值，constexpr 变量也可以基于其他 constexpr 变量通过一系列的计算得到。
constexpr int m = n + 5;
//在上述代码中，变量 m 的值可以在编译时被计算出来，因为 n 是一个编译时常量。

//需要注意的是，在使用 constexpr 关键字定义函数时，函数必须满足以下条件：
//1.函数的返回值类型必须是字面值类型。
//2.函数体中只能使用 constexpr 变量或字面值作为参数。
//3.函数体中的语句必须是一条返回语句，且返回值必须是常量表达式。
//总之，constexpr 关键字可以用于定义编译时常量，提高程序的性能和效率。需要注意的是，constexpr 变量和函数必须满足一定的限制条件，否则会导致编译错误。

//表达式
//算术运算、位运算、关系运算、逻辑运算等常规的运算操作。例如：
constexpr int a = 1 + 2 + 3;
constexpr bool b = true && false;
//函数调用：如果函数满足一定的限制条件，即返回类型是字面值类型并且参数都是常量表达式，那么该函数调用也是一个常量表达式。例如：
constexpr int square(int x) 
{
    return x * x;
}
constexpr int c = square(3);	//或者int c = square(3);也是可以的 
//需要注意的是，constexpr 关键字可以用于指定一个变量或函数是否是一个编译时常量，如果变量或函数不满足某些限制条件，则可能无法在编译时确定其值，导致编译错误。
```

```cpp
//错误的：
int n = 10;
constexpr int m = n + 5;
//上面的报错：表达式的计算结果不是常数 或者 表达式必须含有常量值

//正确的：
constexpr int n = 10;
constexpr int m = n + 5;
```

是的，constexpr 关键字是在 C++11 中添加的。C++11 引入了 constexpr 关键字，用于指定变量或函数在编译时能够确定其值，并可以用于数组大小、模板参数等需要编译时常量的地方。

**在 C++11 之前，如果需要定义编译时常量，通常使用 #define 预处理指令或枚举类型来实现，但这种方式有一些限制和不足，例如无法进行类型检查、无法处理复杂的表达式、无法进行调试等。**

通过引入 constexpr 关键字，C++11 提供了一种更加灵活、类型安全、易于调试的方式来定义编译时常量和可在编译时计算的表达式。需要注意的是，在使用 constexpr 关键字定义变量或函数时，需要满足一些限制条件，例如返回类型必须是字面值类型(常量)、函数体中只能使用 constexpr 变量或字面值(int a = 5;a是字面值)，作为参数、函数体中的语句必须是一条返回语句等，否则会导致编译错误。

```c++
void test2()
{
	//constexpr关键字，c++11新赠的
	//constexpr关键字可以让一个变量变成编译时常量
	constexpr int a = 5;
	int arr[a];
	for (int i = 0; i < a; i++)
	{
		arr[i] = i;
	}
	for (int i = 0; i < a; i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
}
```



# 4.函数重载

函数重载：是函数的一种特殊情况，C++允许**在同一作用域中**声明几个功能类似的同名函数，这些同名函数的形参列表(参数个数 或 类型 或 顺序)必须不同，常用来处理实现功能类似数据类型不同的问题。（重点：在同一个作用域中才会出现函数重载）

```c++
int add(int a, int b)
{
	return a + b;
}

//参数类型不同
int add(char a, int b)
{
	return a + b;
}

//参数顺序不同
int add(int a, char b)
{
	return a + b;
}

//参数个数不同
int add(int a, char b,int c)
{
	return a + b + c;
}
```

注意点：函数重载不能根据返回值不同区分。

原因：c++底层函数名是参数名和函数参数组合起来的，没有包含返回值。

C语言没办法支持重载，因为同名函数没办法区分。而C++是通过函数修饰规则来区分，只要参数不同，修饰出来的名字就不一样，就支持了重载  。



c语言为什么不能支持函数重载？

C语言没有函数重载的主要原因是因为在C语言设计时，为了避免增加编译器的复杂度以及保持和已有代码的兼容性，没有提供函数重载的特性。

函数重载的实现需要编译器根据函数名字、参数类型、个数和顺序等信息来生成唯一的函数符号（mangled name）进行函数匹配。然而，在C语言中函数名字所在的符号表中只保存了函数名字本身，没有保存函数的完整信息，因此C语言编译器无法实现函数重载。

此外，函数重载也会增加函数调用的复杂度，例如在C++中，函数重载会导致编译器需要进行函数匹配，这会影响程序的性能。在C语言中，由于没有函数重载，函数调用可以更高效地进行。



c++中函数重载底层是怎么处理的？

在C++中，函数重载是指在同一作用域内定义多个具有相同名称但参数列表不同的函数。

底层处理函数重载的机制称为名称修饰（Name Mangling）或函数符号重载（Function Overloading）。这个机制会根据函数的参数类型、参数个数和参数顺序等信息，生成一个独一无二的符号来标识每个不同的重载函数。

在编译阶段，编译器会根据函数的参数列表，将函数名进行修饰。修饰过程会根据函数的参数类型进行映射，使得每个函数都有一个唯一的名称。修饰的方式因编译器而异，不同的编译器可能采用不同的修饰规则。

在链接阶段，链接器会根据函数调用的名称修饰和函数定义的名称修饰进行匹配，找到对应的函数实现。

总结起来，函数重载底层的处理方式是通过名称修饰，使得每个重载函数都具有唯一的标识符，从而在编译和链接过程中能够正确地区分和调用不同的重载函数。



# 5.函数名字修饰

C++中函数重载底层是怎么处理的？  

在C++中，函数重载是通过名称修饰（name mangling）来实现的。当编译器遇到函数名相同但参数类型不同的函数时，会使用不同的算法为每个函数生成一个唯一的名称，这个过程称为名称修饰。名称修饰的结果会将不同的函数区分开来，以便在链接阶段正确地识别和调用不同的函数。

具体来说，在C++中，名称修饰的规则会根据函数的参数类型、顺序和数量等因素进行计算，生成一个唯一的函数名。这个唯一的函数名也被称为函数符号（function symbol）。



一个程序要运行起来需要经历4个阶段：

**预处理：**

预处理指的是在编译过程中，编译器在实际编译代码之前执行的一系列操作，主要包括以下三个方面:

1. 文件包含（#include）：指将多个文件合并成一个文件。在编译过程中，当编译器遇到 #include 指令时，就会将指定的头文件内容包含进来，形成一个新的源文件，从而确保头文件所包含的函数和变量可以在当前文件中被使用。
2. 宏定义（#define）：指将一些常量、函数或表达式处理成宏。在编译过程中，编译器会将所有的宏定义替换到程序中，在某些情况下，宏定义可以简化程序的编写，并提高可读性。
3. 条件编译（#ifdef、#ifndef 等）：指根据条件选择性地编译部分代码。在编译过程中，使用 #ifdef、#ifndef 等条件编译指令可以让编译器在编译时根据条件进行选择性的编译，这样可以让程序适应不同的平台、环境或者需求。

这些预处理工作的主要目的是为了减少代码重复、提高代码的可维护性和可读性、增强代码的灵活性和可移植性。预处理阶段产生的输出结果被称为**预处理器输出**，它是编译过程中的重要一环。在预处理阶段结束后，编译器将对生成的预处理文件进行编译、汇编、链接等操作，**最终生成可执行文件**。



**编译：**

编译阶段是编译器在预处理阶段之后执行的阶段，主要分为以下几个步骤：

1. 词法分析：将源代码按照字符序列切分成一个一个的单词（token），并将其分类、打标记。
2. 语法分析：将词法分析生成的 token 序列转换成语法树并进行语义分析，检查代码是否符合语法规范、是否存在语义错误等。如果存在错误，则会给出相应的错误提示。
3. 代码优化：对代码进行优化，使生成的机器码更加高效。优化过程主要包括常量合并、表达式简化、循环展开、函数内联等。
4. 代码生成：将优化后的中间代码转换成目标机器码，并生成可执行文件。代码生成的过程主要包括寄存器分配、指令选择、代码填空等。

总的来说，编译阶段主要是将高级语言编写的源代码翻译成目标机器能够直接执行的机器码，这个过程中会进行词法分析、语法分析、代码优化和代码生成等多个步骤，**最终生成可执行文件**。该过程的关键在于将高级的抽象语言转换成低级的机器码，以便计算机能够理解和执行。



**汇编：**	objdump -S a.out	查看源码（汇编）

汇编阶段是编译器生成目标文件的过程。在编译器中，经过编译阶段和链接阶段处理后，我们得到了一个可执行文件。其中，**编译阶段产生的输出文件被称为“目标文件”。**

汇编阶段主要完成两个任务：将汇编指令翻译成机器码，以及将汇编指令和数据段组合成目标文件。

具体来说，**汇编器（Assembler）会读取由编译器生成的汇编代码文件，对其进行处理，将它们转化成机器指令，同时生成目标文件。**在该过程中，汇编器会进行符号解析、重定位、代码生成等操作。

1. 符号解析

符号解析指的是将代码中定义的变量、函数等标识符与其相应的地址进行关联和处理，建立起符号表。符号表中记录了用到的符号的名称、地址和类型等信息，在后续的过程中会用到。

  2.重定位

重定位指的是将目标文件中的相对地址转换成绝对地址，使得代码能够在正确的内存地址空间执行。在重定位的过程中，汇编器会使用符号表中记录的信息进行修正，保证所有的引用都指向正确的地址。

  3.代码生成

代码生成指的是将汇编代码翻译成机器指令，并将它们存储在目标文件中。在代码生成过程中，汇编器会将汇编代码中的伪操作（pseudo-op）转换成相应的机器指令，同时使用符号表进行地址计算和处理，最终得到目标文件。

**总之，汇编阶段将编译器产生的中间代码翻译成目标机器能够理解的机器指令，并将它们组合成目标文件。汇编器的输出结果是一个目标文件，它已经完成了从高级语言到机器码的完整转换。**



**链接：**

链接阶段是编译器将多个目标文件以及库文件链接为一个可执行文件的过程。在这个过程中，编译器将所有的目标文件（包括主程序和库文件等）组装成一个单独的可执行文件，该过程被称为“链接”。

链接阶段主要完成以下几项工作：

1. 符号解析和重定位

在链接阶段，编译器将处理所有目标文件中未被解析的符号，并将每个符号与其相应的地址关联起来，使得最终生成的可执行文件能够正确地运行。这个过程被称为“符号解析和重定位”。

   2.垃圾回收

在编译多个目标文件的过程中，有些代码可能没有被使用到或引用到，链接阶段会进行垃圾回收的处理，将这些无用的代码从可执行文件中清除。

注意：

C++是一门不自带垃圾回收机制的编程语言，即程序员需要手动管理内存。在C++中，程序员需要自行跟踪和管理内存的分配和释放。这种手动管理内存的方式，虽然可以让程序员更加精细地控制内存的使用，但同时也存在漏洞的风险，如非法内存访问等问题。

然而，C++程序员可以使用第三方库或框架，使用其提供的垃圾回收机制来管理内存。比如，在C++程序中可以使用Boehm-Demers-Weiser (BDW)垃圾回收器，它是一个开源的、跨平台的垃圾回收机制，可以自动识别需要回收的内存并释放它。此外，还有一些商用的C++垃圾回收机制，如IBM的C++垃圾回收器等。

需要注意的是，使用垃圾回收机制也有一些缺点。比如，由于垃圾回收器需要遍历整个内存空间来寻找要释放的内存区域，因此会消耗较多的CPU资源。此外，垃圾回收器不能保证及时地释放所有的无用内存，可能会导致内存泄漏等问题。

总之，C++没有自带垃圾回收机制，需要程序员手动管理内存。但程序员可以使用第三方库或框架来实现垃圾回收功能。在使用垃圾回收机制时，需要权衡其带来的效率和正确性等方面的影响。

   3.函数库的链接

在链接阶段，编译器还会将用到的函数库的代码链接到可执行文件中。编译器通常提供了大量的标准函数库，如数学库、字符串操作库、IO库等，这些函数库通常编译成已经被汇编的目标文件，它们可以被任何程序调用。在链接阶段，编译器会将这些函数库中的代码链接到可执行文件中，实现对库函数的调用。

   4.生成可执行文件

**在完成以上步骤之后，编译器会将所有的目标文件和函数库链接起来，并生成一个可执行文件。该文件可以直接在操作系统上运行。**

**总之，链接阶段是编译器将多个目标文件以及库文件链接为一个可执行文件的过程，主要包括符号解析和重定位、垃圾回收、函数库的链接和可执行文件的生成等步骤。这个过程是将目标代码联合起来并生成可执行文件的关键步骤。**



补充 / 注意：

1.在linux下，采用gcc编译完成后，函数名字的修饰没有发生改变；

2.在linux下，采用g++编译完成后，函数名字的修饰发生改变，编译器将函数参数类型信息添加到修改后的名字中；

3.对比Linux会发现，windows下C++编译器对函数名字修饰非常诡异，但道理都是一样的；

4.通过这里就理解了C语言没办法支持重载，因为同名函数没办法区分。而C++是通过函数修饰规则来区分，只要参数不同，修饰出来的名字就不一样，就支持了重载；

5.另外我们也理解了，为什么函数重载要求参数不同！而跟返回值没关系。



# 6.extern "C"

作用：在c++中将一个函数按照c的风格来编译。

```c++
//函数声明，使用 extern "C"
extern "C" void func(int n);

//函数定义，不使用 extern "C"
void func(int n) 
{
    //函数实现
}
//在函数声明中必须加加extern "C"，在函数实现中可加可不加。
```



有时候在C++工程中可能需要将某些函数按照C的风格来编译，在函数前加extern "C"，意思是告诉编译器，将该函数按照C语言规则来编译。比如：tcmalloc是google用C++实现的一个项目，他提供tcmallc()和tcfree两个接口来使用，但如果是C项目就没办法使用，那么他就使用extern “C”来解决。

```cpp
extern "C" int Add(int left, int right);

int main()
{
	Add(1,2);
	return 0;
}
```

链接时报错：error LNK2019: 无法解析的外部符号**_Add**，该符号在函数 _main 中被引用。

原因：只有Add函数的申明，没有Add函数的实现。



# 7.引用

## 7.1引用的概念和学习内容

在C++中，引用是一种特殊的变量类型，它可以被看作是一个已存在变量的别名（即给一个变量取多个名字），可以通过引用来修改原有变量的值或传递变量参数。使用引用可以简化程序代码，提高程序的可读性和可维护性。

为了学习C++中的引用，你需要掌握以下几个知识点：

1.引用的定义：定义一个引用变量需要在变量名前面加上&符号。例如，int &a = b; 就是将整型变量b的别名赋值给变量a，这样a和b指向同一个内存地址，对a的修改也会影响到b的值。

2.引用的特点：引用必须在定义时初始化，一旦引用被初始化后，就不能再指向其他内存地址，它始终引用同一个地址。同时，引用不占用额外的内存空间，它只是指向原有变量的指针。

3.引用的用途：使用引用可以使程序更简洁，减少拷贝操作，避免程序中因多次复制而引起的性能损失。常见的引用应用场景包括函数参数传递、作为函数返回值、以及在STL的迭代器中使用等。

4.引用与指针的区别：引用和指针都可以用来访问内存中的变量，但它们有很多不同之处。引用与指针相比更加安全、易于使用，**同时也没有指针的灵活性和通用性。**

解释：

引用相对于指针而言，缺少了一些指针的灵活性和通用性。

首先，引用在定义时必须被初始化，而且只能初始化为某个已经存在的变量。因此，引用不像指针那样能够动态地指向不同的对象或者空对象。这也就意味着，引用不能像指针一样用于动态内存分配等场景，从而导致了引用的使用范围受到了一定的限制。

其次，指针可以进行指针运算、比较两个指针的大小等操作，而引用则没有这样的能力。指针可以通过数组的形式进行访问，这对于实现复杂的数据结构非常重要，比如链表、树等数据结构，以及多维数组的处理等场景。而引用则无法实现这样的功能。

总体来说，虽然引用比指针更加简洁和易用，但是在某些场景下，指针的灵活性和通用性是不可或缺的。因此，在C++编程中，我们需要根据具体情况选择使用引用还是指针。



**引用的使用：类型& 引用变量名(对象名) = 引用实体；**

注意：**引用类型**必须和引用**实体**是**同种类型**的    



## 7.2常引用

**常引用是指在定义引用变量时，在变量类型前面加上const关键字，表示该引用变量所引用的内存空间不可被修改。**具体来说，常引用的特点如下：

1. 定义方式：常引用的定义和普通引用的定义方式相同，但在定义时需要添加const关键字。
2. **初始化：常引用必须在定义时进行初始化，并且一旦初始化完成后，就无法再修改所引用的对象。**
3. **作用：常引用通常用于函数参数传递和返回值中，可以避免函数中意外修改传入的参数或者返回的值。**
4. **特殊性质：常指针对所引用的对象实行只读访问，因此不能通过常引用修改原始对象的值，这样可以保证程序运行的安全性。**

总之，常引用在C++编程中是非常重要的概念，它可以帮助我们避免无意中修改已经定义好的变量，从而提高了程序的健壮性和可维护性。在实际的开发过程中，我们应该尽可能地使用常引用，以避免程序中由于意外的变量修改导致的问题。

```c++
void test3()
{
	//常引用
	const int a = 10;
	//int& ra = a; // 该语句编译时会出错，a为常量
	const int& ra = a;
	
    //int& b = 10; // 该语句编译时会出错，b为常量
	const int& b = 10;
	
    double d = 12.34;
	//int& rd = d; 		//该语句编译时会出错，类型不同
	const int& rd = d;	//赋予常性的值类型是可以不同的（下面会有解释）
}

//拆解：
double d = 10.5；
//int& rd = d; 	//该语句编译时会出错，类型不同

const int& rd = d;
//由于rd是一个const int类型的常量引用，而d是一个double类型的变量，因此编译器会进行类型转换，将d的值从double类型转换为int类型，然后在后台创建一个const int类型的临时变量，将转换后的整数值存储在该临时变量中，并将该临时变量的地址绑定到常量引用rd上。拆解如下：
int temp = static_cast<int>(a);  //将a的值从double类型转换为int类型，并且通过强转后的整数值存储在 temp中
const int& b = temp;          //将临时变量temp的地址绑定到常量引用b上
//最终，b引用了一个const int类型的临时变量，其值为10。需要注意的是，由于double类型的变量a被转换为int类型的值10，
//因此在这个过程中发生了精度损失。在实际应用中，可能需要对精度损失进行额外处理。
```

临时变量：临时变量是指在表达式求值的过程中，由系统自动产生的、临时存放表达式结果的变量。通常情况下，这些变量不需要我们手动定义或管理，而是由编译器隐含地生成和使用。

```c++
//1.数值类型的运算：对于两个数值类型的变量相加、相减、相乘、相除等操作，编译器会生成临时变量来存储中间结果。
int a = 10;
int b = 20;
int c = a + b; 	//编译器会生成临时变量tmp来存储a+b的结果，并将其赋值给c

//2.函数调用：当调用一个函数时，编译器会为函数参数创建临时变量，并将这些变量传递给函数。在函数返回值时，也会产生临时变量来存储函数的返回值。
int add(int a, int b)
{
    return a + b;
}

int x = 10;
int y = 20;
int z = add(x, y); 		//在调用add函数时，编译器会为a和b创建临时变量，用于存储x和y的值

//3.运算符重载：在对某些对象类型进行运算时，可能需要重载运算符。在运算符重载函数中，也会产生临时变量来存储中间结果。
class Point 
{
public:
    int x;
    int y;

    Point operator+(const Point& p) const 
    {
        Point tmp;
        tmp.x = x + p.x;
        tmp.y = y + p.y;
        return tmp; 	//在这里会产生一个临时变量tmp，用于存储x+p.x和y+p.y的结果
    }
};

Point p1{10, 20};
Point p2{30, 40};
Point p3 = p1 + p2; 	//在这里会调用重载后的operator+函数，并生成一个临时变量来存储返回值

//总之，临时变量是编译器在求解表达式时自动生成的、短暂存在的变量。我们在编写程序时不需要显式定义临时变量，但需要注意它们的使用和生命周期。
```

总之，临时变量是指在表达式求值过程中由编译器自动生成的、临时存放表达式结果的变量。这些变量通常无需我们手动管理，**但在一些需要优化程序性能的场景下，我们可以手动将临时变量转化为静态变量或者全局变量，以提高程序的效率。**



## 7.3使用场景

### 7.3.1引用作为函数参数

```c++
#include <iostream>
#include <string>

using namespace std;

//引用作为函数参数
void print(string& s) 
{
    cout << s << endl;
}

int main() 
{
    string str = "Hello, world!";
    print(str); 	//使用引用作为函数参数，避免了进行字符串的拷贝操作
    return 0;
}

```



### 7.3.2引用作为返回值

```c++
#include <iostream>
#include <vector>

using namespace std;

//引用作为函数返回值
vector<int>& create_vector() 
{
    static vector<int> vec; 	//静态变量，避免返回一个局部变量的引用(这里的静态变量是要确保vec对象在返回的时候，返回值使用引用返回的时候要确保出函数的时候vec对象还存在)
    for(int i = 0; i < 10; i++)
    {
        vec.push_back(i);
    }

    return vec;
}

int main() 
{
    vector<int>& vec = create_vector(); 	//使用引用作为函数返回值，避免进行vector的拷贝操作
    for(auto x : vec) 
    {
        cout << x << " ";
    }
    cout << endl;
    return 0;
}
```

引用做函数参数和返回值可以**避免拷贝构造和析构函数的开销，从而提高程序的性能。在使用引用作为函数参数或返回值时，需要注意生命周期的问题，确保引用指向的对象始终存在。**

注意：**如果函数返回时，出了函数作用域，如果返回对象还未还给系统，则可以使用引用返回，如果已经还给系统了，则必须使用传值返回。** （传值会发生值拷贝，传引用不会发生值拷贝）

```c++
//有引用的时候（这个代码是重点）
#include <iostream>

using namespace std;

int& Add(int a, int b)
{
	int c = a + b;
	return c;
}

int main()
{
	int &ret = Add(1, 2);
	Add(3, 4);
	cout << "Add(3, 4) is :" << ret << endl;
	return 0;
}
//输出结果：Add(3, 4) is : 7
//解释：有引用的时候，ret指向的是Add函数，是一直指向的，函数的值变化了，引用也就变化了。
```



```c++
//没有引用的时候（这个代码也是重点）
#include <iostream>
#include <vector>

using namespace std;

int& Add(int a, int b)
{
	int c = a + b;
	return c;
}

int main()
{
	int ret = Add(1, 2);
	Add(3, 4);
	cout << "Add(1, 2) is : " << ret << endl;
	return 0;
}
//输出结果：Add(1, 2) is : 3
//解释：没有引用的时候，相当于是把函数计算后的结果赋值给ret
```



## 7.4传值和传引用、返回值和返回引用效率比较

以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实参或者返回变量的一份临时的拷贝，**因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。**  

### 7.4.1参数：传值和传引用

```c++
#include <time.h>
struct A
{ 
    int a[10000]; 
};
void TestFunc1(A a){}
void TestFunc2(A& a){}

void test4()
{
	A a;
	//以值作为函数参数
	size_t begin1 = clock();
	for (size_t i = 0; i < 1000000; ++i)
		TestFunc1(a);
	size_t end1 = clock();
	//以引用作为函数参数
	size_t begin2 = clock();
	for (size_t i = 0; i < 1000000; ++i)
		TestFunc2(a);
	size_t end2 = clock();
	//分别计算两个函数运行结束后的时间
	cout << "TestFunc1(A)-time:" << end1 - begin1 << endl;	//TestFunc1(A) - time:25487
	cout << "TestFunc2(A&)-time:" << end2 - begin2 << endl;	//TestFunc2(A&) - time:18
}
```



### 7.4.2返回值：值返回和参数返回

```c++
#include <time.h>
struct A
{ 
    int a[10000]; 
};

A a;
//值返回
A TestFunc1() { return a; }
//引用返回
A& TestFunc2() { return a; }

void test5()
{
	//以值作为函数的返回值类型
	size_t begin1 = clock();
	for (size_t i = 0; i < 1000000; ++i)
		TestFunc1();
	size_t end1 = clock();
	//以引用作为函数的返回值类型
	size_t begin2 = clock();
	for (size_t i = 0; i < 1000000; ++i)
		TestFunc2();
	size_t end2 = clock();
	//计算两个函数运算完成之后的时间
	cout << "TestFunc1 time:" << end1 - begin1 << endl;		//TestFunc1 time : 49019
	cout << "TestFunc2 time:" << end2 - begin2 << endl;		//TestFunc2 time : 21
}
```

通过上述代码的比较，发现**传值和指针在作为传参以及返回值类型上效率相差很大，传引用远远优于传值。**  



## 7.5引用和指针的区别

引用的底层实现：通过指针实现，在底层引用就是指针。

引用本身是有空间的，空间的大小和指针的大小相同，不会去开辟所指向的实体的空间。（对于引用，编译器在底层自动做解引用，不需要手动实现）

引用的使用方式：按照语法规定使用，不能按照指针的使用方式操作引用。

引用是const指针。



在**语法概念上**引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。

在**底层实现上**实际是有空间的，因为**引用是按照指针方式来实现**的。



具体如下：

1.引用在定义时必须初始化，指针没有要求。

2.引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体。

3.没有NULL引用，但有NULL指针。

**4.在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4个字节)。**

```c++
#include <iostream>
using namespace std;

int main()
{
	int a = 10;
	int& b = a;
	int* c = &a;
	cout << sizeof(a) << endl;	//4
	cout << sizeof(b) << endl;	//4
	cout << sizeof(c) << endl;	//64位结果是8，32位结果是4
	return 0;
}

```

**5.引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小。**

6.有多级指针，但是没有多级引用。

7.访问实体方式不同，指针需要显式解引用，引用编译器自己处理。

8.引用比指针使用起来相对更安全。

**9.作用：指针主要用于动态内存分配和指向函数等用途，而引用主要用于函数参数传递和返回引用值等用途。**



## 7.6面试题：在c++中引用使用起来比指针更加安全体现在哪些方面？

在C++中，使用引用相对于指针有以下几个方面的安全性优势：

1. 空引用安全：引用必须在声明时初始化，并且不能被重新赋值为nullptr或者空引用。这意味着**引用不会指向空地址，避免了空指针解引用带来的潜在问题。**
2. 避免非法操作：引用不能被重新赋值，即不能改变绑定对象。这样可以避免一些错误操作，比如意外修改了指针的指向，导致程序出现未定义行为。
3. 无需解引用：使用引用时可以直接通过变量名来访问对象，而不需要像指针那样先进行解引用操作。这样降低了代码的复杂性和出错的可能性。
4. 自动内存管理：引用不需要像指针那样手动分配和释放内存，它们只是对象的别名。这样可以减少内存泄漏和悬挂指针等问题，简化了内存管理。
5. 隐式传递信息：通过引用参数传递对象时，可以明确表达参数是作为输入还是输出，提高了代码的可读性。而指针需要显式地注明const来表达参数只是输入，并且需要考虑指针为空的情况。

尽管引用在上述方面具有安全性优势，但在某些场景下，指针也是必需的，例如需要动态分配内存、数组访问和函数多态等情况。在选择使用引用还是指针时，应根据具体情况权衡利弊。



# 8.内联函数

## 8.1内联函数的学习内容

学习内联函数需要掌握以下内容：

1. 内联函数的定义：内联函数是一种特殊的函数，它会**在调用处直接将函数体展开，以避免函数调用的开销。**通常使用 inline 关键字来声明内联函数。
2. 内联函数的优点：内联函数能够消除函数调用的开销，提高程序的执行效率；内联函数的代码通常比较短小，使得代码更加简洁易读。
3. 内联函数的限制：内联函数并非总是适用于所有函数。因为内联函数在调用时会将函数体直接嵌入到调用处，这可能导致代码体量增大，反而降低程序效率；另外，**内联函数也有一定的编译器支持限制，特别是在递归、复杂结构或多线程情况下，内联函数的行为可能不可预见。**
4. **内联函数的实现：内联函数的实现包括了编译器对函数体的嵌入和在链接器中去重。在编译时，内联函数的函数体会被直接嵌入到每个调用处，因此在目标代码中不会出现实际的函数调用。在链接时，编译器将会对相同的内联函数进行去重合并，从而减少代码的大小和复杂度。**
5. 内联函数的使用：内联函数通常用于简单、频繁被调用的函数，例如访问器、操作符、短小的工具函数等。需要避免使用过于复杂的代码或具有递归性质的函数作为内联函数。

总的来说，学习内联函数需要理解内联函数的定义、优缺点、实现方式和使用场景。在编写代码时，我们应该根据具体情况进行权衡和选择，避免滥用内联函数，从而达到优化程序执行效率的目的。



## 8.2vs2017下查看和设置

在函数前增加inline关键字将其改成内联函数，在编译期间编译器会用函数体替换函数的调用。

查看方式：

1.在release模式下，查看编译器生成的汇编代码中是否存在**call Add**；

2.在debug模式下，需要对编译器进行设置，否则不会展开(因为debug模式下，编译器默认不会对代码进行优化，以下给出vs2017的设置方式)  

找到文件右键点击属性，进入优化，把内联函数扩展修改成只适用于 __inline (/Ob1)

![image-20230531152930136](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230531152930136.png) 



## 8.3内联函数的优缺点和特性

内联函数的优点：

1. 内敛函数调用开销小：每次函数调用都会有一定的开销，包括压栈、跳转等操作，而内联函数是将函数体直接嵌入到调用处，避免了这些开销，从而提高程序的执行效率。
2. 代码简洁易读：内联函数的代码通常比较短小，通过使用内联函数，可以使代码更加简洁易读，从而提高代码的可维护性和可重用性。
3. 避免函数调用带来的一些问题：一些代码语句在函数调用时可能会出现不同的错误或警告，例如空指针的使用等。而使用内联函数可以避免一些函数调用带来的潜在问题。

内联函数的缺点：

1. 可能会导致代码体量增大：对于较长的内联函数，其代码将被重复嵌入到多个调用处，并可能导致目标代码体积增大，从而降低程序的性能。（空间性能降低，时间性能提高）

2. **编译器支持可能有限：不是所有的编译器都支持内联函数，甚至部分编译器可能会忽略 inline 关键字。因此，在使用内联函数时需要注意编译器的支持情况。**

3. 编写和维护难度大：内联函数虽然会提高代码的执行效率，但其编写和维护的难度也相应增加。内联函数需要遵守一些约束条件，例如**不能有循环、switch 等语句，并且需要考虑多个调用处的问题。**

4. **调试困难**：内联函数展开后的代码可能会影响调试工作，使程序的调试难度增加。

总的来说，内联函数可以在一定程度上提高程序的执行效率，但是需要权衡其优缺点并根据具体情况进行选择。**在编写代码时，我们需要考虑代码的长度、调用频繁程度、编译器支持等因素，从而确定是否使用内联函数。**



内联函数的优点在于可以提高程序的执行效率，减少函数调用开销、代码简洁易读、避免函数调用带来的潜在问题等。这些优点使得代码更具可维护性，因为内联函数通常是短小精悍的代码段，易于理解和修改。

然而，内联函数的缺点在于可能会导致代码冗长，影响程序的可读性和可维护性。内联函数在每个调用处都会被复制一份代码，**并且内联函数的声明与定义必须在同一个头文件中，否则可能导致链接错误。**这些特性使得内联函数可能不太容易维护。

**综合考虑，内联函数在一定程度上易于维护，但需要注意一些限制和约束条件。在使用内联函数时，需要谨慎分析代码的特性和需求，并根据具体情况进行使用和选择。如果内联函数的代码过于复杂或者涉及到一些特殊情况，建议将其定义为普通函数进行调用，以保证代码的可读性和可维护性。**

 

内敛函数的特性：

1.inline是一种**以空间换时间**的做法，省去调用函数额开销。所以**代码很长**或者有**循环递归**的函数不适宜使用作为内联函数；

2.**inline对于编译器而言只是一个建议，编译器会自动优化，如果定义为inline的函数体内有循环/递归等等，编译器优化时会忽略掉内联；**

3.**inline不能声明和定义分离（要写在一个头文件中），分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会找不到。**  

解释：

内联函数的声明和定义必须写在同一个头文件中。这是因为内联函数的实现方式是将函数的代码直接嵌入到函数调用处，所以编译器需要在编译期间知道函数的具体实现以便进行代码的优化和生成。如果内联函数的声明和定义分别写在不同的源文件中，编译器无法确定函数的实现位置，就无法嵌入函数的代码，也就无法实现内联函数的功能。因此，为了正确使用内联函数，我们必须在同一个头文件中同时定义函数的声明和实现。**如果需要在多个源文件中共享内联函数，可以将其定义在一个公共头文件中，并在需要使用该函数的源文件中包含该头文件。这样，编译器就能正确地嵌入内联函数的代码，实现内联函数的功能。**

``` c++
//头文件
inline int add(int a, int b);

//源文件
int add(int a, int b) 
{
    return a + b;
}

//会出现链接错误，提示多个定义符号
duplicate symbol '__Z3addii' in:
    file1.o
    file2.o
ld: 1 duplicate symbol for architecture x86_64
//这是因为编译器无法将内联函数的代码插入到函数调用处，所以只能在每个源文件中生成一份函数实现。
//而由于多个源文件都包含了内联函数的声明，这样就导致了重复定义的错误。
//因此，要实现内联函数的功能，必须将其定义也写在头文件中，并确保所有使用该函数的源文件都包含了该头文件。
//这样编译器才能正确解析内联函数，并将其代码插入到函数调用处。(还有别的实现不同的编译器可能会报错可能会忽略作为普通函数使用。)
```

为了避免代码冗余，链接器会进行重复代码的去重操作。



## 8.4内联函数的使用场景

内联函数应该在以下场景下使用：

1. 频繁调用的函数：当一个函数需要频繁调用时，每次调用都会有一定的开销，包括堆栈的压入和弹出、跳转等。如果将该函数定义为内联函数，则可避免这些开销。

2. 短小精悍的函数：内联函数通常适用于代码较短小的函数，这样可以减少程序的指令数，从而提高程序的执行效率。

3. **函数嵌套调用（循环）：当函数中需要多次嵌套调用其他函数时，将这些函数定义为内联函数可以避免多次函数调用造成的额外开销，提高程序的执行效率。**

   解释：

   ```c++
   #include <iostream>
   
   inline int add(int a, int b)
   {
       return a + b;
   }
   
   int main()
   {
       int num1 = 5, num2 = 10, sum;
   
       //内联函数在单个函数中的使用
       sum = add(num1, num2);
       std::cout << "Sum = " << sum << std::endl;
   
       //内联函数在函数嵌套调用中的使用
       for(int i = 0; i < 5; i++) {
           sum = add(sum, i);
       }
   
       std::cout << "New sum = " << sum << std::endl;
   
       return 0;
   }
   ```

4. **模板函数：C++ 中的模板函数通常是使用内联方式实现的，因为模板函数通常非常短小，而且需要实例化多次，使用内联函数可以避免重复生成相同的代码和链接器的过程。**

总之，内联函数适用于频繁调用且代码简单、精炼的函数，以及需要多次嵌套调用和实例化的函数。但是也需要注意，**滥用内联函数可能会导致程序体积变大，降低程序的性能和可读性。因此，在使用内联函数时，需要谨慎权衡其优缺点并根据具体情况进行选择。**



## 8.5宏的优缺点以及如何替代宏

宏是 C/C++ 中一种常见的预处理指令，它可以让程序员定义一个可以在代码中多次使用的代码片段，从而提高代码的可读性和复用性。

宏的优点：

1. 提高代码的可读性：通过定义宏可以将一些重复出现的代码片段封装起来，将其命名为一个有意义的符号名称，从而更加直观和易于理解。
2. 提高代码的可维护性：当代码需要修改时，我们**只需要修改宏定义语句，就可以将整个程序中所有的该宏调用进行修改**，而不需要逐个进行修改。
3. 提高代码的复用性：通过定义宏，可以将经常使用的代码片段进行封装，这样可以大大提高代码的复用性。

宏的缺点：

1. 可读性下降：**过多的宏定义**可能会导致代码过于复杂，不易阅读和理解，使得代码难以维护。
2. **可移植性差：由于编译器对于宏的处理方式不同，因此在不同的编译环境下可能会产生意想不到的问题，从而导致代码的可移植性较差。**
3. **容易出错：由于宏是预处理器处理的，它并不会检查宏定义和宏调用之间的类型和表达式问题，因此在使用过程中容易出现错误。**
4. **不方便调试：在程序运行过程中，宏并不会被编译器记录和追踪，即使出现了错误，也很难通过调试工具定位到其位置。**

综上所述，虽然宏作为一种代码复用机制，在一些情况下是非常有用的，但是在过度使用时，也可能产生不好的影响。因此，在使用宏时，需要根据实际情况进行评估，权衡其优缺点，尽量避免出现上述缺点，从而写出高质量的代码。



**上面的优缺点概括为一下几点：**

缺点：

**1.可移植性差，不同的编译器对于宏的处理方式不同，因此在不同的编译环境下可能会产生不同的意想不到的问题，从而导致代码的可移植性较差；**

**2.容易出错，由于宏是预处理器处理的，预处理器不会检查宏定义和宏调用之间的类型和表达式问题，因此在使用过程中容易出现错误；**

**3.不方便调试：在程序运行过程中，宏并不会被编译器记录和追踪，即使出现了错误，也很难通过调试工具定位到其位置；**

**4.宏定义的个数过多的时候会导致代码过于复杂，不易于阅读、理解和维护代码；**

优点：

**5.修改代码的时候只需要修改宏，这样可以减少修改的地方，提高了代码的可维护性；**

**6.给宏定义一个有意义的名字，从而更加直观和易于理解。**



宏是 C/C++ 中一种常见的预处理指令，虽然它可以提高代码的可读性和复用性，但同时也存在一些缺点。为了避免宏带来的问题，我们可以考虑使用以下几种方法来替代宏。

1.使用函数：

将宏定义的代码片段封装成函数，这样可以避免宏出现的问题。**函数可以进行参数类型和返回类型的检查**，可以提高程序的可读性和健壮性。而且，**函数能够方便地进行调试和错误处理**。

2.使用 const 变量：

使用 const 变量来代替宏定义中的常量。const 变量有类型和作用域，**可以受到编译器的类型检查，而宏则不受任何类型检查。在使用 const 变量时，也不用担心它会被多次定义或者多次声明的问题。**

3.**使用枚举类型：**

**枚举类型可以实现和宏类似的功能。它可以声明一个常量，并限制它的取值范围。枚举类型可以在程序中多次使用，而不用担心重复定义的问题。**

解释：

```c++
#include <iostream>

//用枚举类型替换宏定义
enum {
    MAX_LENGTH = 100,
    MIN_VALUE = 0,
    MAX_VALUE = 1000,
};

int main() {
    int arr[MAX_LENGTH];
    for (int i = MIN_VALUE; i <= MAX_VALUE; ++i) {
        std::cout << i << " ";
    }
    return 0;
}
```

枚举类型解释：

在上面的代码中，我们使用匿名枚举类型来定义了三个常量 MAX_LENGTH、MIN_VALUE 和 MAX_VALUE，分别代表最大长度、最小值和最大值。

**这些常量在程序中可以直接使用，并且不会出现与其他变量或符号重复定义的问题。**

相比宏定义，使用枚举类型的优势在于可以得到编译器的类型检查和保证，更加安全可靠，并且使得代码更具可读性和维护性。

**同时，使用 enum 可以避免一些宏定义可能带来的副作用，例如符号重定义和类型错误等。**

**需要注意的是，匿名枚举类型中定义的每个常量均为整型，如果需要自定义类型，需要定义一个命名枚举类型并为每个枚举值显式地指定一个值。**

4.使用 inline 函数：

inline 函数本质上是一种编译器的优化手段，它可以把函数体内的代码直接插入到函数调用处，从而避免了函数调用的开销。而且，**inline 函数和宏定义类似，可**

**以直接将代码片段插入到程序中，但它受到类型检查和作用域限制。**

5.使用constexpr关键字（c++11新添加的）：

constexpr 可以用来替代宏定义中的一些常量。在 C++11 中引入了 constexpr 关键字，它可以在编译期间计算出表达式的值，并将其保存为常量。使用 

constexpr 代替宏定义可以避免宏定义可能带来的一些问题，例如宏定义可能会导致程序员错误地输入不合法的类型、符号重复定义等问题。constexpr 变量必须

在编译时能够确定其值，因此，对于包含循环、递归、动态分配内存等运行时特性的表达式，不能使用 constexpr 来定义常量。

总之，虽然宏定义在一些情况下是非常有用的，但是在过度使用时，也可能带来不利的影响。因此，我们可以使用以上几种方法来替代宏，提高代码的可读性、可

维护性以及可移植性。



总结宏的优缺点：

优点：

1.增强代码的复用性；

2.提高性能。

缺点：

1.不方便调试宏。（因为预编译阶段进行了替换）

2.导致代码可读性差，可维护性差，容易误用；

3.没有类型安全的检查。



# 9.auto关键字（c++11新添加的）

## 9.1auto关键字的学习内容

auto 关键字是 C++11 引入的新特性，它可以让编译器自动推断变量类型，从而避免了需要手动指定变量类型的繁琐过程。学习 auto 关键字需要掌握以下几个方面：

1. auto 的基本语法：auto 变量名 = 表达式；
   - 使用 auto 关键字定义变量时，需要在等号右侧给出一个表达式，auto 关键字将自动推断该表达式的类型，并将其作为变量类型。
2. auto 的注意事项：
   - 自动推断的类型必须能够明确确定，否则程序将无法通过编译。
   - **在使用 auto 定义变量时，初始化表达式的类型和变量的类型并不一定完全相同，但是必须是兼容的类型，否则编译器将会报错。**
   - **在使用 auto 定义变量时，需要考虑变量的引用类型或者指针类型，避免产生意想不到的问题。**
3. auto 的应用场景：
   - 在模板编程中，常常需要用到具有通用性的代码，并需要自动推断变量类型。
   - **在拥有复杂类型的代码中，使用 auto 可以简化代码，并使其更易于阅读和维护。**
   - **在需要追求高效性能的代码中，使用 auto 可以避免不必要的类型转换和复制，提高程序的性能。**

总之，学习 auto 关键字需要深入理解其基本语法和注意事项，并熟练掌握其应用场景。只有这样，我们才能更好地运用 auto 关键字来简化代码、提高程序效率。



## 9.2auto关键字在c语言和c++语言中的区别

在 C 语言中，`auto` 关键字是一种存储类说明符，用于定义具有自动存储周期的本地变量（局部变量）。C++ 也支持这种用法，但是在 C++11 中引入了新的 `auto` 关键字，用于表示自动类型推断。因此，在 C 和 C++ 中，`auto` 关键字有着不同的含义和用法。（c++11出现之后auto关键字在c语言和c++语言中的用法不同）

1.c语言中的auto关键字

在 C 语言中，`auto` 关键字是一种默认的存储类说明符，用于定义函数内的本地变量。当我们使用 `auto` 定义变量时，编译器会为该变量分配一个内存空间，可以在程序执行到该变量所在的函数时自动创建并初始化，当程序离开该函数作用域时，其内存空间会被自动释放。

```c++
void func() 
{
    auto int i = 0; // 自动推导为 int 类型，和int i = 0;作用一样，写与不写auto没什么区别
    ...
}

```

2.c++11语言中的auto关键字

而在 C++11 中，`auto` 关键字的用法发生了变化。C++11 引入了 `auto` 关键字作为一种新的类型说明符，用于自动推断变量的类型，可以避免需要手动指定变量类型的过程。使用 `auto` 关键字定义变量时，编译器会根据变量声明语句右侧的表达式自动推导出变量的类型。

```c++
auto a = 1; // 自动推导为 int 类型
auto d = 3.14; // 自动推导为 double 类型
auto d = 3.14f; // 自动推导为 float 类型
auto str = "hello"; // 自动推导为 const char* 类型
```

需要注意的是，在 C++ 中，使用 `auto` 关键字定义变量时，变量的初始值必须与其类型兼容，否则编译器会报错。此外，还可以使用 `auto&` 和 `auto*` 来分别表示引用和指针类型的自动类型推断。

总之，虽然在 C 和 C++ 中都支持 `auto` 关键字，但是它们的含义和用法是不同的。在 C 中，`auto` 仅作为一个默认的存储类说明符；而在 C++11 中，`auto` 则成为了一种新的类型说明符，用于自动推断变量的类型。



## 9.3auto关键字与指针类型和引用类型结合起来使用

用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&。 

```c++
void test6()
{
	//auto关键字与指针类型和引用类型结合起来使用
	int x = 10;
	auto a = &x;
	auto* b = &x;
	auto& c = x;
	//指针不区分auto和auto*是因为右边&取地址符
	cout << typeid(a).name() << endl;	//int*
	cout << typeid(b).name() << endl;	//int*
	cout << typeid(c).name() << endl;	//int	因为x是int类型的，别名的类型和实体的类型一样
	cout << typeid(x).name() << endl;	//int 实体
	*a = 20;
	*b = 30;
	c = 40;
}
```



## 9.4auto关键字使用的注意事项

1.**使用auto定义变量时必须对其进行初始化**，在编译阶段编译器需要根据初始化表达式来推导auto的实际类型。因此auto并非是一种“类型”的声明，而是一个类型

声明时的“占位符”，编译器在编译期会将auto替换为变量实际的类型；

2.用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&；（指针不区分auto和auto指针是因为右边&取地址符）

3.当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，**因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量。**  

```c++
void TestAuto()
{
	auto a = 1, b = 2;
	auto c = 3, d = 4.0; // 该行代码会编译失败，因为c和d的初始化表达式类型不同
}
```

4.atuo推导类型可能不符，需要显示指定右边表达式的类型；

```c++
auto x = 0;		//推导出来时int，但是我们想要float
auto x = 0.0f; 	//显式指定类型为 float
```

5.auto关键字和const关键字结合使用时，需要注意推导出来的类型是否是 const；

```c++
const auto x = 123; // 推导出来的类型是 const int
```

6.不要滥用 auto关键字：尽管 `auto` 关键字可以帮助我们简化代码，提高开发效率，但是在使用时还是需要谨慎，不要滥用。特别是在需要清晰、明确地表达变量类型时，应该避免使用 `auto`，以提高代码的可读性和可维护性。

7.auto与指针和引用结合起来使用：

**用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&。**



## 9.5auto关键字不能推导的场景

1.**auto不能作为函数的参数**，只能用于变量的声明和初始化。如果需要在函数中使用自动推导，可以考虑使用函数模板和类型推导来实现。

```c++
//代码编译失败，auto不能作为形参类型，因为编译器无法对a的实际类型进行推导
void TestAuto(auto a){}
```

2.**auto不能直接用来声明数组**。

```c++
void TestAuto()
{
	int a[] = {1,2,3};
	auto b[] = {4，5，6};		//error
}
```

3.为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法。

```c++
//在c++11的文件中
#include <iostream>

using namespace std;

int main()
{
	auto int a = 10;	//error，报错：类型说明符的组合无效
	return 0;
}
```

4.auto在实际中最常见的优势用法就是跟以后会讲到的C++11提供的新式for循环，还有lambda表达式等进行配合使用。



# 10.基于范围的for循环（c++11新添加的）

## 10.1语法结构

```c++
for (decl : coll)
{
    statement;
}
//其中，decl 是用于声明一个变量，coll 是容器名称，statement 是针对容器中每个元素的语句。在每次循环时，变量 decl 将被赋值为容器中的一个元素。
```



## 10.2注意事项

1.for循环迭代的范围必须是确定的：对于数组而言，就是数组中第一个元素和最后一个元素的范围；对于类而言，应该提供begin和end的方法，begin和end就是for循环迭代的范围；

```c++
void TestFor(int array[])
{
	for(auto& e : array)
	cout<< e <<endl;
}
//这个代码中的for循环就是没有范围的，是错的。（数组作为参数传参之后会变成指针，没有数组的范围了）
```

2.for循环与普通循环类似，可以使用continue来结束本次循环，也可以使用break来跳出整个循环。

3.迭代的对象要实现++和==（或者实现!=的操作）的操作。（这里在迭代器的时候会告诉如何实现）



## 10.3使用的地方

1.迭代器：迭代的对象要实现++和==的操作；

```c++
#include <iostream>
#include <vector>

int main()
{
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // 遍历 vector 容器
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it)
    {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
//输出结果：1 2 3 4 5
```



### 10.3.1自己实现一个容器类和迭代器类（重点复习 + 代码实现）

```c++
#include <iostream>

// 定义迭代器类
class MyIterator 
{
public:
	MyIterator(int* ptr) 
		: ptr_(ptr) 
	{}

	// 解引用操作符
	int& operator*() const 
	{ 
		return *ptr_; 
	}  
	//这里解释一下在解引用运算符重载中为什么是使用引用返回，而不是值返回：
	//在解引用操作符中使用引用返回（返回类型为int&）是为了允许对迭代器指向的元素进行读写操作。
	//解引用操作符的作用是获取迭代器指向的元素的引用。如果我们使用值返回（返回类型为int），则会返回元素的副本，而不是直接操作原始元素。
	//通过使用引用返回，我们可以直接操作原始元素，而不是副本。这样，在循环中使用解引用操作符时，我们可以修改容器中的元素，而不仅仅是读取它们的值。
	//因此，为了允许对迭代器指向的元素进行读写操作，并在循环中正确地修改容器中的元素，我们需要使用引用返回而不是值返回。
	//通俗的解释：值返回只能进行读操作，而不能进行写操作，引用返回不仅可以进行读操作，还可以进行写操作。

	// 前置递增操作符
	MyIterator& operator++() 
	{
		++ptr_; 
		return *this;	//this是一个指向当前对象的指针，this指针指向调用该成员函数的对象，*this表示的是MyIterator对象
	}
	//这里解释一下在前置运算符重载中为什么是使用引用返回，而不是值返回：
	//通过使用引用返回我们可以直接修改当前迭代器对象的状态，并返回修改后的对象的引用。
	//这样在循环中使用前缀递增操作符时，迭代器会被正确地更新，以便遍历容器的下一个元素
	//因此，为了保持前缀递增操作符的预期行为，并在循环中正确地更新迭代器对象，我们需要使用引用返回而不是值返回。

	 
	// 不等于操作符
	bool operator != (const MyIterator& other) const 
	{ 
		return ptr_ != other.ptr_; 
	}   

private:
	int* ptr_; // 指向当前迭代元素的指针
};

// 定义容器类型
class MyContainer 
{
public:
	//构造函数，被explicit修饰的构造函数不能发生隐式类型转换
	explicit MyContainer(int size) 
		: size_(size), 
		data_(new int[size]) 
	{}

	//析构函数
	~MyContainer()
	{
		delete[] data_;
	}
	
	//begin迭代器：返回指向第一个元素的迭代器
	MyIterator begin() const
	{
		return MyIterator(data_);
	}   

	//end迭代器：返回指向最后一个元素后面的迭代器
	MyIterator end() const
	{ 
		return MyIterator(data_ + size_);
	} 

private:
	int size_;   // 容器大小
	int* data_;  // 存储数据的指针
};

//使用范围for循环遍历容器
int main()
{
	MyContainer container(5);
	
	int i = 0;

	//下面修改容器中的值的前提是：实现迭代器类中的解引用运算符，注意点是引用返回，赋给修改容器中元素的作用
	for (auto& x : container)		//这里使用引用，就可以改变容器中的值，不使用引用就不能改变容器中的值
	{
		x = ++i;
	}

	for (auto x : container) 
	{
		std::cout << x << " ";
	}
	std::cout << std::endl;

	return 0;
}	
//输出结果：1 2 3 4 5
```



2.自动类型推导auto

```c++
#include <iostream>
#include <vector>

int main()
{
    std::vector vec = {1, 2, 3, 4, 5};  // 自动推导出 vector<int> 类型

    for (auto x : vec) 
    {
        std::cout << x << " ";
    }
    std::cout << std::endl;

    return 0;
}
```



3.引用

```c++
#include <iostream>
#include <vector>

int main()
{
    std::vector<int> vec = {1, 2, 3, 4, 5};

    for (int& x : vec) 
    {
        x *= 2;			//修改vec中元素的值
    }		

    for (int x : vec)
    {
        std::cout << x << " ";			//2 4 6 8 10
    }
    std::cout << std::endl;

    return 0;
}
```



# 11.指针空值nullptr(c++11新添加的)

## 11.1概念

nullptr指针：`nullptr` 是 C++11 中引入的空指针关键字，用于表示一个不指向任何有效对象或函数的指针。`nullptr` 是一个右值，可以被隐式转换成指向任何类型的空指针。

```c++
int* ptr = nullptr;  //将ptr初始化为一个空指针
```



## 11.2与其他空指针常量的比较

C++ 中还存在其他表示空指针的常量，例如 `NULL` 和 `0`。但是这些常量存在一些历史遗留问题，容易引起一些隐藏的问题。`nullptr` 是 C++11 引入的新特性，用于代替这些常量，并提供更好的类型安全性。

```c++
void fun(int ptr) 
{
	cout << "fun(int)" << endl;
}

void fun(int* ptr) 
{
	cout << "fun(int*)" << endl;
}

//nullptr
void test7()
{
	bool result1 = nullptr == NULL;  // 结果为 1
	bool result2 = nullptr == 0;     // 结果为 1
	bool result3 = nullptr != NULL;  // 结果为 0
	bool result4 = nullptr != 0;     // 结果为 0
	fun(NULL);			//fun(int)	宏替换，预处理，NULL等价于0	在传统的C头文件(stddef.h)中
	fun(nullptr);		//fun(int*)	关键字
	fun((int*)NULL);	//fun(int*)
	fun(0);				//fun(int)
}

//在C语言或者c++98中空指针初始化
int* p1 = NULL;
int* p2 = 0;

//在C++98中，字面常量0既可以是一个整形数字，也可以是无类型的指针(void*)常量，
//但是编译器默认情况下将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强转(void *)0。
```



## 11.3总结

1.在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入的;

2.**在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同;**

```c++
	cout << sizeof(nullptr) << endl;	//4
	cout << sizeof((void*)0) << endl;	//4
```

3.为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr。