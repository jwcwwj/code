# 1.继承的概念及定义

## 1.1继承的概念

继承(inheritance)机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基

础上进行扩展，增加功能，这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构，体现了由简单

到复杂的认知过程。以前我们接触的复用都是函数复用，继承是类设计层次的复用。

```c++
#include <iostream>
#include <string>

using namespace std;

//基类
class Person
{
public:
	void Print()
	{
		cout << "name:" << _name << endl;
		cout << "age:" << _age << endl;
	}
protected:
	string _name = "peter"; //姓名
	int _age = 18;			//年龄
};

//派生类
class Student : public Person		//class默认是private，static默认是public
{
protected:
	int _stuid; //学号
};

class Teacher : public Person
{
protected:
	int _jobid; // 工号
}; 

void test()
{
	Student s;
	Teacher t;
	s.Print();
	//输出：
	//name:peter
	//age:18
	t.Print();
	//输出：
	//name:peter
	//age:18
}

int main()
{
	test();
	return 0;
}
```



## 1.2继承的定义

### 1.2.1定义格式

上面1.1中的代码，Person是父类，也叫做基类，Student和Teacher是子类，也叫做派生类。

class/student 派生类（子类） :	继承方式（不写就是默认的） 基类（父类）

{

访问限定符：

​	成员函数和成员变量	

}



### 1.2.2继承方式和访问限定符

继承方式：public继承、private继承、protected继承

访问限定符：public访问、private访问、protected访问



### 1.2.3继承基类成员访问方式的变化

| 类成员/继承方式     | public继承            | protected继承         | private继承         |
| ------------------- | --------------------- | --------------------- | ------------------- |
| 基类的public成员    | 派生类的public成员    | 派生类的protected     | 派生类的private成员 |
| 基类的protected成员 | 派生类的protected成员 | 派生类的protected成员 | 派生类的private成员 |
| 基类的private成员   | 在派生类中不可见      | 在派生类中不可见      | 在派生类中不可见    |

总结：
1.基类private成员在派生类中无论以什么方式继承都是不可见的。这里的不可见是指基类的私有成员还是被继承

到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它。

2.基类private成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在派生类中能访问，

就定义为protected。可以看出保护成员限定符是因继承才出现的。

3.实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。**基类的其他成员在子类的访问方**

**式 == Min(成员在基类的访问限定符，继承方****式)，public > protected > private。**

4.使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public，不过最好显示的写出继承

方式。

5.在实际运用中一般使用都是**public**继承，几乎很少使用protetced/private继承，也不提倡使protetced/private

继承，因为protetced/private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强。

```c++
#include <iostream>
#include <string>

using namespace std;

class Person
{
public:
	void Print()
	{
		cout << _name << endl;
	}

protected:
	string _name;	//姓名

private:
	int _age;		//年龄
};

//public继承
class Student1 : public Person
{
protected:
	int _stunum; // 学号

	void fun(Student1 s)		
	{
		s._name;	//protected可以访问
		//s._age;	//private不可访问
	}
};
 
void test1()
{
	Student1 s1;
	s1.Print();		//public可以访问
}

//protected继承
class Student2 : protected Person
{
protected:
	int _stunum; // 学号

	void fun(Student2 s2)
	{ 
		s2._name;
		cout << _name << endl;		//protected可以访问
		//cout << _age << endl;		//private不可以访问
	}
};

void test2()
{
	Student1 s2;
	s2.Print();		//public可以访问
}

//private继承
class Student3 : private Person
{
protected:
	int _stunum; // 学号
	void fun()
	{
		Print();
		_name;
		//_age;		//private不可以访问
	}
};

void test3()
{
	Student3 s3;
	//s3.Print();		//不可访问
}

int main()
{
	cout << sizeof(string) << endl;		//28
	test1();
	test2();
	test3();
	return 0;
}
```



# 2.基类和派生类对象赋值转换

派生类对象可以赋值给基类的对象 / 基类的指针 / 基类的引用。这里有个形象的说法叫切片或者切割。寓意把派生

类中父类那部分切来赋值过去。

基类对象不能赋值给派生类对象。

基类的指针可以通过强制类型转换赋值给派生类的指针。但是必须是基类的指针是指向派生类对象时才是安全的。

这里基类如果是多态类型，可以使用RTTI(Run-Time Type Information)的dynamic_cast 来进行识别后进行安全转

换。（ps：这个我们有会讲，这里了解一下）。

```c++
#include <iostream>
#include <string>

using namespace std;

class Person
{
protected:
	string _name;	//姓名
	string _sex;	//性别
	int _age;		//年龄
};

class Student : public Person
{
public:
	int _No; // 学号
};

void test()
{
	Student sobj;
	//1.子类对象可以赋值给父类对象/指针/引用（切片）
	//和内置类型的隐式类型转换一样
	//子类 -> 父类
	Person pobj = sobj;		//发生了拷贝，不是一个对象
	Person* pp = &sobj;
	Person& rp = sobj;

	//2.基类对象（父类）不能赋值给派生类（子类）对象
	//sobj = pobj;		//error
	
	//3.基类（父类）的指针可以通过强制类型转换赋值给派生类（子类）的指针
	//父类指针、引用不能直接赋值给子类指针引用
	Student* ps1 = (Student*)pp; //这种情况转换是可以的。	pp里面存放的是Student的地址
	ps1->_No = 10;
	pp = &pobj;		//pp里面存放的是Person的地址

	//下面的情况访问不到子类新增的成员，不要写
	Student* ps2 = (Student*)pp; // 这种情况转换时虽然可以，但是会存在越界访问的问题
	//ps2->_No = 10;	//error，越界访问
}

int main()
{
	test();
	return 0;
}
```



# 3.继承中的作用域

1.在继承体系中基类和派生类都有独立的作用域。

2.子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏，也叫重定义。（同名

时，子类成员隐藏了父类成员）（在子类成员函数中，可以使用基类::基类成员显示访问）

3.需要注意的是如果是成员函数的隐藏，只需要函数名相同就构成隐藏。

**4.注意在实际中在继承体系里面最好不要定义同名的成员。**

```c++
#include <iostream>
#include <string>

using namespace std;

// Student的_num和Person的_num构成隐藏关系，可以看出这样代码虽然能跑，但是非常容易混淆
class Person
{
protected:
	string _name = "小李子"; // 姓名
	int _num = 111; // 身份证号
};
class Student : public Person
{
public:
	void Print()
	{
		cout << "姓名:" << _name << endl;
		cout << "身份证号:" << Person::_num << endl;
		cout << "学号:" << _num << endl;
	}
protected:
	int _num = 999; // 学号
};

void test1()
{
	Student s1;
	s1.Print();
	//输出：
	//姓名:小李子
	//身份证号:111
	//学号:999
}


// B中的fun和A中的fun不是构成重载，因为不是在同一作用域
// B中的fun和A中的fun构成隐藏，成员函数满足函数名相同就构成隐藏。
class A
{
public:
	void fun()
	{
		cout << "func()" << endl;
	}
};
class B : public A
{
public:
	void fun(int i)
	{
		A::fun();
		cout << "func(int i)->" << i << endl;
	}
}; 

void test2()
{
	B b;
	b.fun(10);
	//输出：
	//func()
	//func(int i)->10
}

int main()
{
	test1();
	test2();
	return 0;
}
```



# 4.派生类的默认成员函数

6个默认成员函数，“默认”的意思就是指我们不写，编译器会自动生成一个，那么在派生类中，这几个成员函数是

如何生成的呢？

1.派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。**如果基类没有默认的构造函数，则必须**

**在派生类构造函数的初始化列表阶段显示调用。**

2.派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化。

3.派生类的operator=必须要调用基类的operator=完成基类的复制。

4.派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。因为这样才能保证派生类对象先清

理派生类成员再清理基类成员的顺序。

**5.派生类对象初始化先调用基类构造再调派生类构造。**

**6.派生类对象析构清理先调用派生类析构再调基类的析构。**

![image-20230705023035829](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230705023035829.png)

![image-20230705023103566](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230705023103566.png)

```c++
#include <iostream>
#include <string>

using namespace std;

class Person
{
public:
	Person(const char* name = "peter")
		: _name(name)
	{
		cout << "Person()" << endl;
	}

	Person(const Person& p)
		: _name(p._name)
	{
		cout << "Person(const Person& p)" << endl;
	}

	Person& operator=(const Person& p)
	{
		cout << "Person operator=(const Person& p)" << endl;
		if (this != &p)
			_name = p._name;
		return *this;
	}

	~Person()
	{
		cout << "~Person()" << endl;
	}

protected:
	string _name; //姓名
};

class Student : public Person
{
public:
	//子类默认的构造函数，自动调用父类的构造函数
    Student(const char* name, int num)
		: Person(name)
		, _num(num)
	{
		cout << "Student()" << endl;
	}

    //子类默认的拷贝构造，自动调用父类的拷贝构造
    //显示定义的拷贝构造，默认调用父类的默认构造（指定之后调用父类拷贝构造）
	Student(const Student& s)
		: Person(s)		//切片，指定之后调用父类拷贝构造
		, _num(s._num)
	{
		cout << "Student(const Student& s)" << endl;
	}

    //显示定义的赋值运算符，不会自动调用父类的赋值运算符
    //子类默认的赋值运算符，自动调用父类的赋值运算符
	Student& operator = (const Student& s)
	{
		cout << "Student& operator= (const Student& s)" << endl;
		if (this != &s)
		{
            //需要显示调用父类的赋值运算符
			Person::operator =(s);		//这个算是自己写的，注意作用域（父类和子类的operator=是同名隐藏）	 
			_num = s._num;
		}
		return *this;
	}

    //显示定义的析构，在子类函数体执行完的时候，也会自动调用父类析构
    //子类的析构会自动调用父类的析构
	~Student()
	{
		cout << "~Student()" << endl;
        //父类的析构不需要显示写，会自动调用父类的析构
        //Person::~Person();		//必须加作用域才可以调用父类的析构（前提是父类没有资源），原因是父类和子类的析构时同名隐藏（父类和子类的析构函数底层函数名是相同的）
        //析构函数的名称：底层（destructor）
	}
protected:
	int _num; //学号
};

void test()
{
	Student s1("jack", 18);
	Student s2(s1);
	Student s3("rose", 17);
	s1 = s3;
	//输出：
	//Person()			父类的构造函数
	//Student()			子类的构造函数
	//Person(const Person& p)	父类的拷贝构造函数
	//Student(const Student& s)	子类的拷贝构造函数
	//Person()			父类的构造函数
	//Student()			子类的构造函数
	//Student& operator= (const Student& s)		子类的=运算符
	//Person operator=(const Person& p)			父类的=运算符
	//~Student()		子类的析构函数
	//~Person()			父类的析构函数
	//~Student()
	//~Person()
	//~Student()
	//~Person()
}

int main()
{
	test();
	return 0;
}
```



# 5.继承与友元

友元关系不能继承，也就是说基类友元不能访问子类私有和保护成员。

```c++
#include <iostream>
#include <string>

using namespace std;

class Student;

class Person
{
public:
	friend void Display(const Person& p, const Student& s);
protected:
	string _name = "jac"; // 姓名
};

class Student : public Person
{
	//friend void Display(const Person& p, const Student& s);
protected:
	int _stuNum; // 学号
};

void Display(const Person& p, const Student& s)
{
	cout << p._name << endl;		//输出：jac		没有指定值输出空字符串
	//友元关系不能继承
	//cout << s._stuNum << endl;		//error
} 

void test()
{
	Person p;
	Student s;
	Display(p, s);
}

int main()
{
	test();
	return 0;
}

```



# 6.继承与静态成员

基类定义了static静态成员，则整个继承体系里面只有一个这样的成员（父类和子类共享静态成员）。无论派生出

多少个子类，都只有一个static成员实例。（静态成员可以被继承，但只有一个）

```c++
#include <iostream>
#include <string>

using namespace std;

class Person
{
public:
	Person() { ++_count; }

protected:
	string _name;			//姓名

public:
	static int _count;		//统计人的个数。
};

int Person::_count = 0;		//类外初始化静态成员

class Student : public Person
{
protected:
	int _stuNum; // 学号
};

class Graduate : public Student
{
protected:
	string _seminarCourse;		//研究科目
}; 

void test()
{
	Student s1;
	Student s2;
	Student s3;
	Graduate s4;
	cout << "人数:" << Person::_count << endl;	//人数：4
	Student::_count = 0;
	cout << "人数:" << Person::_count << endl;	//人数：0
}

int main()
{
	test();
	return 0;
}
```



# 7.复杂的菱形继承及菱形虚拟继承

单继承：一个子类只有一个直接父类时称这个继承关系为单继承。

多继承：一个子类有两个或以上直接父类时称这个继承关系为多继承。

菱形继承：菱形继承是多继承的一种特殊情况。

![image-20230705204921214](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230705204921214.png)

菱形继承的问题：从下面的对象成员模型构造，可以看出菱形继承有数据冗余和二义性的问题。在Assistant的对

象中Person成员会有两份。

![image-20230705205004643](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230705205004643.png)

```c++
#include <iostream>
#include <string>

using namespace std;

class Person
{
public:
	string _name; //姓名
};

class Student : public Person
{
protected:
	int _num; //学号
};

class Teacher : public Person
{
protected:
	int _id; //职工编号
};

class Assistant : public Student, public Teacher
{
protected:
	string _majorCourse; //主修课程
};

void Test()
{
	// 这样会有二义性无法明确知道访问的是哪一个
	Assistant a;
	//a._name = "peter";	//error
	// 需要显示指定访问哪个父类的成员可以解决二义性问题，但是数据冗余问题无法解决
	a.Student::_name = "xxx";
	a.Teacher::_name = "yyy";
}

void test()
{
	cout << sizeof(Person) << endl;		//28
	cout << sizeof(Student) << endl;	//32
	cout << sizeof(Teacher) << endl;	//32
	cout << sizeof(Assistant) << endl;	//92 = 32 + 32 + 28
}

int main()
{
	test();
	return 0;
}
```

虚拟继承可以解决菱形继承的二义性和数据冗余的问题。如上面的继承关系，在Student和Teacher的继承Person时使用虚拟继承，即可解决问题。需要注意的

是，虚拟继承不要在其他地方去使用。

```c++
#include <iostream>
#include <string>

using namespace std;

class Person
{
public:
	string _name; //姓名
};

class Student : virtual public Person
{
protected:
	int _num; //学号
};

class Teacher : virtual public Person
{
protected:
	int _id; //职工编号
};

class Assistant : public Student, public Teacher
{
protected:
	string _majorCourse; //主修课程
};

void test()
{
	Assistant a;
	a._name = "peter";	//虚拟继承之后就不会有歧义了
	a.Student::_name = "xxx";
	a.Teacher::_name = "yyy";		//改的是同一个内容
	cout << sizeof(Person) << endl;		//28
	cout << sizeof(Student) << endl;	//36 = 4(指针) + 28 + 4
	cout << sizeof(Teacher) << endl;	//36 = 4(指针) + 28 + 4
	cout << sizeof(Assistant) << endl;	//72 = 8 + 8 + 28 + 28
}

int main()
{
	test();
	return 0;
}
```



## 7.1虚拟继承的原理

虚拟继承解决数据冗余和二义性的原理：

为了研究虚拟继承原理，我们给出了一个简化的菱形继承继承体系，再借助内存窗口观察对象成员的模型。

```c++
#include <iostream>
#include <string>

using namespace std;

//查看使用了虚拟继承和没有使用虚拟继承的内存图

//不使用虚拟继承
class A1
{
public:
	int _a;
};

class B1 : public A1
{
public:
	int _b;
};

class C1 : public A1
{
public:
	int _c;
};

class D1 : public B1, public C1
{
public:
	int _d;
};

//没有使用虚拟继承
void test1()
{
	D1 d;
	d.B1::_a = 1;
	d._b = 3;
	d.C1::_a = 2;
	d._c = 4;
	d._d = 5;
}

//使用了虚拟继承
class A2
{
public:
	int _a;
};

class B2 : virtual public A2
{
public:
	int _b;
};

class C2 : virtual public A2
{
public:
	int _c;
};

class D2 : public B2, public C2
{
public:
	int _d;
};

//使用了虚拟继承
void test2()
{
	D2 d;
	d.B2::_a = 1;
	d._b = 3;
	d.C2::_a = 2;
	d._c = 4;
	d._d = 5;
}

int main()
{
	test1();
	test2();
	return 0;
}
```

![image-20230706000138479](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230706000138479.png)

虚拟表第一个位置是0，是相对于自身的偏移量，要是有多态会是一个负的。



# 8.继承的总结和反思

1.很多人说C++语法复杂，其实多继承就是一个体现。有了多继承，就存在菱形继承，有了菱形继承就有菱形虚拟

继承，底层实现就很复杂。所以一般不建议设计

出多继承，一定不要设计出菱形继承。否则在复杂度及性能上都有问题。

2.多继承可以认为是C++的缺陷之一，很多后来的OO语言都没有多继承，如Java。

3.继承和组合：

3.1public继承是一种**is-a**的关系。也就是说每个派生类对象都是一个基类对象。

3.2组合是一种**has-a**的关系。假设B组合了A，每个B对象中都有一个A对象。

3.3优先使用对象组合，而不是类继承。

3.4继承允许你根据基类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称为白箱复用(white-box 

reuse)。术语“白箱”是相对可视性而言：在继承方式中，基类的内部细节对子类可见。继承一定程度破坏了基类的

封装，基类的改变，对派生类有很大的影响。派生类和基类间的依赖关系很强，耦合度高。

3.5对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求

被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black-box reuse)，因为对象的内部细节是不可

见的。对象只以“黑箱”的形式出现。 组合类之间没有很强的依赖关系，耦合度低。优先使用对象组合有助于你保持

每个类被封装。

3.6实际尽量多去用组合。组合的耦合度低，代码维护性好。不过继承也有用武之地的，有些关系就适合继承那就

用继承，**另外要实现多态，也必须要继承。**类之间的关系可以用继承，也可以用组合，那就用组合。



# 9.笔试面试题

**1.什么是菱形继承？菱形继承的问题是什么？**

答：

菱形继承（Diamond Inheritance）是指在继承关系中出现的一种特殊情况，形成了一个菱形的继承结构，也称为

钻石继承。

菱形继承发生在以下情况：存在一个基类（父类），然后有两个中间类（子类）分别继承这个基类，最后又有一个

子类同时继承这两个中间类。这就形成了一个菱形的继承关系，如下所示：

```c++
   A
  / \
 B   C
  \ /
   D
```

在这个继承结构中，B和C都继承了A类，而D同时继承了B和C类。

菱形继承可能会引发一些问题，其中主要问题是多重继承导致的二义性（Ambiguity）问题。因为D同时继承了B

和C，而B和C都继承了A，所以D将拥有来自A的重复成员（属性和方法）。当使用D类的对象调用这些继承自A的

成员时，就会产生二义性，编译器无法确定到底应该使用哪个继承自A的成员。

为了解决菱形继承带来的二义性问题，编程语言通常采用了不同的处理方式。其中一种常见的方式是虚继承

（Virtual Inheritance），通过在某个继承路径上添加关键字来表示虚继承，从而告诉编译器只继承一份共享的基

类成员，避免了重复继承带来的二义性。虚继承可以确保在菱形继承中只有一份基类对象被创建，解决

了二义性的问题。

**总结起来，菱形继承是指在继承关系中形成一个菱形的结构，可能会导致二义性问题。为避免二义性，常使用**

**虚继承来解决菱形继承带来的问题。**

答：

菱形继承带来的主要问题是二义性（Ambiguity）。在菱形继承结构中，当一个子类同时继承了两个中间类，而这

两个中间类又都继承了同一个基类时，子类将继承自基类的成员（属性和方法）出现了重复。

这样一来，在子类中调用继承自基类的成员时（比如方法或属性），编译器无法确定应该使用哪个继承的成员，因

为它们来自不同的路径。这就产生了二义性，也就是无法唯一确定应该调用哪个基类的成员。

例如，在上述菱形继承示意图中，D类继承了B类和C类，而B类和C类都继承了A类。如果B类和C类都定义了一个

名为"function()"的方法，并且D类没有重写这个方法，那么当使用D类的对象调用"function()"方法时，编译器无法

确定到底是调用来自B类的方法还是来自C类的方法。

这种二义性可能导致程序逻辑错误，使代码难以理解和维护。同时，菱形继承也增加了编译器的复杂性，因为需要

进行额外的判断和决策来解决二义性问题。

为了解决菱形继承带来的二义性，一种常见的解决方案是虚继承（Virtual Inheritance）。虚继承通过在某个继承

路径上添加关键字（比如C++中的"virtual"关键字）来表示虚继承，从而告诉编译器只继承一份共享的基类成员，

避免了重复继承带来的二义性。

**总结而言，菱形继承的问题主要是二义性，即继承自基类的成员出现重复，编译器无法确定应该调用哪个基类**

**的成员。为了解决这个问题，可以使用虚继承来避免重复继承和二义性。**

**2.什么是菱形虚拟继承？如何解决数据冗余和二义性的？**

菱形虚拟继承（Diamond Virtual Inheritance）是在菱形继承结构中使用虚继承的一种方式。它解决了菱形继承

带来的二义性问题。

在菱形虚拟继承中，通过在某个继承路径上添加关键字来表示虚继承，告诉编译器只继承一份共享的基类成员，避

免了重复继承带来的二义性。

具体而言，在菱形继承的例子中，当D类同时继承B类和C类时，可以在B类和C类的继承声明中使用虚继承。这

样，D类就只会继承一份来自A类的基类成员，避免了重复继承和二义性的问题。

例如，使用C++语言来演示菱形虚拟继承的代码如下所示：

```c++
class A {
public:
    int data;
};

class B : virtual public A {
public:
    void function() {
        // ...
    }
};

class C : virtual public A {
public:
    void function() {
        // ...
    }
};

class D : public B, public C {
    // ...
};
```

在上述代码中，B类和C类的继承关系中都使用了虚继承（通过在继承声明中添加"virtual"关键字），表示对A类的

虚继承。这样，D类在继承B类和C类时，只会继承一份来自A类的基类成员，避免了二义性问题。

通过菱形虚拟继承，可以确保在菱形继承中只有一份基类对象被创建，解决了重复继承导致的二义性问题。这样可

以简化继承关系，减少代码重复，提高代码的可读性和可维护性。 



菱形虚拟继承（Diamond Inheritance）会导致数据冗余和二义性的问题，但可以通过以下方式来解决：

1. 虚拟继承（virtual inheritance）：在继承关系中使用虚拟继承可以解决菱形继承的数据冗余问题。通过在派

   生类对共同基类的继承声明中添加`virtual`关键字，可以确保只有一份共同基类的实例被创建，避免了数据

   的冗余。

2. 重写冲突的成员函数：当菱形继承导致派生类中存在冲突的成员函数时，派生类需要重写这些成员函数并明确

   指定使用哪个基类的实现。通过在派生类中重新定义和实现这些成员函数，并使用作用域限定符来指定调用哪

   个基类的实现，可以消除二义性。

3. 使用虚函数和接口：将基类中可能导致冲突或二义性的成员函数声明为虚函数，并通过定义接口规范其行为。

   派生类可以根据具体需求实现这些虚函数，从而避免数据的冗余和二义性问题。

4. 增加间接基类：通过增加一个额外的间接基类来解决菱形继承的二义性问题。这样一来，派生类可以分别继承

   两个不同的共同基类，避免了直接的继承关系，从而消除了二义性。

需要注意的是，在解决菱形继承问题时，应该根据实际情况选择合适的解决方案。虚拟继承、重写成员函数、使用

虚函数和接口以及增加间接基类都是常见的解决方案，具体取决于继承关系和需求的复杂性。在进行设计时，还应

考虑代码的可读性、可维护性和性能等因素。



**3.继承和组合的区别？什么时候用继承？什么时候用组合？**

继承（Inheritance）和组合（Composition）是面向对象编程中两种常见的代码复用机制，它们在实现代码重用

和建立类之间的关系时有所不同。下面是它们的主要区别：

1. 定义：继承是通过从一个类派生出另一个类来创建类之间的关系。子类（派生类）继承了父类（基类）的属性

   和方法。组合是将一个或多个类的对象组合成一个更大的类，新的类通过包含其他类的实例来实现功能。

2. 关系类型：继承是一种"is-a"（是一个）关系，表示子类是父类的特殊化。组合是一种"has-a"（有一个）关

   系，表示一个类包含其他类。

3. 代码复用：继承可以实现代码的复用，子类可以直接访问并重用父类的属性和方法。组合通过将已有的类作为

   对象引入到新的类中，以实现代码的复用。

4. **灵活性：继承在编译时就确定了类之间的关系，是静态的，子类无法在运行时更改其继承关系。组合在运行**

   **时可以动态地替换组合的对象，提供更大的灵活性。**（不理解）

5. 关联程度：继承具有更强的关联程度，子类与父类之间具有较高的耦合性。组合具有较弱的关联程度，通过对

   象的引用或指针进行交互，可以更灵活地替换和修改组件。

6. **设计理念：继承用于描述类之间的一般化和特殊化关系，通过抽象和分层来组织代码。组合用于描述对象之**

   **间的整体与部分关系，通过构建更大的类来实现功能。**

在选择使用继承还是组合时，需要考虑类之间的关系、代码的复用性、灵活性以及设计的目标。继承适用于表示类

之间的"is-a"关系和共享的属性和方法，组合适用于描述类之间的"has-a"关系和**动态组合对象**的需求。





继承在以下情况下是适用的：

1. 表示类之间的"is-a"关系：当一个类是另一个类的特殊情况或子类时，使用继承是合适的。例如，可以有一个

   父类Animal，它的子类可以是Cat、Dog等，因为它们都属于动物。

2. 代码重用：如果多个类之间有许多相似的属性和方法，可以将这些共同的部分放在一个父类中，通过继承来实

   现代码的重用。子类可以继承并直接使用父类中的属性和方法，而无需重新编写。

3. 扩展功能：使用继承可以在已有类的基础上进行扩展和修改，添加额外的属性和方法，以满足特定的需求。这

   样可以避免对原有类进行修改，减少代码的复杂性和维护成本。

4. 实现多态性：继承是实现多态性的一种方式。通过基类的引用指向不同子类的对象，可以实现针对不同对象调

   用相同方法时的不同行为，增加代码的灵活性和可扩展性。

需要注意的是，在使用继承时应遵循以下原则：

- 保持类之间的关系清晰和一致，确保继承关系的正确性。
- 避免过度继承，不要滥用继承机制，避免创建过深或复杂的继承层次。
- 注意继承中的耦合性，避免出现紧耦合的类之间的依赖关系。
- 当出现功能上的变化时，优先考虑使用组合而不是继承，以提高灵活性和可维护性。

总之，在需要表示类之间的"is-a"关系、实现代码重用、添加功能或实现多态性的情况下，可以考虑使用继承来构

建类的继承体系。





组合在以下情况下是适用的：

1. 表示类之间的"has-a"关系：当一个类包含其他类的对象作为其一部分时，可以使用组合来表示类之间的关

   系。例如，一个Car类可以包含Engine、Tire和Seat等对象作为其组成部分。

2. 动态组合对象：如果需要在运行时动态地替换或修改组件对象，组合是一个更灵活的选择。通过修改内部对象

   的引用或指针，可以实现组合对象的动态变化。

3. 避免多层继承的复杂性：当存在多个类之间的复杂继承关系时，使用组合可以避免继承层次的过深和复杂性。

   通过将功能分解为独立的类，并通过组合将它们组合在一起，可以简化代码结构和维护。

4. 实现接口和模块化设计：组合可以帮助实现接口和模块化的设计。将不同的功能模块封装成独立的类，并通过

   组合将它们组装到更大的类中，以实现各个模块的独立性和可复用性。

5. 提高代码的灵活性和可扩展性：使用组合可以减少类之间的耦合度，提高代码的灵活性和可扩展性。通过更改

   组合对象的具体实现，可以轻松地修改和扩展功能，而不影响其他部分的代码。

需要注意的是，在使用组合时应遵循以下原则：

- 目标是实现最小耦合和高内聚性，保持组件之间的独立性。
- 选择合适的关联类型，例如通过引用、指针等方式进行组合。
- 避免过度组合，确保组合对象的层次结构清晰，不要嵌套过深导致代码难以理解和维护。
- 合理设计接口和模块，避免接口的暴露程度过高或过低，保持适当的封装。

总之，在需要表示类之间的"has-a"关系、动态组合对象、简化复杂继承关系、实现模块化设计或提高代码灵活性

和可扩展性的情况下，可以考虑使用组合来构建类的组合关系。