# 1.非类型模板参数

模板参数分类类型形参与非类型形参。

类型形参：出现在模板参数列表中，跟在class或者typename之类的参数类型名称。

非类型形参，就是用一个常量作为类(函数)模板的一个参数，在类(函数)模板中可将该参数当成常量来使用。  

在STL实现的双端队列中就有非类型模板参数。

![image-20230630035247777](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230630035247777.png)

```c++
//#pragma warning(disable:4996)		//忽略4996这个错误
#define _CRT_SECURE_NO_WARNINGS		
//用于取消 Visual Studio 编译器（MSVC）在使用某些标准 C/C++ 函数时产生的安全警告信息
#include <iostream>
#include <string>
#include <algorithm> 
#include <assert.h>
#include <string.h>
#include <vector>
#include <list>
#include <stack>
#include <queue>
#include <functional>	//greater算法的头文件
#include <array>			//静态数组类

using namespace std;

//template <class T,double num>		//报错：浮点模板参数是非标准的
//struct A
//{};

struct B
{};

//template <class T,B obj>		 //报错：非类型模板参数不能作为类类型
//struct C
//{};

template <class T, char ch>
struct D
{};

int main()
{
	//array<T,size_t>		size_t是非类型模板参数
	array<int, 10> arr;			//静态数组，等价于int arr[10]
	//非类型模板参数只能是整数类型，不能给浮点数或者自定义类型数据
	B b;
	//C<int,b> c;		//报错：表达式必须含有常量值
	D<float, 'a'> d;

	return 0;
}
//没有输出结果
//注意点：这个代码不是很理解为什么
```

注意：

1.浮点数、类对象以及字符串是不允许作为非类型模板参数的。

2.非类型的模板参数必须在编译期就能确认结果。



# 2.模板的特化

## 2.1模板的特化的概念

通常情况下，**使用模板可以实现一些与类型无关的代码，但对于一些特殊类型的可能会得到一些错误的结果。**

比如判等操作，传参字符串，不使用特化版本是对比字符串的地址，实际上是想比较字符串的内容。

此时，就**需要对模板进行特化。即：在原模板类的基础上，针对特殊类型所进行特殊化的实现方式**。模板特化中分

为**函数模板特化**与**类模板特化**。



## 2.2函数模板特化

函数模板的特化步骤：

1.必须要先有一个基础的函数模板

2.关键字template后面接一对空的尖括号<>

3.函数名后跟一对尖括号，尖括号中指定需要特化的类型

4.函数形参表: 必须要和模板函数的基础参数类型完全相同，如果不同编译器可能会报一些奇怪的错误。  



注意：一般情况下如果函数模板遇到不能处理或者处理有误的类型，为了实现简单通常都是将该函数直接给出。

（给出普通函数）

```c++
//#pragma warning(disable:4996)		//忽略4996这个错误
#define _CRT_SECURE_NO_WARNINGS		
//用于取消 Visual Studio 编译器（MSVC）在使用某些标准 C/C++ 函数时产生的安全警告信息
#include <iostream>
#include <string>
#include <algorithm> 
#include <assert.h>
#include <string.h>
#include <vector>
#include <list>
#include <stack>
#include <queue>
#include <functional>	//greater算法的头文件
#include <array>		//静态数组类

using namespace std;

//判等
template <class T>
bool isEqual(T& a, T& b)
{
	cout << "函数模板" << endl;
	return a == b;
}

//模板的特化
//前提：已有一个通用的模板

//1.全特化
template <>
bool isEqual<const char*>(const char*& a, const char*& b)
{
	cout << "函数模板特化" << endl;
	return strcmp(a, b) == 0;		//strcmp等于0表示相等，不等于0表示不相等
}

//1.也可以写一个普通的函数做全特化的事情
//2.当普通函数比模板函数合适的时候会调用普通函数（普通函数完全匹配）
//3.当普通的函数和模板函数同时存在时，作用一样，会调用普通函数
bool isEqual(const char* a, const char* b)
{
	cout << "普通函数" << endl;
	return strcmp(a, b);
}

int main()
{
	//bool ret = isEqual(1, 2);
	//ret = isEqual(1.2, 1.2);
	bool ret = isEqual("123", "123");	//普通函数

	const char* ptr = "123";			//常量字符串
	const char ptr2[] = "123";			//加const为了和常量字符串类型一样

	ret = isEqual(ptr, ptr2);			//普通函数
	cout << ret << endl;		//0

	return 0;
}
//输出结果：
//普通函数
//普通函数
//0
```

总结：函数模板特化版本用的不多，对于特殊的类型直接使用普通函数实现。



## 2.3类模板特化

类模板特化分为全特化和和偏特化。

1.全特化：是将模板参数列表中所有的参数都确定化。

2.偏特化：任何针对模版参数进一步进行条件限制设计的特化版本。



偏特化有以下两种表现方式：

1.部分特化：将模板参数类表中的一部分参数特化。

2.参数更进一步的限制：偏特化并不仅仅是指特化部分参数，而是针对模板参数更进一步的条件限制所设计出来的

一个特化版本。

```c++
//#pragma warning(disable:4996)		//忽略4996这个错误
#define _CRT_SECURE_NO_WARNINGS		
//用于取消 Visual Studio 编译器（MSVC）在使用某些标准 C/C++ 函数时产生的安全警告信息
#include <iostream>
#include <string>
#include <algorithm> 
#include <assert.h>
#include <string.h>
#include <vector>
#include <list>
#include <stack>
#include <queue>
#include <functional>	//greater算法的头文件
#include <array>		//静态数组类

using namespace std;

//类模板特化：
//应用场景：类型萃取
//前提：已有一个通用的模板

template <class T1, class T2>
struct D
{
public:
	D(const T1& d1, const T2& d2)
		: _d1(d1)
		, _d2(d2)
	{
		cout << "D(T1, T2)" << endl;
	}

	T1 _d1;
	T2 _d2;
};

//特化类模板：
//1.全特化：所有的类型都是具体类型，没有类型的限制
template<>
struct D<char, double>
{
	D(const char& d1, const double& d2)
		: _d1(d1)
		, _d2(d2)
	{
		cout << "D(char, double)" << endl;
	}

	char _d1;
	double _d2;
};

//全特化
void test1()
{
	D<int, int> d1(1, 1);			//通用模板的实例化
	//输出：D(T1, T2)
	D<char, double> d2('a', 1.1);	//全特化版本的实例化
	//输出：D(char, double)
}
//输出结果：
//D(T1, T2)
//D(char, double)

//2.1偏特化：只特化部分类型
template <class T1>
struct D<T1, char>
{
	D(const T1& d1, const char& d2)
		:_d1(d1)
		, _d2(d2)
	{
		cout << "D(T1, char)" << endl;
	}

	T1 _d1;
	char _d2;
};

//偏特化
void test2()
{
	D<int, char> d3(1, 'a');	//偏特化版本的实例化
	//输出：D(T1, char)
}
//输出结果：
//D(T1, char)

//2.2偏特化给模板参数做进一步的限制
template <class T1, class T2>
struct D<T1*, T2*>
{
public:
	D(const T1& d1, const T2& d2)
		: _d1(d1)
		, _d2(d2)
	{
		cout << "D(T1*, T2*)" << endl;
	}

	T1 _d1;
	T2 _d2;
};

//2.2偏特化给模板参数做进一步的限制
void test3()
{
	D<int*, int*> d4(1, 2);
	//输出：D(T1*, T2*)
}
//输出结果：
//D(T1*, T2*)

int main()
{
	test1();		//全特化
	test2();		//偏特化
	test3();		//偏特化给模板参数做进一步的限制
	return 0;
}
```



# 3.模板的分离编译

一个程序（项目）由若干个源文件共同实现，而每个源文件单独编译生成目标文件，最后将所有目标文件链接起来

形成单一的可执行文件的过程称为分离编译模式。



c/c++程序要运行，一般要经历一下步骤：

1.预处理：去注释、头文件展开，宏替换		.i

2.编译：语法检查、源代码转汇编代码 	.s

注意：头文件不参与编译，编译器对工程中的多个源文件是分离开单独编译的。

3.汇编：汇编代码转二进制代码	.o/.obj

4.链接：把二进制代码整合成可执行程序/库文件，并处理没有解决的地址问题



错误的示范：模板函数申明和定义分文件写。

```c++
//模板分离编译.cpp
#include "模板分离编译.h"
#include <iostream>
using namespace std;

//只有使用的时候才会走实例化的过程
//.cpp没有实例化的函数，以为在.h中，.h也不知道实例化函数的地址，最后就找不到实例化的函数
//正常函数定义和声明时分开写的，但模板函数是放在一个文件里面写的（都写在头文件里）

template <class T>
void fun(const T& a)
{
	cout << "fun(const T&)";
}

//模板分离编译.h
template <class T>
void fun(const T& a);

//main.cpp
#include <iostream>
#include "模板分离编译.h"

using namespace std;

int main()
{
	fun(10);	//error		报错：1个无法解析的外部命令	/ 无法解析的外部符号
	return 0;
}
```

正确的写法：模板函数申明和定义都放在.h文件中编写。

```c++
//模板分离编译.h
template <class T>
void fun(const T& a)
{
	std::cout << "fun(const T&)";
}	

//main.cpp
#include <iostream>
#include "模板分离编译.h"
using namespace std;

int main()
{
	fun(10);	//fun(const T&)
	return 0;
}
```

解决办法：

1.将声明和定义放到一个文件 "xxx.hpp" 里面或者xxx.h其实也是可以的。推荐使用这种。

2.模板定义的位置显式实例化。这种方法不实用，不推荐使用。（就是在定义模板的位置显示实例化）

```c++
//模板分离编译.h
template <class T>
void fun(const T& a)
{
	std::cout << "fun(const T&)";
}	

int main()
{
	fun(30);		//让这个文件产生int类型的函数模板实例化
	return 0;
}
//不推荐，编译器容易报错
```



# 4.模板总结

优点：

1.模板复用了代码，节省资源，更快的迭代开发，C++的标准模板库(STL)因此而产生；

2.增强了代码的灵活性。



缺点：

1.模板会导致代码膨胀问题，也会导致编译时间变长；

2.出现模板编译错误时，错误信息非常凌乱，不易定位错误。
