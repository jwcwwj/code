# 1.面向过程和面向对象的初步认识

C语言是**面向过程**的，**关注**的是**过程**，分析出求解问题的步骤，通过函数调用逐步解决问题；

C++是**基于面向对象**的，**关注**的是**对象**，将一件事情拆分成不同的对象，靠对象之间的交互完成。



# 2.类

## 2.1结构体

c语言中结构体，只能定义变量；

c++中结构体不仅可以定义变量，还可以定义函数。

```c++
#define _CRT_SECURE_NO_WARNINGS   //定义宏，禁止相关警告,用于禁止或屏蔽某些编译器警告信息。
//#define _CRT_SECURE_NO_WARNINGS 通常应该在包含任何 stdio.h 系列头文件之前定义，以确保编译器能够识别宏定义。
//这是因为，在 stdio.h 等头文件中可能包含一些与安全有关的警告信息，如果定义宏在头文件之后，则可能无法禁止这些警告。
#include <iostream> 

using namespace std;

struct Student
{
	void SetStudentInfo(const char* name, const char* gender, int age)
	{
		strcpy(_name, name);		//c++使用strcpy_s或者加上#define _CRT_SECURE_NO_WARNINGS（必须放在第一行）
		strcpy(_gender, gender);
		_age = age;
	}
    
	void PrintStudentInfo()
	{
		cout << _name << " " << _gender << " " << _age << endl;
	}
    
	char _name[20];
	char _gender[3];
	int _age;
};

void test1()
{
	Student s;
	s.SetStudentInfo("Peter", "男", 18);
	s.PrintStudentInfo();	//Pater	男	18
}
```

结构体struct在c++中可以使用，但是在c++中一般使用类class。



## 2.2类的定义

```c++
class className
{
	// 类体：由成员函数和成员变量组成
};
```

class为定义类的关键字，ClassName为类的名字，{}中为类的主体，注意类定义结束时后面分号。

类中的元素称为类的成员：类中的数据称为类的属性或者成员变量; 类中的函数称为类的方法或者成员函数。

类的两种定义方式：

1.声明和定义全部放在类体中，**需要注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处理(次重点)**;

```c++
//.cpp文件
class Student
{
public:
	void SetStudentInfo(const char* name, const char* gender, int age)
	{
		strcpy(_name, name);		//c++使用strcpy_s或者加上#define _CRT_SECURE_NO_WARNINGS（必须放在第一行）
		strcpy(_gender, gender);
		_age = age;
	}
    
	void PrintStudentInfo()
	{
		cout << _name << " " << _gender << " " << _age << endl;
	}

private:
	char _name[20];
	char _gender[3];
	int _age;
};
```

2.声明放在.h文件中，类的定义放在.cpp文件中;

```c++
//.h文件	声明
class Student
{
public:
	void SetStudentInfo(const char* name, const char* gender, int age)；
	void PrintStudentInfo()；
       
priveate:
	char _name[20];
	char _gender[3];
	int _age;
};
 
//.cpp文件 定义
void Student::SetStudentInfo(const char* name, const char* gender, int age)
{
	strcpy(_name, name);		//c++使用strcpy_s或者加上#define _CRT_SECURE_NO_WARNINGS（必须放在第一行）
	strcpy(_gender, gender);
	_age = age;
}

void Student::PrintStudentInfo()
{
	cout << _name << " " << _gender << " " << _age << endl;
}
```

注意：一般推荐使用第二种（次重点 + 书写类的习惯）。



## 2.3类的作用域

类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员，需要使用 :: 作用域解析符指明成员属于哪个类域。  

```c++
//.h文件	声明
class Student
{
public:
	void SetStudentInfo(const char* name, const char* gender, int age)；
	void PrintStudentInfo()；
       
priveate:
	char _name[20];
	char _gender[3];
	int _age;
};

//.cpp文件 定义
void Student::SetStudentInfo(const char* name, const char* gender, int age)
{
	strcpy(_name, name);		//c++使用strcpy_s或者加上#define _CRT_SECURE_NO_WARNINGS（必须放在第一行）
	strcpy(_gender, gender);
	_age = age;
}

//方法PrintStudentInfo是在Student类中的
void Student::PrintStudentInfo()
{
	cout << _name << " " << _gender << " " << _age << endl;
}
```



## 2.4类的访问限定符

C++实现封装的方式：用类将对象的属性与方法结合在一块，让对象更加完善，通过访问限定符（访问权限）选择性的将其接口提供给外部的用户使用，**作用是提**

**高代码的安全性和可维护性，主要就是为了安全。**

访问限定符有三个：public（共有）、protected（保护）、private（私有）

访问限定符说明：

1.public修饰的成员在类外可以直接被访问；

2.protected和private修饰的成员在类外不能直接被访问(此处protected和private是类似的，区别是protected是在继承的时候使用的)；

3.访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止；

4.class的默认访问权限为private，struct为public(因为struct要兼容C)。 

**注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别。**

**解释：访问限定符仅仅是告诉编译器在编译期间应该如何处理这些成员，以及哪些代码可以访问这些成员。因此，无论是 public、protected 还是 private成员，在内存中都以相同的方式存在，没有任何区别。**

```c++
class MyClass 
{
public:
    int public_var;
    
protected:
    int protected_var;
    
private:
    int private_var;
};

int main() 
{
    MyClass obj;
    obj.public_var = 1;     // 可以访问 public 成员
    //obj.protected_var = 2;  // 不能访问 protected 成员
    //obj.private_var = 3;    // 不能访问 private 成员
    
    return 0;
}
```

**在编译时，如果在 `main` 函数中访问了 `protected` 或 `private` 成员，则会出现编译错误。但是，一旦程序编译成功后，这些成员变量在内存中的存储方式相**

**同，没有任何区别。因此，如果绕过编译器，直接操作内存，则可以随意访问所有的类成员，无论其访问限定符如何定义。**

**需要注意的是，使用访问限定符仍然是一个好习惯，它可以帮助开发者提高代码的可读性、安全性和可维护性，并在一定程度上避免错误的发生。但是，不要将访**

**问限定符看作是一种完全可靠的安全手段，它并不能保证程序的完全安全。**



## 2.5c语言中的struct和c++中的strcut与class的区别

### 2.5.1c语言中的struct和c++中的struct有何区别

在 C 语言中，结构体(struct)是一种数据类型，用于定义一组异质的数据，可以包括不同的数据类型，如整型、字符型、浮点型等。C 语言中的 struct 只能包含成

员变量，不能包含成员函数或访问限定符，因此它们被视为一种简单的数据类型。

而在 C++ 中，结构体(struct)除了包含成员变量外，还可以包含成员函数（方法），并且支持访问限定符。这意味着 C++ 的结构体可以有自己的函数和行为，并且

可以对其成员变量实施访问控制。此外，C++ 中的结构体还可以继承其他类或结构体，在语法上与类(class)无异。

具体来说，C++ 中的结构体相比于 C 语言，有以下几个区别：

1. C++ 中的结构体可以包含成员函数，而 C 语言中的结构体不能包含函数；

2. C++ 中的结构体支持访问限定符（`public`、`private`、`protected`），而 C 语言中的结构体不支持访问限定符；

3. **在 C++ 中，结构体可以继承其他的类或结构体，而 C 语言中的结构体不能进行继承**；

4. **C++ 中的结构体可以定义成模板，而 C 语言中的结构体不能定义成模板**。



### 2.5.2c++中的class和c++中的struct有何区别

**在 C++ 中，Class 和 Struct 基本上是相同的，只是默认的访问控制权限不同。**

当使用 Class 关键字定义一个类时，默认情况下，所有的成员变量和函数都是私有的（private），除非使用 public 或 protected 关键字来显式地声明公有或保护

成员。而当使用 Struct 关键字定义一个结构体时，默认情况下，所有的成员变量和函数都是公有的（public）。



## 2.6封装

面向对象的三大特性：封装、继承、多态。

封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。

封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给封装起来。但是我们目的

全封装起来，不让别人看。所以我们开放了售票通道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，我们使用类数据和方法都封装一下。不想

给别人看到的，我们使用protected/private把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。



## 2.7类的作用域

类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员，需要使用 :: 作用域解析符指明成员属于哪个类域。

```c++
class Person
{
public:
	void PrintPersonInfo();

private:
	char _name[20];
	char _gender[3];
	int _age;
};

//这里需要指定PrintPersonInfo是属于Person这个类域
void Person::PrintPersonInfo()
{
	cout<<_name<<" "_gender<<" "<<_age<<endl;
}
```



## 2.8类的实例化

**用类类型创建对象的过程，称为类的实例化。**

1.类只是一个模型一样的东西，限定了类有哪些成员，**定义出一个类并没有分配实际的内存空间来存储它**。

2.一个类可以实例化出多个对象，实例化出的对象占用实际的物理空间，存储类成员变量想·。

3.做个比方。类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个

设计，实例化出的对象才能实际存储数据，占用物理空间。

```c++
class Student
{
public:
	void SetStudentInfo(const char* name, const char* gender, int age)
	{
		strcpy(_name, name);		//c++使用strcpy_s或者加上#define _CRT_SECURE_NO_WARNINGS（必须放在第一行）
		strcpy(_gender, gender);
		_age = age;
	}
    
	void PrintStudentInfo()
	{
		cout << _name << " " << _gender << " " << _age << endl;
	}

private:
	char _name[20];
	char _gender[3];
	int _age;
};

int main()
{
    Student s;	//类的实例化，实例出了一个s对象
    return 0;
}
```



## 2.9类的大小

### 2.9.1如何计算类对象的大小

 两种方法，下面主要讲第二种

1.使用 C++ 的 `sizeof` 运算符：`sizeof` 运算符可以返回某个类型或变量在内存中所占用的空间大小（以字节为单位）。因此，通过对类类型应用 `sizeof` 运算

符，可以得到该类在内存中所占用的空间大小。**需要注意的是，`sizeof` 返回的是编译时期的值，因此不能包含动态分配的成员变量的大小**。

2.手动计算（不太常用）：手动计算类的大小需要考虑以下几个因素：

- 类非静态成员变量的大小：根据类型的不同，变量在内存中所占用的空间大小也不同。例如，`int` 类型通常占用 4 个字节，而 `double` 类型通常占用 8 个字

  节。（**静态成员变量不占实例对象的空间，因为静态成员变量属于类本身，不属于特定的实例对象**）

  ```c++
  //声明静态成员变量
  class MyClass 
  {
  public:
      static int s_value;
  };
  
  // 定义并初始化静态成员变量
  int MyClass::s_value = 0;
  //在编译时，静态成员变量被分配到程序的全局数据区或静态存储区中，它们的生命周期与程序一致。
  //需要注意的是，静态成员变量在类定义时只是声明，需要在类外部进行定义和初始化。在进行定义时，需要指定该变量的存储位置和初始值
  //另外，静态成员函数也不会占用实例对象的空间，它们属于类的方法，只能访问静态成员变量或其他静态成员函数，不能访问非静态成员变量或成员函数。
  //静态成员函数的调用不需要创建类实例对象，可以直接使用类名加作用域符来调用。
  ```

- 类的对齐方式：由于内存对齐的原因，在计算类的大小时，还需要考虑类的对齐方式。**一般来说，默认情况下类以 4 字节对齐（vs2017的默认对齐值是8个字**

  **节），但具体对齐方式可能受到编译器、CPU 架构等因素的影响，需要根据实际情况进行确认。**

- **类的虚函数表指针：如果类中包含虚函数，则编译器会自动生成一个虚函数表（vtable），并将该表的指针作为类中的一个成员变量。因此，在计算类的大小**

  **时，还需要将虚函数表指针的大小计算在内。**

综上所述，使用 `sizeof` 运算符是一种比较简单、直接的方法，推荐使用。

**如果需要手动计算类的大小，则需要考虑更多的因素，且容易受到编译器和硬件平台等因素影响，因此不太常用。**



### 2.9.2类的对齐方式

类的对齐方式是指编译器在将类实例化为对象时，按照什么规则对其成员变量进行内存对齐。**不同的编译器和平台可能会有不同的默认对齐方式，一般默认的对齐**

**值为4或8字节。具体的对齐方式可以使用 `#pragma pack` 指令来控制，或者通过编译器选项进行配置。**

常见的类对齐方式包括：

1. 默认对齐方式：一般情况下，编译器会根据对齐值（通常为4或8字节）自动对齐类的成员变量。

2. 以最长的基本类型为对齐基准：当类中的成员变量包含多个基本类型时，编译器会选择其中长度最长的基本类型作为对齐基准，并按照该基准类型的大小进行

   对齐。

3. 以最大对齐模数为对齐基准：编译器将类的对齐值除以所有成员变量中最大的基本类型的对齐值，得到一个整数（称为对齐模数）。然后对所有成员变量进行

   内存对齐，使它们的地址能够被对齐模数整除。**这种对齐方式可以避免在开发跨平台应用时出现内存对齐问题。**

**需要注意的是，类的对齐方式可能受到编译器、操作系统和硬件平台等多方面因素的影响，因此在跨平台开发时需要格外注意。**同时，不合理的对齐方式可能会对

程序的性能产生一定影响，因此需要根据具体应用场景进行优化。



类/结构体内存对齐规则：

1.第一个成员在与结构体偏移量为0的地址处；

2.其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处；

注意：**对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。(注释：要是编译器的默认对齐数是大于所有类型字节的最大值，就相当于对齐俗话是该成员大小。)**

VS中默认的对齐数为8  

3.结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍；

4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。  

```c++
class A
{
	int a;		//4 + 4		//int是4个字节，double是8个字节，a要对齐b补充4个字节
	double b;	//8
	char c;		//1 + 3
	int  d;		//4
};

class B
{
	int a;		//4 + 4
	double b;	//8
	int  d;		//4
	char c;		//1 + 3		加3是要满足类的大小要是最大字节的整数倍
};

//嵌套类
class C
{
	int a;		//4 + 4
	double b;	//8
	char c;		//1 + 7
	//B中变量的最大对齐值是8
	B e;		//24
};

class D
{
	int a;		//4 + 4
	double b;	//8
	//B中变量的最大对齐值是8
	B e;		//24
	char c;		//1 + 7
};

void test2()
{
	cout << sizeof(A) << endl;	//24
	cout << sizeof(B) << endl;	//24
	cout << sizeof(C) << endl;	//48
	cout << sizeof(D) << endl;	//48
}
//空类创建对象分配一个字节的空间，原因是对象存在了，存在了就占空间。
```



### 2.9.3如何修改默认对齐值

默认情况下，C/C++ 语言中的数据类型在内存中分配空间时，所使用的对齐值是编译器默认设置的。

修改默认对齐值：使用编译器提供的预处理器指令进行设置。例如，在 GCC 编译器中，可以通过 `#pragma pack(n)` 来设置结构体或其他数据类型的对齐方式，

其中 `n` 代表字节对齐值，常见的取值为 1、2、4 或 8 等。   

需要注意的是，修改默认对齐值可能会对代码的可移植性产生影响，因此需要谨慎考虑。建议在实际开发中，根据具体需求和硬件平台特点进行相应的调整。



### 2.9.4为什么存在内存对齐

在堆上一次申请4G内部（64位操作系统才可以，32位操作系统不行）

```c++
void test8()
{    
    void* p = new char[0xfffffffful];    //32位下数组的总大小不得超过0x7fffffff，只能在64位下申请4G内存
    cout << "new:" << p << endl;
}
```

具体来说，当 CPU 从内存中读取或写入数据时，如果数据未正确对齐，则需要进行多次访问才能完成数据的读取或写入，这样会大幅降低数据传输效率。而经过

内存对齐处理后，CPU 可以直接从内存中读取或写入数据，无需多次访问，从而提高数据传输速度，提升整个系统的性能。

此外，为了让编译器可以方便地访问结构体或其他复合数据类型中的元素，通常也需要进行内存对齐。如果结构体中的成员未对齐，那么编译器在访问结构体成员

时可能会出现问题，这也会降低系统性能。（主要是为了提高读取数据的效率，以及提高平台的移植性）

需要注意的是，不同的编程语言和硬件平台对内存对齐的处理方式可能有所不同，具体情况需要根据实际编程环境来确定。



### 2.9.5类对象的存储方式

只保存成员变量，成员函数存放在公共的代码段。

一个类的大小，实际就是该类中”成员变量”之和，当然也要进行内存对齐，注意空类的大小，空类比较特殊，编译器给了空类一个字节来唯一标识这个类。  

原因：要是把成员变量和成员函数放在一起，会造成定义对象的时候浪费空间，每个对象都保存一份代码是没有必要的，放在公共的代码段，谁使用谁去取。



### 2.9.6计算结构体中某个成员相对于结构体起始位置的偏移量

两个办法，一个是使用offsetof宏，另一个是指针相减。

方法1：offsetof宏

```c++
class MyClass 
{
public:
	int i;
	char c;
	double d;
};

//offsetof宏计算偏移量
void test4()
{
	std::cout << "offset of i: " << offsetof(MyClass, i) << std::endl;	//0
	std::cout << "offset of c: " << offsetof(MyClass, c) << std::endl;	//4
	std::cout << "offset of d: " << offsetof(MyClass, d) << std::endl;	//8
}
```

方法2：指针相减	类型不一样进行强制转换

```c++
class MyClass 
{
public:
	int i;
	char c;
	double d;
};

void test3()
{
	MyClass obj;
	std::cout << "offset of i: " << (char*)&obj.i - (char*)&obj << std::endl;	//0
	std::cout << "offset of c: " << (char*)&obj.c - (char*)&obj << std::endl;	//4
	//std::cout << "offset of c: " << (double*)&obj.c - (double*)&obj << std::endl;	//0	
	std::cout << "offset of d: " << (char*)&obj.d - (char*)&obj << std::endl;	//8		8个1字节
	//std::cout << "offset of d: " << (int*)&obj.d - (int*)&obj << std::endl;	//2		2个4字节
	//std::cout << "offset of d: " << (double*)&obj.d - (double*)&obj << std::endl;	//1	1个8字节
}
```



### 2.9.7大小端

大端：低地址存高位，高地址存高位。（linux机器一般为大端机器）

小端：低地址存低位，高地址存高位。（windows机器一般为小端机器）

```c++
int a = 0x12345678;
//大端： 12	34	56	78
//小端： 78	56 	34	12
```

在计算机系统中，数据的存储方式有两种，分别是大端（Big-Endian）和小端（Little-Endian）。在程序中需要根据当前操作系统的字节序来选择正确地处理数

据。

```c++
//判断一台机器是大端还是小端。	windows测试的，结果是小端
//方法1：
void test5()
{
	int a = 1;	//0x00 00 00 01
	char* pa = (char*)&a;	//取一位低地址字节
	if (*pa)
		cout << "是小端" << endl;		//低地址是1说明低地址存低位，是小端
	else
		cout << "是大端" << endl;
}

//方法2：
void test6()
{
	union A
	{
		char a;
		int b;
	};

	A obja;
	obja.b = 1; //0x 00 00 00 01
	if(obja.a)
		cout << "是小端" << endl;		//低地址是1说明低地址存低位，是小端
	else
		cout << "是大端" << endl;
}
```

大小端主要用于不同计算机或设备之间的数据交换，以及内存中数据的存储和读取。在网络通信中，由于不同计算机或设备采用的字节序可能不同，因此需要在传

输时进行字节序的转换，以确保数据的正确传输。在内存中，由于不同的处理器或操作系统采用的字节序也可能不同，因此在编写程序时需要根据当前系统的字节

序来正确地处理数据，以避免出现错误。因此，理解和掌握大小端的概念和处理方法对于计算机科学和工程领域的从业人员是非常重要的。



## 2.10this指针

### 2.10.1认识this指针

在 C++ 中，`this` 指针是一个指向当前对象的指针，它是在成员函数内部自动创建的一个特殊指针。**每个对象都有自己的 `this` 指针，用来指示该对象本身的地**

**址。**

当我们调用一个成员函数时，编译器会隐式地将当前对象的地址传递给函数，并且把这个地址存储在 `this` 指针中。因此，在成员函数内部，我们可以通过 `this` 

指针来访问当前对象的成员变量和成员函数。

```c++
//结果相同，证明调用函数传的第一个形参是this指针，就是调用对象的地址
class MyClass1 
{
public:
	void print() 
	{
		std::cout << "Address of object: " << this << std::endl;
	}
};

void test7()
{
	MyClass1 obj;
	std::cout << "Address of object: " << &obj << std::endl;
	obj.print();
}

```

C++中如何区分是哪个对象调用的函数：C++编译器给每个“非静态的成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。  



### 2.10.2this指针的特性

1.**this类型：类类型* const this；**（本身的指向是不会发生变化的，不能修改this指针的指向，但是可以修改this指针指向的内容）

2.只能在非静态成员函数的内部使用，非静态成员函数中都有一个this指针，作为函数的第一个形参，this指针指向调用函数的对象；（只有在非静态成员函数的内

部存在this指针）

3.this指针存在周期：调用这个函数的时候存在，调用结束就销毁了（**this指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传**

**递给this形参。所以对象中不存储this指针。**）

4.this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递。**（一般存放在内存的栈上，但是this指针使用的比较**

**多，编译器会进行优化，优化之后存放在寄存器上，寄存器访问效率是最高的，寄存器优于缓存，缓存优于内存，寄存器是紧挨着CPU的）**



### 2.10.3this指针可以为空吗

```c++
class A1
{
public:
	void PrintA()
	{
		cout << _a << endl;
	}
	
	void Show()
	{
		cout << "Show()" << endl;
	}

private:
	int _a;
};

void test8()
{
	A1* p = nullptr;
	//p->PrintA();		//不可以调用访问了this指针指向的对象，因为this指针为nullptr，空指针不能解引用。
	p->Show();			//可以调用，没有访问this指针指向的对象，也没有修改this指针指向的对象
}
//总结：this指针能不能为空是看情况的，不访问或者修改this指针指向对象的值就可以使用，否则不能使用
```

**现实使用中，this不推荐为空，因为要操作对象。当然也不会出现this指针为空的情况，但一些特殊情况或者错误的使用可能会导致this指针为空**，如下：

1.在使用裸指针时，如果指针为空并且尝试访问其成员，则会导致访问空指针而出现 nullptr； 

2.当多线程并发访问对象时，如果没有进行正确的同步操作，可能会导致 this 指针为空或无效；

3.在某些环境下，如操作系统内核开发中，为了实现某些功能，需要手动构造对象并调用其方法，此时需要特别小心，避免出现空指针或者非法使用 this 的情

况。

总之，为了保证程序的正确性和健壮性，不能轻易地让 this 指针为空或无效。建议在编写和使用成员函数时，始终保证 this 指针的有效性，并尽量避免手动设置 

this 指针的值。

**需要注意的是，在使用智能指针（smart pointer）等 RAII（资源获取即初始化）机制时，可以避免使用裸指针，从而有效地避免因空指针访问导致的问题。而在**

**必须使用裸指针的情况下，应该在访问指针前先判断其是否为空，以避免空指针访问。**

**在 C++ 中，裸指针没有进行内存管理的能力，需要手动管理内存的分配和释放，因此使用裸指针要谨慎，避免出现内存泄漏等问题。可以使用智能指针等 RAII 机**

**制来避免这些问题。**



## 2.11裸指针

问题：裸指针是什么？

裸指针（Raw pointer）是指在编程语言中直接操作内存地址的指针，也称为未经处理的指针。与其它高级语言不同，裸指针不提供自动内存管理功能，需要手动管理内存分配和释放。

裸指针通常用于低级编程语言或对性能要求较高的场景，如系统级编程、嵌入式开发等。使用裸指针需要特别小心，因为它们容易引发内存错误，如空指针引用、非法内存访问等，可能导致程序崩溃或安全漏洞。

在现代高级编程语言中，如C++，为了提高代码的安全性和可维护性，通常推荐使用智能指针或容器等高级数据结构来替代裸指针，以便自动管理内存资源。这样可以减少内存泄漏和悬挂指针等问题的风险。



下面是一个使用裸指针的简单示例：

```c++
#include <iostream>

int main() {
    int* rawPtr = new int(5);  // 使用裸指针分配动态内存

    std::cout << "Value: " << *rawPtr << std::endl;  // 访问指针指向的值

    delete rawPtr;  // 释放动态分配的内存

    return 0;
}
```

在这个示例中，我们使用`new`操作符来动态分配一个整数的内存，并将返回的地址赋给裸指针`rawPtr`。然后，我们通过解引用指针`*rawPtr`来访问指针所指向的值。最后，使用`delete`操作符释放了动态分配的内存，以防止内存泄漏。

请注意，这只是一个基本示例，实际上，在使用裸指针时还需要考虑多种情况，如空指针检查、释放已释放的内存等，以确保正确的内存管理和避免潜在的错误。



# 3.类的6个默认成员函数

如果一个类中什么成员都没有，简称为空类。空类中什么都没有吗？并不是的，任何一个类在我们不写的情况下，都会自动生成6个默认成员函数。

```c++
class Data
{

};
```

初始化和清理：

1.构造函数主要完成初始化工作；

2.析构函数主要完成清理工作；

拷贝复制：

3.拷贝构造是使用同类对象初始化创建新对象；

4.赋值重载主要是把一个对象赋值给另一个对象；

取地址重载：

5.普通对象；

6.const对象取地址。

## 3.1构造函数

### 3.1.1构造函数的概念

构造函数是一个特殊的成员函数，名字与类名相同，**创建类类型对象时由编译器自动调用构造函数，保证每个数据成员都有 一个合适的初始值，并且在对象的生命周期内只调用一次。**（**构造函数不创建对象，是给创建的对象赋初值，只有第一次赋值叫做赋初值，所以构造函数只能调用一次**）

**编译器在创建对象时，自动调用构造函数，构造函数完成对象内容的初始化，并不是创建对象。**



### 3.1.2构造函数的特性

构造函数是特殊的成员函数，需要注意的是，**构造函数虽然名称叫构造，但是需要注意的是构造函数的任务不是开空间创建对象，而是初始化对象。**  

1.函数名和类名相同；

2.无返回值；

3.对象实例化时编译器自动调用对应的构造函数；

4.构造函数可以重载；

5.**如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成；**

6.关于编译器自动生成的构造函数，是否会完成一些事情呢？编译器生成的默认构造函数，会对自定类型成员调用它的构造函数；

7.**无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。注意：无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为是默认构造函数。**

```c++
class A
{
public:
	A(int a = 10)
	{
		_a = a;
		cout <<  "A(int)" << endl;
	}

private:
	int _a;
};

class Date
{
public:
	//类中写了构造函数编译器就不会生成无参构造，一个类中只能有一个默认构造，一般给一个全缺省构造函数
	// 1.无参构造函数，是一个默认构造，默认构造还有全缺省构造，没有构造函数的时候编译器自动调用的构造函数也是默认构造。
	Date()
	{
		cout << "Date()" << endl;
	}

	// 2.带参构造函数
	Date(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
		cout <<  "Data(int, int, int)" << endl;
	}

private:
	int _year;
	int _month;
	int _day;
	A a;	//类中有自定义成员，会调用自定义成员的默认构造函数（一个类中有自定义成员的时候，自定义成员的类中必须有默认构造函数）
};

//构造函数
void test1()
{
	//调用无参构造
	Date d1;
	
	//调用有参构造
	Date d2(2023, 6, 5);

	//不能显示调用构造函数
	//d1.Date(2023, 6, 5);		//error
	
	//输出：
	//A(int)		无参构造自定义
	//Date()
	//A(int)		有参构造自定义
	//Data(int, int, int)
}
```



### 3.1.3总结

构造函数：初始化对象的内容，不是创建对象。

1.创建对象时，编译器自动调用构造函数，不能显示调用；

2.如果没有显示定义构造，则编译器自动生成无参构造，否则，编译器不再生成无参构造；

3.默认构造：只有一个

​			无参构造

​			全缺省构造

​			没有构造函数，编译器自动生成的无参构造函数

4.**如果有自定义成员，则构造函数会自动调用自定义成员的默认构造。**



### 3.1.4补充需要学习的

学习placement new，placement new可以显示的调用构造函数。



在C++中，可以使用“placement new”运算符来显式调用对象的构造函数。"placement new"运算符允许在已分配的内存上构造对象，而不是在默认的“new”操作符下创建新的内存。

以下是一个示例，展示了如何使用"placement new"来显式调用构造函数：

```c++
#include <iostream>

class MyClass 
{
public:
    MyClass(int value) : m_value(value) 
    {
        std::cout << "Constructor called with value: " << m_value << std::endl;
    }

    ~MyClass() 
    {
        std::cout << "Destructor called with value: " << m_value << std::endl;
    }

private:
    int m_value;
};

int main() 
{
    void* memory = operator new(sizeof(MyClass));  // 分配内存

    MyClass* obj = new (memory) MyClass(42);  // 在分配的内存上调用构造函数

    obj->~MyClass();  // 显式调用析构函数

    return 0;
}

//输出结果：
//Constructor called with value: 42
//Destructor called with value: 42
```

在这个示例中，我们首先使用`operator new`来分配足够的内存来容纳一个`MyClass`对象。然后，我们使用"placement new"运算符将构造函数应用于分配的内存。通过将内存地址作为参数传递给`new`操作符，我们可以将构造函数显式地调用在该地址上执行。最后，我们使用显式调用析构函数`obj->~MyClass()`来销毁对象并释放内存。

请注意，在使用"placement new"时，我们需要手动管理内存的分配和释放。这意味着我们需要调用`operator new`来分配内存，并使用`operator delete`来释放内存，而不是简单地使用`delete`操作符。**此外，我们还需要显式调用析构函数来销毁对象。这种方法需要更加谨慎地处理内存和对象的生命周期，因为编译器无法自动帮助我们处理这些任务。**



## 3.2析构函数

### 3.2.1析构函数的概念

析构函数：与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器完成的。而**对象在销毁时会自动调用析构函数，完成类的一些资源清理工作。**  



### 3.2.2析构函数的特性

1.析构函数名是在类名前加上字符~；

2.无参数无返回值；

3.**一个类有且只有一个析构函数，若未显示定义，系统会自动生成默认的析构函数；**

4.对象生命周期结束时，c++编译系统自动调用析构函数来释放对象所占用的内存；（这意味着，我们不需要手动调用析构函数来释放对象，编译器会代替我们完

成这一过程。）

5.**关于编译器自动生成的析构函数，是否会完成一些事情呢？编译器生成的默认析构函数，会对自定类型成员调用它的析构函数。（关于编译器自动生成的析构函**

**数，它会对类中所有自定义类型成员调用它们的析构函数。如果我们未显式定义析构函数，那么编译器生成的默认析构函数会依次调用每个成员变量的析构函数，**

**在对象销毁时释放它们所占据的内存。）**

```c++
//#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <assert.h>

using namespace std;

typedef int DataType;

class SeqList
{
public:
	SeqList(int capacity = 10)
	{
		_pData = (DataType*)malloc(capacity * sizeof(DataType));
		assert(_pData);
		_size = 0;
		_capacity = capacity;
	}

	~SeqList()
	{
		cout << "~SeqList()" << endl;
		if (_pData)
		{
			free(_pData);	// 释放堆上的空间
			_pData = NULL;	// 将指针置为空
			_capacity = 0;
			_size = 0;
		}
	}

private:
	int* _pData;
	size_t _size;
	size_t _capacity;
};

class Date
{
public:
	Date(int year = 2023, int month = 6, int day = 5)
	{
		_year = year;
		_month = month;
		_day = day;
		cout << "Data(int, int, int)" << endl;
	}

private:
	int _year;
	int _month;
	int _day;
	SeqList a;	//类中有自定义成员，会调用自定义成员的默认构造函数和析构函数
};

int main()
{
	Date d1;
	return 0;
}
//输出：
//Data(int, int, int)
//~SeqList()		//编译器的默认析构函数调用类中自定义成员的析构函数
```



## 3.3拷贝构造函数

### 3.3.1拷贝构造函数的概念

构造函数：只有单个形参，该形参是对本类类型对象的引用(一般常用const修饰)，在用已存在的类类型对象创建新对象时由编译器自动调用。

**拷贝构造函数和构造函数一样，都是在对象创建好之后调用的，作用都是赋值，而不是创建对象。**



### 3.3.2拷贝构造函数的特性

**拷贝构造函数是特殊的构造函数。**

1.拷贝构造函数是构造函数的一个重载形式；

2.**拷贝构造函数的参数只有一个且必须使用引用传参，使用传值方式会引发无穷递归调用**；

原因：传递值会发生值拷贝，会递归调用拷贝构造函数，即触发拷贝构造函数调用自身的问题，导致无限递归并最终耗尽程序堆栈空间，从而导致程序崩溃。

3.**若未显示定义，系统生成默认的拷贝构造函数。默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝叫做浅拷贝或者值拷贝**；

```c++
//#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <assert.h>

using namespace std;

//编译器默认生成的值拷贝，也叫做浅拷贝，没有开辟空间的时候可以使用，有空间开辟的时候不能，因为空间释放的时候会出现重复释放的错误。
//默认拷贝构造	浅拷贝
class Date
{
public:
	Date(int year = 2023, int month = 6, int day = 5)
	{
		_year = year;
		_month = month;
		_day = day;
		cout << "Data(int, int, int)" << endl;
	}

	~Date()
	{
		cout << "~Date()" << endl;
	}

	//如果不显示定义拷贝构造，编译器会自动生成默认拷贝构造
	Date(const Date& d)
	{
		cout << "Date(const Date& d)" << endl;
		_year = d._year;
		_month = d._month;
		_day = d._day;
	}

private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	Date d;
	Date d1(d);			//拷贝构造传递引用
}
//输出：
//Data(int, int, int)
//Date(const Date& d)
//~Date()
//~Date()
```

4.那么编译器生成的默认拷贝构造函数已经可以完成字节序的值拷贝了，我们还需要自己实现吗？当然像日期类这样的类是没必要的。那么下面的类呢？验证一下试试？  （**有资源的类必须显示定义拷贝构造，实现深拷贝。**）

```c++
//编译器自动生成的默认拷贝构造函数不能完成深拷贝，只能完成浅拷贝，下面自己实现一个深拷贝

```

**总结：只有值拷贝的时候，使用编译器生成的默认拷贝构造函数是可以的，但是有空间的时候要自己实现拷贝构造函数，完成深拷贝。**

注意：

拷贝构造只要没有，编译器就会生成拷贝构造。

构造函数是没有任何一个构造函数编译器才会生成无参构造函数。（**注意：有拷贝构造的时候自己要实现无参构造函数或者默认构造函数。**）

**总结：如果显示定义了构造函数，需要手动实现无参构造函数，这里无参构造函数推荐使用全缺省构造函数。**

```c++
#include <iostream>
#include <assert.h>

using namespace std;

class Date
{
public:
	~Date()
	{
		cout << "~Date()" << endl;
	}

	//如果不显示定义拷贝构造，编译器会自动生成默认拷贝构造
	Date(const Date& d)
	{
		cout << "Date(const Date& d)" << endl;
		_year = d._year;
		_month = d._month;
		_day = d._day;
	}

private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	Date d;				//error，类Date不存在默认构造函数
}
```



```c++
//修改上面的代码：添加无参构造函数（在手动显示实现拷贝构造函数的时候也要手动显示实现无参构造函数。）
#include <iostream>
#include <assert.h>

using namespace std;

class Date
{
public:
	~Date()
	{
		cout << "~Date()" << endl;
	}

	Date(int year = 1998, int month = 11, int day = 3)
		:_year(year)
		,_month(month)
		,_day(day)
	{}

	//如果不显示定义拷贝构造，编译器会自动生成默认拷贝构造
	Date(const Date& d)
	{
		cout << "Date(const Date& d)" << endl;
		_year = d._year;
		_month = d._month;
		_day = d._day;
	}

private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	Date d;				
}
//输出结果：~Date()
```



## 3.4赋值运算符重载

### 3.4.1运算符重载	

注意点：不是类的默认成员函数。（**运算符重载在类中默认只实现了赋值运算符，没有重载其余运算符，需要手动实现、赋值运算符有的情况下也需要手动实现。**）

C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与

普通的函数类似。

函数名字为：关键字operator后面接需要重载的运算符符号。

函数原型：返回值类型 operator操作符(参数列表)  



规定：

1.不能通过连接其他符号来创建新的操作符：比如operator@；（operator只能连接语法中已经存在的运算符，不能创建新的运算符。）

2.**重载操作符必须有一个类类型或者枚举类型的操作数**；（不理解）

3.用于内置类型的操作符，其含义不能改变，例如：内置的整型+，不能改变其含义；

4.作为类成员的重载函数时，其形参看起来比操作数数目少1个，成员函数的操作符有一个默认的形参this，限定为第一个形参；

5.根据 C++11 标准，在 [over.oper] 章节中规定了以下运算符是不能被重载的：

1. 作用域解析运算符 `::`
2. 成员指针运算符 `.*`（后面学习）
3. 成员对象指针运算符 `.`
4. 条件运算符 `?:`
5. 大小和对齐操作符 `sizeof`
6. 类型名字查询运算符 `typeid`            实际用法：cout << typeid(d).name() << endl;   或者    cout << typeid(Date).name() << endl;

此外，根据 C++20 标准，在 [lex.charset] 章节中规定了预处理符号 `#` 和 `##` 也不能被重载。

需要注意的是，这些规定是 C++ 标准强制实施的规则，旨在保证语言的一致性和可移植性，避免出现重载行为不一致、歧义或非法的情况。在实际编程中，我们应该尽量遵守这些规定，以保证代码的正确性和可读性。

**同时，在某些情况下，我们可能会需要模拟某些不能被重载的运算符的行为，例如可以使用函数或者类成员函数来模拟某些运算符的行为。但是，需要注意将运算符重载的行为和原始的语义保持一致，避免出现意外的结果。**

重载的两种写法：

```C++
//#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

//第一种写法：把重载放在类的外面			可以使用友元保证类的封装性
class Date
{
	friend bool operator==(const Date& d1, const Date& d2);
public:
	Date(int year = 2023, int month = 6, int day = 5)
	{
		_year = year;
		_month = month;
		_day = day;
	}

private:
	int _year;
	int _month;
	int _day;
};

bool operator==(const Date& d1, const Date& d2)
{
	return d1._year == d2._year && d1._month == d2._month && d1._day == d2._day;
}

int main()
{
	Date d1(2023, 6, 6);
	Date d2(2023, 6, 6);
	//判断日期对象是否相等
	if (d1 == d2)
		cout << "日期相等" << endl;
	else
		cout << "日期不相等" << endl;
}
//输出结果：
//日期相等
```



```c++
//#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

//第二种写法：把重载放在类的里面	 
class Date
{
	friend bool operator==(const Date& d1, const Date& d2);
public:
	Date(int year = 2023, int month = 6, int day = 5)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	bool operator==(const Date& d)
	{
		return _year == d._year && _month == d._month && _day == d._day;
	}

private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	Date d1(2023, 6, 6);
	Date d2(2023, 6, 6);
	//判断日期对象是否相等
	if (d1 == d2)
		cout << "日期相等" << endl;
	else
		cout << "日期不相等" << endl;
}
//输出结果：
//日期相等
```



```c++
//#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

//把重载放在类的里面
class Date
{
public:
	Date(int year = 2023, int month = 6, int day = 5)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	bool operator==(const Date& d)
	{
		return _year == d._year && _month == d._month && _day == d._day;
	}

private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	Date d1(2023, 6, 6);
	Date d2(2023, 6, 6);
	//判断日期对象是否相等
	if (d1 == d2)			//等价于d1.operator(d2)	等价于operator==(d1,d2)
		cout << "日期相等" << endl;
	else
		cout << "日期不相等" << endl;

	return 0;
	//this指针始终指向运算符的第一个参数
}
//输出结果：
//日期相等
```



### 3.4.2赋值运算符重载

注意点：是类的默认成员。（**运算符重载在类中默认只实现了赋值运算符，没有重载其余运算符，需要手动实现、赋值运算符有的情况下也需要手动实现。**）

赋值运算符主要有四点：

1.参数类型

2.返回值

3.检查是否自己给自己赋值

4.返回*this

5.一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝。

```c++
//#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

class A
{
public:
	A& operator=(A& a)
	{
		if (this != &a)
			_a = a._a;
		cout << "operator=(A&)" << endl;
		return *this;
	}

	int _a;
};

//赋值运算符重载
class Date
{
public:
	Date(int year = 2023, int month = 6, int day = 5)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	bool operator==(const Date& d)
	{
		return _year == d._year && _month == d._month && _day == d._day;
	}

	/* 
	Date& operator=(Date& d)		//返回拷贝和引用都行，但是引用效率更高，返回值要调用拷贝构造
	{
		//&d是取引用对象的地址
		if (this != &d)		//自己给自己赋值，直接跳过	根据地址判断
		{
			_year = d._year;
			_month = d._month;
			_day = d._day;
		}
		cout << "operator=(Date&45)" << endl;
		return *this;			//返回被赋值好的对象
	}
	*/

private:
	int _year;
	int _month;
	int _day;
	A a;
};

int main()
{
	Date d1(2023, 6, 5);
	Date d2(1, 1, 1);
	Date d3(1998, 11, 3);
	//赋值运算符：修改已经存在的对象的内容
	d3 = d1 = d2;		 //等价于d3.operator=(d1.operator=(d2));
	//d3.operator=(d1.operator=(d2));	在类中不显示定义赋值运算符，默认赋值运算符会自动调用自定义赋值运算符
	//输出结果：
	//operator=(A&)
	//operator=(A&)
	Date d4 = d1;			//不是赋值，是拷贝构造
	//赋值的意义是修改已经存在的对象的内容
	//拷贝构造是创建一个新对象的时候调用拷贝构造，但拷贝构造不是创建一个新的对象，是初始化新的对象
}
//连续赋值的顺序是从右向左赋值
//a = b = c			
//分解为：b = c   a = b
```

**赋值运算符编译器自己实现了，还需要显示实现赋值运算符吗，是需要的，当有空间的时候需要显示实现赋值运算符，就和深拷贝一样。**

```c++
//这个代码不仅会造成重复释放，还会造成内存泄漏
class String
{
public:
	String(const char* str = "")
	{
		_str = (char*)malloc(strlen(str) + 1);
		strcpy(_str, str);
	}

    ~String()
	{
		cout << "~String()" << endl;
		free(_str);
	}
    
private:
	char* _str;
};

int main()
{
	String s1("hello");
	String s2("world");
	s1 = s2;		//error
}
```

```c++
//深拷贝
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

class String
{
public:
	/*
	String(const char* str = "")
	{
		_str = (char*)malloc(strlen(str) + 1);
		strcpy(_str, str);
	}
	*/

	String(const char* str = "")
		: _str(nullptr)
	{
		if (str != nullptr)
		{
			_str = new char[strlen(str) + 1];
			strcpy(_str, str);
		}
	}

	/* 
	String(const String& other)
		: _str(nullptr)
	{
		if (other._str != nullptr) 
		{
			_str = new char[strlen(other._str) + 1];
			strcpy(_str, other._str);
		}
	}
	*/

	//深拷贝
	String& operator=(const String& other)
	{
		if (this != &other) 
		{
			char* temp = new char[strlen(other._str) + 1];
			strcpy(temp, other._str);
			delete[] _str;		//释放原来的字符串空间
			_str = temp;		//将新空间中的字符串拷贝到原来空间中
		}
		return *this;
	}

	~String()
	{
		cout << "~String()" << endl;
		delete[] _str;
	}

private:
	char* _str;
};

int main()
{
	String s1("hello");
	String s2("world");
	s1 = s2;
	return 0;
}
```



## 3.5const成员

### 3.5.1const修饰类的成员函数

将const修饰的类成员函数称之为const成员函数，const修饰类成员函数，实际修饰该成员函数隐含的this指针，表明在该成员函数中不能对类的任何成员进行修

改。（只能修饰类的成员函数）

```c++
class B
{
public:
	int get1()		//this：const B		this的指向不能改变
	{
		_b = 10;
		return _b;
	}

	int get2() const	//const this：const B* const	this的指向和this指向的值都不能改变
	{
		//_b = 10;		//不允许修改this指针指向的内容
		return _b;
	}

private:
	int _b;
};
```

```c++
class B
{
public:
	int get1()		//this：const B		this的指向不能改变
	{
		_b = 10;
		//非const成员函数内可以调用其它的const成员函数吗
		get2();		//可以
		return _b;
	}

	int get2() const	//const this：const B* const	this的指向和this指向的值都不能改变
	{
		//_b = 10;		//不允许修改
		//const成员函数内可以调用其它的非const成员函数吗
		//get1();	//不能	原因：this指针的内容不能修改，不能调用非const成员函数
		return _b;
	}

private:
	int _b;
};

void test7()
{
	B b;
	const B b1;
	//const对象可以调用非const成员函数吗
	//b1.get1();  //不可以	原因：b1是const对象，表明b1的内容不能修改，非const成员函数是可以修改的，违背了含义
	//非const对象可以调用const成员函数吗
	b.get2();	//可以调用
	//原则是对象的权限不能放大，但是可以缩小
}
```



## 3.6取地址及const取地址操作符重载

```c++
class Date
{
public:
	Date* operator&()
	{
		return this;
	}
	const Date* operator&()const
	{
		return this;
	}
    //这两个函数构成重载了，参数一个是Date* const，一个是const Date* const
private:
	int _year; // 年
	int _month; // 月
	int _day; // 日
};

void test8()
{
	Date obja;
	Date* pa = &obja;
	const Date objb;
	const Date* pa = &objb;
}
//实现的时候两个都要实现
```

这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊情况，才需要重载，比如**想让别人获取到指定的内容。**  

一般都不写，病毒等一些特殊场合会有，不会是好事。



# 4.日期类的实现

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

class Date
{
public:
	//构造函数
	Date(int y = 1, int m = 1, int d = 1)
		:_y(y)
		,_m(m)
		,_d(d)
	{
		//判断日期是否有效
		if (y <= 0 || m <= 0 || m > 12 || d <= 0 || d > getDay(y, m))
		{
			//日期无效
			_y = 1;
			_m = 1;
			_d = 1;
			cout << "日期无效，设为默认值1-1-1" << endl;
		}
		else
		{
			//日期有效
			_y = y;
			_m = m;
			_d = d;
		}
	}

	//获取每年每月的天数
	int getDay(int y, int m)
	{
		static int days[] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
		int day = days[m];
		//如果是2月且为闰年，2月天数加1
		if (m == 2 && (((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0)))
			day += 1;
		return day;
	}

	//运算符重载
	//日期运算
	//Date += int	日期 += 天数
	Date& operator+=(int day)
	{
		//判断天数是否为负数	
		if (day < 0)
			return *this -= -day;	//整个过程没有发生拷贝，效率很高
		//相加天数
		_d += day;
		//判断天数是否溢出
		while (_d > getDay(_y, _m))
		{
			//减去当月的天数
			_d -= getDay(_y, _m);
			//月份进位
			++_m;
			//判断月份是否溢出
			if (_m == 13)
			{
				//年份进位
				_y++;
				//下一年的1月份
				_m = 1;
			}
		}
		return *this;	//返回相加之后的结果
	}

	//Date + int
	//加法：返回相加之后的结果，操作数不能改变
	Date operator+(int day)
	{
		Date res = *this;
		return res += day;		//返回结果发生了值拷贝
	}

	//++Date	前置++
	Date& operator++()
	{
		return *this += 1;
	}

	//Date++	后置++
	Date operator++(int)	//占位符	//参数是无用的，只是为了区分前置++和后置++
	{
		Date res = *this;
		*this += 1;
		return res;		//值返回,发生了值拷贝
	}

	Date& operator-=(int day)
	{
		//判断天数是否为负数
		if (day < 0)
			return *this += -day;	//整个过程没有发生拷贝，效率很高
		_d -= day;
		while (_d <= 0)
		{
			//用上个月的天数回补
			_m--;
			//判断月份是否溢出，要注意先后顺序
			if (_m == 0)
			{
				//回退到上一个月的12月份
				_y--;
				_m = 12;
			}
			_d += getDay(_y, _m);
		}
		return *this;
	}

	//Date - int
	Date operator-(int day)
	{
		Date res = *this;
		res -= day;
		return res;
	}

	//--Date
	Date& operator--()
	{
		return *this -= 1;
	}

	//Date--
	Date operator--(int)
	{
		Date res = *this;
		*this -= 1;
		return res;
	}

	//==
	bool operator==(const Date& d)
	{
		return _y == d._y && _m == d._m && _d == d._d;
	}

	//!=
	bool operator!=(const Date& d)
	{
		//return !operator==(d);
		return !(*this == d);
	}

	//>
	bool operator>(const Date& d)
	{
		if (_y > d._y)
			return true;
		else if (_y == d._y && _m > d._m)
			return true;
		else if (_y == d._y && _m == d._m && _d > d._d)
			return true;
		else
			return false;
	}

	//<
	bool operator<(const Date& d)
	{
		return !(*this >= d);
	}

	//>=
	bool operator>=(const Date& d)
	{
		return (*this > d) || (*this == d);
	}

	//<=
	bool operator<=(const Date& d)
	{
		return !(*this > d);
	}

	//日期相减：Date - Date
	int  operator-(const Date& d)
	{
		//计算比较小的日期经过多少次自加的运算，可以和比较大的日期相同
		//自加的次数就是相差的次数
		Date max = *this;
		Date min = d;
		int flag = 1;		//*this大，是正值
		if (max < min)
		{
			min = *this;
			max = d;
			flag = -1;		//d大，是负值
		}
		int day = 0;
		while (min < max)
		{
			++min;
			++day;
		}
		return flag * day;
	}

	//输出年月日
	void play()
	{
		cout << "year = " << _y << " month = " << _m << " day = " << _d << endl;
	}

private:
	int _y;		//年
	int _m;		//月
	int _d;		//日
};

/*
//加法操作
void test1()
{
	Date d1(2021, 2, 4);
	Date d2(2021, 2, 4);
	Date d3(2021, 2, 4);
	Date d4(2021, 2, 4);
	d1.operator+=(1);		//2021.2.5
	d2 += 30;
	d3 += 90;
	d4 += 360;
	d1.play();	//year = 2021 month = 2 day = 5
	d2.play();	//year = 2021 month = 3 day = 6
	d3.play();	//year = 2021 month = 5 day = 5
	d4.play();	//year = 2022 month = 1 day = 30
	d3 = d4 + 90;
	d3.play();	//year = 2022 month = 4 day = 30
	d4.play();	//不发生改变	year = 2022 month = 1 day = 30
	++d3;
	d3.play();	//year = 2022 month = 5 day = 1
	Date d5 = d3++;
	d3.play();	//year = 2022 month = 5 day = 2
	d5.play();	//year = 2022 month = 5 day = 1
	//后置++
	//d5 = d4++10;	//error，编译器无法识别
	//d5 = d4.operator++(10);	//ok,这个是可以的，因为参数里面有内容表示后置，没内容表示前置，简写可以直接识别出来
	//参数是无用的，只是为了区分前置++和后置++
}
*/

//减法操作
void test2()
{
	Date d1(2021, 2, 5);
	Date d2(2021, 2, 5);
	Date d3(2021, 2, 5);
	Date d4(2021, 2, 5);
	d1 -= 1;
	d2 -= 30;
	d3 -= 90;
	d4 -= 360;
	d1.play();	//year = 2021 month = 2 day = 4
	d2.play();	//year = 2021 month = 1 day = 6
	d3.play();	//year = 2020 month = 11 day = 7
	d4.play();	//year = 2020 month = 2 day = 11
	d3 = d4 - 30;
	d3.play();	//year = 2020 month = 1 day = 12
	d3 = --d4;
	d3.play();	//year = 2020 month = 2 day = 10
	d4.play();	//year = 2020 month = 2 day = 10
	d3 = d4--;
	d3.play();	//year = 2020 month = 2 day = 10
	d4.play();	//year = 2020 month = 2 day = 9
	//日期自减
	cout << d4 - d3 << endl;	//-1
	cout << d3 - d4 << endl;	//1
}

int main()
{
	//test1();	//加法操作
	test2();	//减法操作
	return 0;
}
```

总结：返回最终的结果就使用引用返回；返回的不是最终的结果，要使用临时值的，就使用值返回。



# 5.再谈构造函数

## 5.1构造函数体赋值

在创建对象时，编译器通过调用构造函数，给对象中各个成员变量一个合适的初始值。

```c++
class Date
{
public:
	Date(int year, int month, int day)
		//初始化列表，真正初始化的地方
		:_year(year)		//括号里面可以是值，也可以是表达式
		,_month(month)
		,_day(day)
	{
        //函数体
		//不是初始化，只是赋初值
		//_year = year;
		//_month = month;
		//_day = day;
	}

private:
	int _year;
	int _month;
	int _day;
};
```

 对象中已经有了一个初始值，但是不能将其称作为类对象成员的初始化，**构造函数体中的语句只能将其称作为赋初值**，而不能称作初始化。因**初始化只能初始**

**化一次，而构造函数体内可以多次赋值**。  



## 5.2初始化列表

初始化列表：以一个**冒号开始**，接着是一个以**逗号分隔的数据成员列表**，每个"**成员变量**"后面跟一个**放在括号中的初始值或表达式。**  

注意点：

1.函数体中有值，初始化列表初始化对象之后，进入函数体替换对象的值；

2.每个成员变量在初始化列表中**只能出现一次**(初始化只能初始化一次）；

3.类中包含以下成员，必须放在初始化列表位置进行初始化：

​	3.1引用成员变量	原因：引用不存在空引用，类定义时不占空间的，只有实例化对象之后成员才占空间，实例化对象之后调用构造函数给引用成员初始化，必	须给一个值，只能在初始化列表，在函数体中是赋值，不是初始化。（引用成员定义的地方就是初始化列表）

​	3.2const成员变量	原因：const对象不能改变，在初始化的时候给一个值就不能再改变了，在初始化列表才叫初始化。

​	3.3自定义类型成员（该类没有默认构造函数）	原因：如下

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

class Time
{
public:
	Time(int hour,int minute,int second)
		:_hour(hour)
		,_minute(minute)
		,_second(second)
	{}

private:
	int _hour;
	int _minute;
	int _second;
};

class Date
{
public:
	Date(int year, int month, int day)
		//初始化列表，真正初始化的地方
		:_year(year)		//括号里面可以是值，也可以是表达式
		,_month(month)
		,_day(day)
		,_hour(12)
		//报错：类Time不存在默认构造函数
	{
		//不是初始化，只是赋初值
		//_year = year;
		//_month = month;
		//_day = day;
	}

private:
	int _year;
	int _month;
	int _day;
	const int _hour;
	Time _t;
};

int main()
{
	Date d(2021, 3, 3);
}
```

```c++
//上面代码修改之后：
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

class Time
{
public:
	Time(int hour,int minute,int second)
		:_hour(hour)
		,_minute(minute)
		,_second(second)
	{}

private:
	int _hour;
	int _minute;
	int _second;
};

class Date
{
public:
	Date(int year, int month, int day)
		//初始化列表，真正初始化的地方
		:_year(year)		//括号里面可以是值，也可以是表达式
		,_month(month)
		,_day(day)
		,_hour(12)
		//报错：类Time不存在默认构造函数
		//新添加的
		,_t(1,1,1)		//这样就可以了，一般不会出现这种情况，一般自定义成员的类使用全缺省构造函数
	{
		//不是初始化，只是赋初值
		//_year = year;
		//_month = month;
		//_day = day;
	}

private:
	int _year;
	int _month;
	int _day;
	const int _hour;
	Time _t;
};

int main()
{
	Date d(2021, 3, 3);
}
```

```c++
//补充：必须在初始化列表初始化
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

class Time
{
public:
	Time(int hour,int minute,int second)
		:_hour(hour)
		,_minute(minute)
		,_second(second)
	{}

private:
	int _hour;
	int _minute;
	int _second;
};

class Date
{
public:
	Date(int year, int month, int day,Time t)
		//初始化列表，真正初始化的地方
		:_year(year)		//括号里面可以是值，也可以是表达式
		,_month(month)
		,_day(day)
		,_hour(12)
		//报错：类Time不存在默认构造函数
		//新添加的
		//,_t(1,1,1)		//这样就可以了，一般不会出现这种情况，一般自定义成员的类使用全缺省构造函数
		//在函数体中赋值，报错：类Time不存在默认构造函数
	{
		_t = t;
		//不是初始化，只是赋初值
		//_year = year;
		//_month = month;
		//_day = day;
	}

private:
	int _year;
	int _month;
	int _day;
	const int _hour;
	Time _t;
};

void test1()
{
	Time t(2, 1, 1);		//当传的值和初始化列表的值不一样使用初始化列表的值，因为这里并没有实参给形参赋值，函数体有赋值的话就是传的值
	Date d(2021, 3, 3,t);
}
```

4.**尽量使用初始化列表初始化，因为不管你是否使用初始化列表，对于自定义类型成员变量，一定会先使用初始化列表初始化；（构造函数的调用顺序，先调用自定义成员变量的构造函数，再执行自己本身的构造函数，构造函数调用的时候先进入初始化列表）**

5.**成员变量在类中声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后次序无关。（是按照声明顺序在初始化列表进行初始化的）**

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

class A
{
public:
	A(int a)
		:_a1(a)
		, _a2(_a1)
	{}
	
	void Print() 
    {
		cout << _a1 << " " << _a2 << endl;
	}

private:
	//初始化顺序，和初始化列表无关
	int _a2;
	int _a1;
};

void test2()
{
	A aa(1);
	aa.Print();		//_a1 = 1	_a2 = -858993460
}
```

6.**不写初始化列表，初始化是随机值，然后在函数体中二次赋值。**

**技巧：声明顺序和初始化列表写的顺序一致，避免出错。**



## 5.3explicit关键字

构造函数不仅可以构造与初始化对象，**对于单个参数的构造函数，还具有类型转换的作用**。

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

class Date
{
public:
	//这个代码加上explicit是错的，不加是对的，原因是explicit修饰构造函数会禁止单参构造隐式类型转换
	explicit Date(int year)
		:_year(year)
	{}

private:
	int _year;
	int _month;
	int _day;
};

void test3()
{
	Date d1(2018);		//构造函数	ok
	Date d2 = d1;		//拷贝构造	ok
	// 用一个整形变量给日期类型对象赋值
	// 实际编译器背后会用2019构造一个无名对象，最后用无名对象给d1对象进行赋值
	//d1 = 2019;			//error
	//为啥叫单参：d1 = 2019，2018;		//不存在这种写法
	//过程：叫做单参构造隐式类型转换
	//1.用2019调用构造函数创建匿名对象
	//2.调用赋值运算符，用匿名对象的内容赋值给d1
}
```

作用：用explicit修饰构造函数，将会禁止单参构造函数的隐式转换。  

不加不会报错，加上会使代码的可读性不好。（因为一眼看过去是错的，但不加explicit是可以通过编译的，加上使类型检查更严格，不加类型检查不严格）



# 6.static成员

## 6.1概念

声明为static**的类成员**称为**类的静态成员**，用static修饰的**成员变量**，称之为**静态成员变量**；用static**修饰**的**成员函数**，称之为**静态成员函数**。**静态的成员变量一定要在类外进行初始化。**（**静态成员在类外初始化，原因：静态成员在静态数据段，不属于对象，对象共享静态成员变量（静态成员不属于对象），没有对象，也会有静态成员**）

```c++
//实现一个类，计算程序中创建出了多少个类对象
class A
{
public:
	A()
	{
		++_scount;
	}

	A(const A& t)
	{
		++_scount;
	}

    //静态成员函数不包含this指针的原因：类名不包含this指针，没有调用对象就没有this指针，this指针指向调用此次函数的对象
	static int GetACount()
	{
        //func();	//error，静态成员函数不能调用普通成员函数，原因：静态成员函数没有this指针，不能访问含有this指针的（this指针指向调用此函数的对象，this指针不能指向类名，静态成员函数中普通函数没办法传递this指针）
		return _scount;
	}
    
    //普通成员函数有this指针，是第一个参数
    void fun()
    {
        GetACount();	//普通函数中可以调用静态成员函数，静态成员函数缩小访问方式，在普通函数中只按照成员访问，不按照类名访问
        cout << "fun()" << endl;
    }

//private:
	static int _scount;
};

int A::_scount = 0;

A funA(A a)
{
	return a;
}

void test4()
{
	cout << A::GetACount() << endl;	//0
	A a1, a2;	//2次构造函数
	A a3(a1);	//1次拷贝构造
	A a4 = funA(a1);	//2次拷贝构造：传值参数拷贝构造和返回值拷贝构造
	//函数两种访问方式
    cout << A::GetACount() << endl;	//5
	cout << a1.GetACount() << endl;	//5
    //静态成员访问方式：
    //1.对象.static成员
	cout << a1._scount << endl;		//5
	//2.类::staitc成员	在没有创建任何对象时，静态成员已经存在，可以通过类名访问
	cout << A::_scount << endl;		//5
}
```



## 6.2特性

1.静态成员为所有类对象所共享，不属于某个具体的实例；

2.静态成员变量必须在类外定义，定义时不添加static关键字，按照类名::static成员变量进行定义；

3.类静态成员即可用类名::静态成员或者对象名.静态成员来访问；

4.静态成员函数**没有**隐藏的this**指针**，不能访问任何非静态成员；

5.**静态成员和类的普通成员一样，也有public、protected、private3种访问级别，也可以具有返回值。**



问题：

1.静态成员函数可以调用非静态成员函数吗？

不能

2.非静态成员函数可以调用类的静态成员函数吗？  

可以

原因：上面代码解释了。



# 7.c++11的成员初始化新玩法

C++11支持非静态成员变量在声明时进行初始化赋值，**但是要注意这里不是初始化，这里是给声明的成员变量缺省值。**  

```c++
class B
{
public:
	B(int b = 0)
		:_b(b)
	{}
	
	int _b;
};

class A
{
public:
	void Print()
	{
		cout << a << endl;
		cout << b._b << endl;
		cout << p << endl;
	}
private:
	//非静态成员变量，可以在成员声明时给缺省值。
	int a = 10;
	B b = 20;
	int* p = (int*)malloc(4);
	static int n;	//静态成员不可以，是在类外定义的
};

int A::n = 10;

void test5()
{
	A a;	//适合于编译器生成的默认构造
	a.Print();
}
```

```c++
class A
{
public:
	A(int a = 1)	
		:_a(a)
	{}

private:
	int _a = 0;	//在构造函数中给出缺省值就按缺省值来，这里是备用值，没有别的值的时候使用
    //如果有自定义成员变量，自定义成员的类必须有无参构造函数，自定义的类的备用值不能代替无参构造函数。（如果没有，会报错）（这个语法不推荐使用）
};

void test6()
{
	A a;	//a._a = 1
}
```

**注意点：这个语法只适用于非静态成员。**



# 8.友元

友元分为：**友元函数**和**友元类**

**友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用。**  



## 8.1友元函数

问题：现在我们尝试去重载operator<<，然后发现我们没办法将operator<<重载成成员函数。因为cout的输出流对象和隐含的this指针在抢占第一个参

数的位置。this指针默认是第一个参数也就是左操作数了。但是实际使用中cout需要是第一个形参对象，才能正常使用。所以我们要将operator<<重载成全局函

数。但是这样的话，又会导致类外没办法访问成员，那么这里就需要友元来解决。operator>>同理。

```c++
class Date
{
public:
	Date(int year, int month, int day)
		:_year(year)
		,_month(month)
		,_day(day)
	{}

	ostream& operator<<(ostream& _cout)
	{
		_cout << _year << "-" << _month << "-" << _day << endl;
		return _cout;
	}

private:
	int _year;
	int _month;
	int _day;
};

void test7()
{
	Date d(2017, 12, 24);
	d << cout;
	d.operator << (cout);
	//和我们想的cout << d;不一样
}
```

友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声明，声明时需要加friend关键字。  

```c++
//使用友元函数之后（重点）
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

class Date
{
	friend ostream& operator<<(ostream& _cout, const Date& d);
	friend istream& operator>>(istream& _cin, Date& d);

public:
	Date(int year, int month, int day)
		:_year(year)
		, _month(month)
		, _day(day)
	{} 

private:
	int _year;
	int _month;
	int _day;
};

ostream& operator<<(ostream& _cout, const Date& d)
{
	_cout << d._year << "-" << d._month << "-" << d._day << endl;
	return _cout;
}

istream& operator>>(istream& _cin, Date& d)
{
	_cin >> d._year;
	_cin >> d._month;
	_cin >> d._day;
	return _cin;
}

int main()
{
	Date d(2023, 6, 9);
	Date d1(1998, 11, 3);
	cin >> d >> d1;			//等价于operator>>(operator>>(cin, d), d1);
	cout << d << d1 << endl;		//等价于operator<<(operator<<(cout, d), d1) << endl;
	//endl是本来就支持的，不需要友元函数重载。
	//d.operator<<(cout, d);		//error，原因是友元函数不属于类的成员函数，是普通函数
	//友元只是为了让类外的函数可以访问类内的私有成员，突破封装的限制
	//控制台结果，前两行输入，后两行输出
	//1998 11 03
	//2023 6 9
	//1998 - 11 - 3
	//2023 - 6 - 9
	cout << endl;
	cout.operator<<(endl);	//在输出流中重载了<<操作符（下面会有更加详细的关于endl的解释）
	return 0;
}
```

说明：

1.友元函数可访问类的私有和保护成员，但不是类的成员函数；

**2.友元函数不能用const修饰；**

原因：const修饰成员函数的时候修饰的是成员函数的this指针，但是友元函数不是类的成员函数，只是一个普通函数，不是成员函数自然不能用const修饰。（const只能修饰类的成员函数）

3.友元函数可以在类定义的任何地方声明，不受类访问限定符限制；

4.一个函数可以是多个类的友元函数；

5.友元函数的调用与普通函数的调用和原理相同。



详细解释`std::endl`：

在C++中，`std::endl`是一个被称为操纵符（manipulator）的特殊值。它实际上是一个函数模板，用于在输出流中插入一个换行符并刷新流。

`std::endl`的类型是一个函数指针，具体类型是`std::ostream& (*)(std::ostream&)`。这个函数接受一个`std::ostream`类型的引用作为参数，并返回同样的引用，用于链式操作。

**使用`std::endl`时，它会在输出流中插入一个换行符，并立即刷新缓冲区，将输出发送到目标设备。相当于执行了两个操作：`'\n'`和`std::flush`。**

**注意点：`std::endl`的使用会导致性能损失，因为它强制刷新输出缓冲区。如果不需要立即刷新缓冲区，可以考虑使用只插入换行符的`'\n'`字符，以提高效率。**



## 8.2友元类

特点：

1.友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的非公有成员；

2.友元关系是单向的，不具有交换性；

解释：比如下面代码中的Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接访问Time类的私有成员变量，但想在Time类中访问

Date类中私有的成员变量则不行。

3.友元关系不能传递。

如果B是A的友元，C是B的友元，则不能说明C是A的友元。  

补充：友元关系不能继承。

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

class Date; // 前置声明		//可以把类放在一个.h文件中，.cpp定义函数
class Time
{
	friend class Date; // 声明日期类为时间类的友元类，则在日期类中就直接访问Time类中的私有成员变量
public:
	Time(int hour = 10, int minute = 10, int second = 10)
		: _hour(hour)
		, _minute(minute)
		, _second(second)
	{}
private:
	int _hour;
	int _minute;
	int _second;
};

class Date
{
public:
	Date(int year = 1900, int month = 1, int day = 1)
		: _year(year)
		, _month(month)
		, _day(day)
	{}

	void SetTimeOfDate(int hour, int minute, int second)
	{
		// 直接访问时间类私有的成员变量
		_t._hour = hour;
		_t._minute = minute;
		_t._second = second;
	}

private:
	int _year;
	int _month;
	int _day;
	Time _t;
};

int main()
{
    return 0;
}
```



# 9.内部类

概念：**如果一个类定义在另一个类的内部，这个内部类就叫做内部类。注意此时这个内部类是一个独立的类，它不属于外部类，更不能通过外部类的对象去调用内**

**部类。外部类对内部类没有任何优越的访问权限。**

注意：内部类就是外部类的友元类。注意友元类的定义，内部类可以通过外部类的对象参数来访问外部类中的所有成员。但是外部类不是内部类的友元。  

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

//内部类
class A
{
private:
	static int k;
	int h;

public:		//类B要是在private里，在类A的外部是不可以实例化的，在类A中可以
	class B
	{
	public:
		void foo(const A& a)
		{
			cout << k << endl;//OK
			cout << a.h << endl;//OK
		}
	};

};
int A::k = 1;

int main()
{

	A::B b;		//类B要是私有的，就不允许在类A的外部实例化，只能在类A中实例化 
	//自己类中不能实例化自己（在类B中实例化类B），报错：不允许使用不完整的类型
	b.foo(A());
}
//输出结果：
//1
//0
```

总结：

1.内部类是外部类的友元类，外部类不是内部类的友元类；

2.内部类可以定义在外部类的public、protected、private都是可以的；（限定了实例化的范围）

3.内部类和友元函数的区别：注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名；

原因：当内部类需要访问外部类的静态成员时，编译器会自动将静态成员翻译成一个全局变量，这样就可以在内部类中直接访问了，而不需要加上作用域解析运算符 `::` 或者外部类名前缀。（这个回答是chatgpt的，感觉不对）

4.sizeof(外部类)=外部类，和内部类没有任何关系；（外部类的大小不包含内部类的大小）

```c++
//外部类的大小不包含内部类的大小
class A
{
private:
	static int k;
	int h;

public:		
	class B
	{
	public:
		int a;
		int b;
		int c;
		void foo(const A& a)
		{
			cout << k << endl;//OK
			cout << a.h << endl;//OK
		}
	};
};
int A::k = 1;

void test10()
{
	cout << sizeof(A) << endl;	//4
	cout << sizeof(A::B) << endl;	//12
}
```

内部类的使用：有些情况需要再次封装，再次封装的内容只需要在这个类中使用，不想在类外使用。

```c++
//不使用乘除法、循环计算1加到n（这个是牛客上的题目）
class Solution
{
public:
    class Sum
    {
        Sum()
        {
            _sum += _i;
            ++_i;
        }
    };
    
    int Sum_Solution(int n)
    {
        //重置
        _sum = 0;
        _i = 1;
        Sum arr[n];
        return _sum;	//返回结果
    }
    
private:
    static int _i;
    static int _sum;
};

int Solution::_i = 1;
int Solution::_sum = 0;
```



# 10.再次理解面向对象和封装

C++是基于面向对象的程序，面向对象有三大特性即：封装、继承、多态。

C++通过类，将一个对象的属性与行为结合在一起，使其更符合人们对于一件事物的认知，将属于该对象的所有东西打包在一起；通过访问限定符选择性的将其部

分功能开放出来与其他对象进行交互，而对于对象内部的一些实现细节，外部用户不需要知道，知道了有些情况下也没用，反而增加了使用或者维护的难度，让

整个事情复杂化。  

比如：火车站中所有工作人员配合起来，才能让大家坐车有条不紊的进行，不需要知道火车的构造，票务系统是如何操作的，只要能正常方便的应用即可。

面向对象是把抽象映射到现实世界。

计算机世界：类实例化对象。

现实世界：主观世界（抽象类别）变为现实世界（实体）	图纸变为房子（图纸是类，房子是实例化的对象）