# 1.入门

## 1.1命名空间：

作用：解决命名冲突的问题，重新定义一个作用域。

定义方式：

方式1：namespace（成员）

方式2：嵌套定义

方式3：同一个命名空间分段定义，编译器自动合并。

使用方式：

方式1：命名空间::成员			推荐使用

方式2：using 命名空间::成员		少用

方式3：using namespace 命名空间		不建议使用，不建议展开命名空间，容易造成命名冲突。



## 1.2函数重载：

函数名相同，参数不同（类型不同、顺序不同、个数不同）。

在同一个作用域下才有函数重载。

c++支持函数重载，c语言不支持函数重载。

原因：底层支持主要在于编译器的编译规则，在底层不同的编译器对函数名命名方式不一样。

函数名修饰规则：

c++：函数名称 + 参数信息

linux：_Z + 函数名字符个数 + 参数类型简写

windows（VS2017）：?@命名空间,类域@函数名 + 参数信息@

c：_ + 函数名



## 1.3缺省参数：

声明或者定义的时候给形参一个默认值。

分类：

1.全缺省：所有形参都给默认值。

2.半缺省：部分形参给默认值，默认值必须从参数右边开始向左连续的赋值。

在声明或者定义的时候赋值，或者声明和定义的时候都赋值，但赋值必须一样，不能在定义和在声明赋的值不一样。



## 1.4引用：

定义：变量的别名或者实体的别名。

语法层面：没有分配空间，在编译器底层占4个或者8个字节的空间，是指针，和指向实体的大小无关。

底层实现：和指针相同。

使用：

1.定义的时候必须初始化。（定义的时候必须指向一个有效的实体，没有空引用）

2.一个变量可以有多个引用。

3.引用实体不能变更。（引用初始化指向一个实体之后不能再修改了）

使用场景：

1.变量别名。

2.函数形参。

3.返回值：返回值的生命周期大于调用函数的生命周期。

和指针的区别：

1.引用定义必须初始化，指针无要求。

2.sizeof：引用是实体大小，指针是指针大小。

3.指针是手动解引用，引用是编译器自动解引用。

4.没有多级引用，但有多级指针。

5.引用没有空引用，但指针有空指针，引用比指针更安全。

6.++引用是++实体，++指针是地址偏移。



## 1.5内敛函数：

inline修饰函数。

调用函数的位置代码原地炸开，减少函数栈帧的开销，提高性能。

不支持分离编译：申明和定义放在一起（一个文件）。

inline对于编译器只是一个建议，编译不一定展开，包括循环、递归、代码较长。（inline适用于短小的代码）



## 1.6c++11：

### 1.6.1auto：类型占位符。

类型名比较长的时候比较方便，但可读性不好，方便开发者，不适用于读者。

作用：类型推导。

auto定义的变量类型根据初始化表达式确定。

auto不能使用的场景：不能定义数组，不能作为函数参数。



### 1.6.2范围for：

for(容器中的变量：要遍历容器的迭代器范围)

前提:

1.范围确定。

2.自定义类型中必须实现的迭代器：begin()、end()、!=、++、解引用。



### 1.6.3空指针nullptr：

nllptr，是一个关键字。

c语言中是NULL，和0一样，具有二义性，整数0或者指针控制。

c++中nullptr是nullptr_t类型。



# 2.类和对象

## 2.1什么是类

自定义类型：把数据和与之相关的定义放在一起的一种类型。（类似结构体）

类的实例化：定义一个类类型的变量，变量称为对象。

封装：类的定义，访问限定符，本质上是一种管理，保护数据，降低耦合，降低使用成本。

## 2.2访问限定符

限制类内部成员在类外的访问权限，在类内部成员的访问不受限定符的限制。

public：类外可以直接访问。

private：类外不能直接访问。

protected：类外不能直接访问，用于继承。

## 2.3类的实例化

定义一个类类型变量的过程。

类本身不占内存，只有实例化的对象才占内存。

可以实例化多个对象。

## 2.4this指针

类类型* const

只存在于成员函数内部，成员函数的第一个形参，一个局部变量。

始终指向当前调用函数的对象。

存放在栈上，如果编译器优化，会存放（eax）寄存器中。

## 2.5对象的大小

对象模型：存放非静态成员变量。（静态成员变量不占空间）

成员函数也不占空间，只有成员变量占空间。

空类大小为1.

遵循内存对齐原则。

## 2.6六大成员函数

### 2.6.1构造函数

在已有的空间上，初始化成员变量。

特点：

1.函数名和类名相同。

2.无返回值。

3.可以重载。

初始化列表：

1.成员变量定义的地方，每个成员变量只能出现一次。

2.必须在列表中初始化的成员：引用、const、自定义类型（没有默认构造函数）

3.会调用自定义成员的默认构造函数。

4.成员变量的初始化顺序和其声明顺序一致，和在初始化列表中的顺序无关，尽量保持初始化顺序和声明顺序一致。

5.静态成员变量不会在初始化列表初始化的，静态成员变量是先于对象存在的，在主程序启动之前静态成员变量就创建好了，必须在类外初始化。

默认构造只能存在一个，包括编译器默认生成的、无参构造、全缺省构造。

### 2.6.2析构函数

完成对象资源的清理，不会销毁对象。

特点：

1.无参。

2.无返回值。

3.不能重载。

4.函数名：~类名。

5.不能重载。

如果有自定义成员，会自动调用自定义成员的析构函数，完成自定义成员的资源清理。

如果没显示写析构函数，编译器会生成一个默认的析构函数，里面啥也不实现，不适用有资源的类。

### 2.6.3拷贝构造

通过已近存在的对象创建一个内容完全相同的对象。

有一个参数，参数为引用类型，不能为传值方式，传值会引发无穷递归。

编译器默认生成的拷贝构造，完成字节拷贝，是浅拷贝，只拷贝对象模型的内容。

### 2.6.4赋值运算符

改变已经存在对象的内容。

返回值为引用，返回值是为了连续赋值。

检查是否给自己赋值。

return *this；

编译器默认生成的完成浅拷贝。

### 2.6.5取地址运算符

一般使用编译器自动生成的默认的，除非有特定的操作需要自己显示定义实现。

return this;

### 2.6.6const取地址运算符

return this;

一般使用编译器自动生成的默认的，除非有特定的操作需要自己显示定义实现。

## 2.7const

const修饰的成员函数（放在函数的后面），本质上const修饰的是this指针指向的内容，const成员函数不能修改对象的内容。

const成员函数（this指针指向和内容都不能修改）不能调用非const成员函数。

非const成员函数可以调用任何成员函数。

const对象不能调用非const成员函数。

非const对象可以调用所有的成员函数。

总结：权限可以缩小，但不能放大。

## 2.8static

静态成员变量：

类中的所有对象共享，可以看做类成员，全局只有一份。

存放在静态数据区。

访问方式：

1.类名::成员

2.对象访问：.或者->

必须在类外定义（初始化）。

静态成员函数：

没有this指针。

访问方式：

1.类名::函数。

2.对象访问：.或者->

不能调用非静态成员函数。

非静态成员函数（含有this指针）可以调用静态成员函数。

## 2.9友元

### 2.9.1友元函数

类内声明（friend + 函数声明），类外定义。

可以访问类内部的所有成员。

一定程度上破坏封装，一般不要用。

<<和>>一般会定义为友元函数的，如果定义成成员函数，this指针会占用第一个参数位置，使用：对象 <<  cout，对象 >> cin，操作参数位置颠倒，故定义为友元函数，用cout << 对象，cin >> 对象。

### 2.9.2友元类

类的所有成员函数都为声明为友元类的函数的友元函数。

友元关系是单向的。

友元关系不能传递。

访问成员：通过对象访问。

内部类：

1.具有友元类的所有特性。

2.可以直接访问外部类的static成员和枚举成员。

3.不从属于外部类，是一个独立的类。

# 3.内存管理

## 3.1内存分布

1.内核

2.栈：局部变量

3.堆：动态开辟

4.数据段：全局变量和静态数据

5.代码段：文字常量和可执行代码（机器码、二进制代码）

## 3.2c内存管理

1.malloc：只开辟内存

2.calloc：开辟内存 + 初始化为0（按字节初始化）

3.realloc（void*，size_t n）：调整空间。

3.1如果需要增容：如果后续空间足够，修改底层标记，向后拼接；如果后续空间不够，重新申请更大的空间，拷贝原有空间的内容，释放原有空间。

3.2如果减小容量：修改底层标记，释放多余空间。

3.3realloc如果第一个参数为空指针，则功能类似于malloc

3.4传入realloc的指针指向的空间，不需要显示释放。

## 3.3c++管理内存

1.new：

内置类型：operator new -> malloc

自定义类型：operator new -> malloc -> 构造

2.new[]

调用operator new[]，其内部调用operator new，对于自定义类型，在调用N次构造。

3.delete

内置类型：operator delete -> free

自定义类型：析构 -> operator delete -> free

4.delete[]

对于自定义类型，首先要调用N次析构，再调用operator delete[]，其内部调用operator delete。



operator new 就是 malloc + 异常。

operator失败抛异常，malloc失败返回NULL。



operator new / operator delete通过重载，定制资源申请和释放的方式。



new定位表达式：new（指针）构造（参数）。

new定位表达式显示调用构造函数，实现空间内容的初始化。

# 4.模板

## 4.1函数模板

实例化：显示实例化和隐式实例化（编译器根据参数自动做类型推演）

非模板函数和模板函数的匹配规则：

1.如果参数类型完全匹配非模板函数，直接调用，不用进行模板函数的实例化。

2.如果参数类型不完全匹配非模板函数，如果可以通过模板函数的实例化生成一个更匹配的函数， 则进行实例化过程。

3.如果指定要显示实例化，一定会进行实例化过程。

特化：当基础模板不能正确处理特定类型的数据时，则可以对特定类型实现一个特化版本。

如果特化版本实现比较复杂，或者出现复杂的编译错误，再直接定义一个对应类型的普通函数。（推荐使用普通函数，不推荐使用特化的函数模板）

## 4.2类模板

实例化：必须显示实例化。（没有隐式实例化）

特化：全特化（类型全部赋值）和偏特化（部分类型赋值）。

偏特化分为部分特化和对模板参数做进一步限制T -> T& 或者 T*......



非类型模板参数：

1.一个具体类型的参数，可以当做常量使用。

2.不能作为非类型模板参数的类型：浮点、字符串常量和自定义类型。

# 5.STL

## 5.1string

管理字符顺序表。

### 5.1.1接口

1.resize：改变有效字符的数量。

当 n > _capacity时，增容。

n > _size时，_size ~ n之间进行赋值，通过接口的参数赋值，或者初始化一个默认值：'\0'。



2.reserve：修改容量，不影响size。

既可以增容，也可以减小容量。

增容规则：初始大小为15byte，按1.5倍或者2倍增容。



3.insert：插入元素

尾插时间复杂度为O(1)，其他地方为O(N)。

元素搬移：从后向前搬移，防止数据覆盖。



4.erase：删除元素

尾删时间复杂度为O(1)，其他地方为O(N)。

元素搬移：从前向后搬移，防止数据覆盖。



5.find查找元素

如果没有找到，返回npos（无符号整数的最大值）static size_t npos = -1



6.+=运算符重载

+= char

+= char*

+= string对象

### 5.1.2访问

operator[] ：可读可写，返回值为引用。

迭代器：可读可写，原生指针：char*。

范围for：通过迭代器的方式访问元素，可读可写。

### 5.1.3拷贝

浅拷贝；字节拷贝，只拷贝对象的内容，不拷贝资源。

深拷贝：即拷贝对象的内容，也拷贝资源。

写实拷贝：浅拷贝 + 引用计数。

### 5.1.4成员函数

拷贝构造：现代写法：

1.在初始化列表中初始化成员；

2.函数内部调用构造函数，创造一个临时对象；

3.调用swap函数，和临时对象交换成员。



赋值运算符重载：现代写法

1.参数构造，通过调用拷贝构造创建一个临时对象；

2.调用swap函数，和临时对象交换成员。

## 5.2vector<>

vector<T>

管理各种类型数据的顺序表

### 5.2.1迭代器失效

插入：当插入发生增容的时候，会引起迭代器实现，增容导致需要开辟新的空间，拷贝原有内容，释放原有空间，迭代器指向的原有空间无法实现。

resize、revserve会导致迭代器失效

删除：删除可能会导致迭代器访问越界，获取删除接口的返回值，指向被删除元素的下一个位置。

解决办法：迭代器失效后重新获取迭代器。

### 5.2.2实现

三个指针：

_start 

_finish

_endOfstorage

size：_finish - _start

capacity：_endOfstorage - _start

### 5.2.3迭代器

begin()：return _start

end()：return _end;

T*

## 5.3list<>

list<T>

带头双向循环链表

### 5.3.1迭代器

iterator<T,Ref,Ptr>

iterator<T,T*,T&>

iterator<T,const T*,const T&>

非原生指针，通过封装节点实现迭代器。

++ --

前置++：

Self& operator++()

{

​	node = node->_next;

​	return *this;

}



后置++：

Self operator++(int)

{

​	Self tmp(*this);

​	node = node->_next;

​	return tmp;

}



前置--：

Self& operator++()

{

​	node = node->_prev;

​	return *this;

}



后置--：

Self operator--(int)

{

​	Self tmp(*this);

​	node = node->_prev;

​	return tmp;

}



成员访问：

解引用*：可读可写

T& operator*()

{

​	return node._data;

}



->：可读可写

T* operator->()

{

​	return &node._data;

}



T* operator->()

{

​	return &operator*();

}



== !=

bool operator==(const Self& lst)

{

​	return node = lst.node;

}



bool operator!=(const Self& lst)

{

​	return node != lst.node;

}



begin：iterator(_header->_next);

end:：iterator(_header);



迭代器失效：

删除的时候导致当前迭代器指向的节点失效。

获取删除接口的返回值，返回值指向下一个节点的位置。



### 5.3.2vector和list的区别联系

vector连续结构，list非连续结构。

vector支持随机访问，list不支持随机访问。

vector迭代器原生指针，list迭代器非原生指针，封装节点。

vector在插入和删除可能导致迭代器失效，list在 删除的时候导致当前迭代器指向的节点失效。

vector不容易造成内存碎片，空间利用率高，list容易造成内存碎片，空间利用率低。

vector在非尾部插入、删除的时间复杂度是O(N)，list在任何地方插入和删除的时间复杂度是O(1)。

vector在关注随机访问效率，不频繁进行插入和删除时使用，list则相反。	



## 5.4deque<>

deque<T>

指针数组（中控） + buffer（缓冲区）：本质为二维数组，空间不连续，逻辑上连续的线性表。

### 5.4.1中控

指针元素：T** map

元素从中间位置开始存放。

### 5.4.2buffer（缓冲区）

每一个buffer长度相同。

### 5.4.3增容

buffer：如果当前buffer已满，开一个新的buffer，新加入的元素存放在新的buffer中，不会进行原有buffer的释放。

中控：开辟一个更大的空间，拷贝原有指针，释放原有的中控空间。

增容代价小，不会引起数据的拷贝。

### 5.4.4迭代器

非原生指针。

start：

T* first：指向第一个buffer的起始位置。

T* last：指向第一个buffer的末尾位置。

T* cur：指向第一个buffer第一个元素的位置。

T** node：指向第一个buffer的首地址在中控中的存储位置。



finish：

T* first：指向最后一个buffer的起始位置。

T* last：指向最后一个buffer的末尾位置。

T* cur：指向最后一个buffer的最后一个元素的下一个位置。

T** node：指向最后一个buffer的首地址在中控中的存储位置。

### 5.4.5特点

vector和list的综合体，具有vector和list的部分优势。

支持随机访问，访问效率相对于vector略低。

不容易造成内存碎片，空间利用率高。

头尾插入和删除的时间复杂度都为O(1)。

增容代价小。

## 5.5容器适配器

适配器：是一种设计模式，本质上为一种转换，对已有容器进行封装，使其转换成另一种容器。

### 5.5.1stack

stack<T>

FILO：后进先出

底层结构：deque、vector、list

默认：deque（增容代价小，故不选vector，不容易造成内存碎片，故不选list）

底层结构需要实现的接口：push_back、pop_back、back、size、empty。

### 5.5.2queue

queue<T>

FIFO：先进先出

底层结构：deque、list（vector不提供pop_front，故不行）

默认：deque（不容易造成内存碎片，故不选list）

底层结构需要实现的接口：empty、size、back、front、push_back、pop_front。

### 5.5.3priority_queue

priority_queue<T>

按照指定比较规则插入元素、删除元素，每次操作需要满足最大堆或者最小堆的性质。

底层结构：vector、deque（list不能随机访问，故不行）

默认：vector（随机访问效率比deque高）

底层结构需要实现的接口：push_back（push_back + 向上调整）、pop_back（交换第一个元素和最后一个元素 + pop_back + 向下调整）、front、size、empty。

## 5.6迭代器

实现和指针相同的操作，是一种访问机制。

原生迭代器：string；char*		vector：T*

非原生迭代器：通过封装，实现类似指针的相关操作。		list：class iterator{private:node}

正向迭代器：begin()：指向第一个元素的位置	end()：指向最后一个元素的下一个位置

反向迭代器：rbegin()：指向最后一个元素的位置	rend()：指向第一个元素的前一个位置

const迭代器：begin() const、end() const、rbegin const()、rend const()、cbegin()、cend()、crbegin()、crend()。

## 5.7仿函数对象

重载括号"()"运算符的类所实例化的对象。

可以看做一个函数去使用，本质是调用成员函数。（返回值 operator(参数)）

结合一些特有的场景，比如排序、比较，完成相应的排序，比较规则。

## 5.8空间配置器

## 5.9算法

查找	搜索	其他

# 6.IO

## 6.1标准IO

### 6.1.1istream

cin

对于内置类型，c++对于内置类型已经重载了 >> 运算符，可以直接使用，cin >> 内置类型。

对于自定义类型，需要开发人员自己重载 >> 运算符。

### 6.1.2ostream

cout、cerr、clog

对于内置类型，c++对于内置类型已经重载了 << 运算符，可以直接使用，clog << 内置类型 和 cout << 内置类型 和 cerr << 内置类型。

对于自定义类型，需要开发人员自己重载 << 运算符。

## 6.2文件IO

### 6.2.1ifstream

二进制读：

按内存/磁盘中的存放形式（二进制）读入，按字节读入，字符流读入。

接口：read。

文本读：

按二进制编码之后的字符读入，按字符读入，字符流读入。

接口：>>，get，getline。

### 6.2.2ofstream

二进制写：

按内存/磁盘中的存放形式（二进制）写入，按字节写入，字符流写入。

接口：write。 

文本写：

按二进制编码之后的字符写入，按字符写入，字符流写入。

接口：<<，put。

## 6.3stringstream

把非字符串类型数据转成字符串。

底层维护一个string对象。

多次转换处理之间，需要调用clear函数清空状态位，否则转换会有问题。

str接口：

无参：返回内部的string对象副本。

带参：设置内部string对象的内容。
