# 1.二叉搜索树

## 1.1二叉搜索树的概念

在传统的二叉搜索树（Binary Search Tree，BST）中，通常是不允许存放重复的值的。BST 是一种有序的二叉树结构，其中每个节点的值大于其左子树的所有节

点的值，并且小于其右子树的所有节点的值。这样的定义使得 BST 是一个有效的数据结构，用于快速查找、插入和删除操作。

由于 BST 的特性，当插入一个新节点时，如果该节点的值与已存在的节点的值相同，那么既无法满足左子树的条件，也无法满足右子树的条件。因此，在传统的 

BST 中，不允许存放重复的值。

然而，可以对 BST 进行扩展来允许存放重复的值。这种扩展称为多重集二叉搜索树（Multiset Binary Search Tree），它是在传统 BST 的基础上修改而来的，允

许每个节点存储多个相同的值。在多重集 BST 中，相同值的节点会按照特定规则进行存储和排序。

需要注意的是，多重集 BST 并非标准的数据结构，它并没有在常见编程库中广泛实现。如果需要存放重复的值，你可能需要使用其他数据结构或自定义 BST 的变

体来实现。



二叉搜索树又称二叉排序树，它或者是一棵空树，或者是具有以下性质的二叉树:

1若它的左子树不为空，则左子树上所有节点的值都小于根节点的值；

2若它的右子树不为空，则右子树上所有节点的值都大于根节点的值；

3它的左右子树也分别为二叉搜索树。

![image-20230713091307102](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230713091307102.png)

中序遍历二叉搜索树是有序的。

## 1.2二叉搜索树的操作

1.二叉搜索树的查找

若根节点不为nullptr：

​	如果根节点的key  ==  查找的key，返回true；（key唯一，不重复）

​	如果根节点的key  > 	查找的key，在根节点的左子树查找；

​	如果根节点的key  < 	查找的key，在根节点的右子树查找。

如果查找完整个树，找不到返回false。

```c++
//二叉搜索树的查找
	Node* find(const T& val)
	{
		Node* cur = _root;
		while (cur)
		{
			//每一的查找类似于二分查找的操作，平均时间复杂度是O(h)，h是树的高度。
			//最差是树像链表一样，是一条直线，最差的时间复杂度是O(n)，n是树的节点个数，树的也是高度。
			if (cur->_data == val)
				return cur;
			else if (cur->_data > val)
				cur = cur->_left;
			else
				cur = cur->_right;
		}
		return nullptr;		//表示没找到
	}
```



2.二叉搜索树的插入

插入的具体操作：

​	如果树为空，节点直接插入，作为根节点；

​	如果树不为空，按照二叉搜索树的性质查找插入位置，插入新节点；

二叉搜索树的性质：根节点的左子树所有节点的值都小于根节点的值，根节点的右子树所有节点的值都大于根节点的值。



插入操作编码的实现步骤：

​	如果二叉搜索树为空直接插入，插入的节点作为根节点；

​	按照二叉搜索树的性质查找要入位置；（位置一定是叶子节点）（记录插入位置的双亲节点，方便插入）（如果元素已经存在，直接返回false，表示插入失败）

​	插入元素。

```c++
//二叉搜索树节点的插入：不插入重复的值，插入重复的值会失败
//二叉搜索树一般不存放重复的值
	bool insert(const T& val)
	{
		if (_root == nullptr)
		{
			//空树
			_root = new Node(val);
			return true;
		} 
		
		//剩下的元素插入不是空树的时候要进行搜索，保证不是重复的数据
		//新插入的元素一般是叶子节点：避免树的节点的连接
		//插入的平均时间复杂度是O(n)，取决于搜索（查找）的性能
		Node* cur = _root;
		Node* parent = nullptr;
		while (cur)
		{
			//搜索：要记录父亲的节点，之后要插入
			parent = cur;
			if (cur->_data == val)
				return false;	//插入失败
			else if (cur->_data > val)
				cur = cur->_left;
			else
				cur = cur->_right;
		}

		//插入
		if (parent->_data > val)
			parent->_left = new Node(val);
		else
			parent->_right = new Node(val);

		return true;		//插入成功
	}
```



3.二叉搜索树的删除

删除的具体操作：

​	首先查找要删除的节点在二叉搜索树中是否存在，不存在返回false，存在按以下四种情况分析：

​		要删除的节点是叶子节点，没有孩子节点；

​		要删除的节点只有左孩子节点；

​		要删除的节点只有右孩子节点；

​		要删除的节点左右孩子节点都存在。

要删除的情况看起来有四种，实际写代码的时候可以把第一种放到第二种或者第三种中，可以不写第一种，第二种或者第三种直接包括了第一种。

实际的删除过程：

​	情况1：要删除的节点只有左孩子节点：查找到要删除的节点，使要删除的节点的双亲节点的左边指向要删除节点的左子树；

​	情况2：要删除的节点只有右孩子节点：查找到要删除的节点，使要删除的节点的双亲节点的右边指向要删除节点的右子树；

​	情况3：要删除的节点的左右孩子节点都存在：

​		找到左子树中的最大的节点，就是左子树最右边的节点，或者找到右子树中的最小的节点，就是右子树最左边的节点；

​		找到之后与要删除的节点交换值，将删除的节点的**位置**变为删除左子树最大的节点的位置或者删除右子树最小的节点的位置；（直接删除不好删除，就找到要

删除节点的替换节点，这样就不用重写连接了）

​	如果树为空，则删除失败。



删除操作编码的实现步骤：

​	如果二叉搜索树为空，，直接返回false，表示删除失败；

​	查找要删除节点在树中的位置；

​	要删除的节点不在二叉搜索树中，无法删除，返回false，表示删除失败；

​	分三种情况进行删除：

​		要删除的节点只有左子树，直接删除；

​		要删除的节点只有右子树，直接删除；

​		要删除的节点左右子树都存在，直接删除不好删除，找一个替换的节点进行删除，避免直接删除之后的复杂连接问题，替换节点为左子树的最大节点，就是左

子树最右边的节点，或者右子树的最小节点，就是右子树最左边的节点，将要删除的节点和替换节点的值进行交换，将问题变为删除替换节点位置的节点，避免二

叉搜索树复杂的连接问题。

```c++
	//二叉搜索树节点的删除
	bool erase(const T& val)
	{
		//查找
		Node* cur = _root;
		Node* parent = nullptr;
		while (cur)
		{
			if (cur->_data == val)	//找到了
				break;
			parent = cur;		//更新父亲节点的位置，方便之后删除操作
			if (cur->_data > val)
				cur = cur->_left;
			else
				cur = cur->_right;
		}

		//判断需要删除的节点是否找到了
		if (cur == nullptr)
			return false;

		//删除
		//1.删除的是叶子节点
		if (cur->_left == nullptr && cur->_right == nullptr)
		{
			//1.1特殊情况：删除的是叶子节点且是根节点
			if (cur == _root)
				_root = nullptr;
			else
			{
				//1.2一般情况：删除的是叶子节点，但不是根节点
				//判断删除的节点在父亲节点的哪一边
				if (parent->_left == cur)
					parent->_left = nullptr;
				else
					parent->_right = nullptr;
			}

			//删除节点
			delete cur;
		}
		//2.删除的是非叶子节点且要删除的节点的左边为空
		else if (cur->_left == nullptr)
		{
			//第一种情况可以归到第二种或者第三种，因为连接是nullptr（可以理解为是特例）。
			//2.1删除的是非叶子节点且是删除的节点是根节点
			if (cur == _root)
				_root = cur->_right;
			else
			{
				//2.2删除的是非叶子节点，但删除的节点不是根节点
				if (parent->_left == cur)
					parent->_left = cur->_right;
				else
					parent->_right = cur->_right;
			} 

			//删除节点
			delete cur;
		}
		//3.删除的是非叶子节点且要删除的节点的右边为空
		else if (cur->_right == nullptr)
		{
			//3.1删除的是非叶子节点且是删除的节点是根节点
			if (cur == _root)
				_root = cur->_left;
			else
			{
				//3.2删除的是非叶子节点，但删除的节点不是根节点
				if (parent->_left == cur)
					parent->_left = cur->_left;
				else
					parent->_right = cur->_left;
			}

			//删除节点
			delete cur;
		}
		//4.删除的是叶子节点且左右子树都存在
		else
		{
			//4.1假设找左子树的最右节点
			Node* leftRigthMost = cur->_left;
			parent = cur;

			//找到左子树最右边的叶子节点
			while (leftRigthMost->_right)
			{
				parent = leftRigthMost;
				leftRigthMost = leftRigthMost->_right;
			}

			//交换左子树最右边的叶子节点的值和要删除节点的值
			swap(leftRigthMost->_data, cur->_data);

			//删除左子树最右节点
			if (parent->_right == leftRigthMost)
				//一直遍历到左子树的最右节点
				parent->_right = leftRigthMost->_left;
			else
				//leftRigthMost右边刚开始就是一个空树
				parent->_left = leftRigthMost->_left;
			//举例：//leftRigthMost右边刚开始就是一个空树
			//						5
			//				4
			//		2
			//	1		3
			//要删除的节点是5，leftRigthMost是4，4的右边没有节点
			//交换节点4和节点5的值
			//						4
			//				5
			//		2
			//	1		3
			//4的左边连接2，最后删除5
			//				4
			//		2
			//	1		3
			delete leftRigthMost;	
		}

		return true;
	}
```



## 1.3二叉搜索树的实现

```c++
#include <iostream>
#include <string>
#include <time.h>		

using namespace std;

//二叉搜索树的节点
template <class T>
struct BNode
{
	BNode(const T& data)
		:_data(data)
		,_left(nullptr)
		,_right(nullptr)
	{}

	T _data;
	typedef BNode<T> Node;
	Node* _left;
	Node* _right;
};

//二叉搜索树：传统的二叉搜索树一般不存放重复的值，每个值都是唯一的
template <class T>
class BTree
{
public:
	typedef BNode<T> Node;

	//构造函数：创建空树
	BTree()
		:_root(nullptr)
	{}

	//二叉搜索树的查找
	Node* find(const T& val)
	{
		Node* cur = _root;
		while (cur)
		{
			//每一的查找类似于二分查找的操作，平均时间复杂度是O(h)，h是树的高度。
			//最差是树像链表一样，是一条直线，最差的时间复杂度是O(n)，n是树的节点个数，树的也是高度。
			if (cur->_data == val)
				return cur;
			else if (cur->_data > val)
				cur = cur->_left;
			else
				cur = cur->_right;
		}
		return nullptr;		//表示没找到
	}

	//二叉搜索树节点的插入：不插入重复的值，插入重复的值会失败
	//二叉搜索树一般不存放重复的值
	bool insert(const T& val)
	{
		if (_root == nullptr)
		{
			//空树
			_root = new Node(val);
			return true;
		} 
		
		//剩下的元素插入不是空树的时候要进行搜索，保证不是重复的数据
		//新插入的元素一般是叶子节点：避免树的节点的连接
		//插入的平均时间复杂度是O(n)，取决于搜索（查找）的性能
		Node* cur = _root;
		Node* parent = nullptr;
		while (cur)
		{
			//搜索：要记录父亲的节点，之后要插入
			parent = cur;
			if (cur->_data == val)
				return false;	//插入失败
			else if (cur->_data > val)
				cur = cur->_left;
			else
				cur = cur->_right;
		}

		//插入
		if (parent->_data > val)
			parent->_left = new Node(val);
		else
			parent->_right = new Node(val);

		/*
		cur = new Node(val);
		if (parent->_data > val)
			parent->_left = cur;
		else
			parent->_right = cur;
		*/

		return true;		//插入成功
	}

	//中序遍历
	void inorder()
	{
		_inorder(_root);
	}

	void _inorder(Node* root)
	{
		if (root)
		{
			_inorder(root->_left);
			cout << root->_data << " ";
			_inorder(root->_right);
		}
	}

	//拷贝二叉搜索树的数据和结构
	Node* copy(Node* root)
	{
		if (root == nullptr)
			return root;

		Node* newNode = new Node(root->_data);
		newNode->_left = copy(root->_left);
		newNode->_right = copy(root->_right);
		//newNode->_left = new Node(root->_left->_data);
		//newNode->_right = new Node(root->_right->_data);
		return newNode;	
	}

	//拷贝构造
	BTree(const BTree<T>& btree)
		:_root(copy(btree._root))
	{
		//_root = copy(btree._root);
	}

	//销毁树
	void destory(Node* root)
	{
		if (root)
		{
			destory(root->_left);
			destory(root->_right);
			cout << "destory：" << root->_data << endl;	//放在delete前面防止访问的是野指针
			delete root;
			//root = nullptr;
		}
	}

	//析构函数
	~BTree()
	{
		if (_root)
		{
			destory(_root);
			_root = nullptr;
		}
	}

	//二叉搜索树节点的删除
	bool erase(const T& val)
	{
		//查找
		Node* cur = _root;
		Node* parent = nullptr;
		while (cur)
		{
			if (cur->_data == val)	//找到了
				break;
			parent = cur;		//更新父亲节点的位置，方便之后删除操作
			if (cur->_data > val)
				cur = cur->_left;
			else
				cur = cur->_right;
		}

		//判断需要删除的节点是否找到了
		if (cur == nullptr)
			return false;

		//删除
		//1.删除的是叶子节点
		if (cur->_left == nullptr && cur->_right == nullptr)
		{
			//1.1特殊情况：删除的是叶子节点且是根节点
			if (cur == _root)
				_root = nullptr;
			else
			{
				//1.2一般情况：删除的是叶子节点，但不是根节点
				//判断删除的节点在父亲节点的哪一边
				if (parent->_left == cur)
					parent->_left = nullptr;
				else
					parent->_right = nullptr;
			}

			//删除节点
			delete cur;
		}
		//2.删除的是非叶子节点且要删除的节点的左边为空
		else if (cur->_left == nullptr)
		{
			//第一种情况可以归到第二种或者第三种，因为连接是nullptr（可以理解为是特例）。
			//2.1删除的是非叶子节点且是删除的节点是根节点
			if (cur == _root)
				_root = cur->_right;
			else
			{
				//2.2删除的是非叶子节点，但删除的节点不是根节点
				if (parent->_left == cur)
					parent->_left = cur->_right;
				else
					parent->_right = cur->_right;
			} 

			//删除节点
			delete cur;
		}
		//3.删除的是非叶子节点且要删除的节点的右边为空
		else if (cur->_right == nullptr)
		{
			//3.1删除的是非叶子节点且是删除的节点是根节点
			if (cur == _root)
				_root = cur->_left;
			else
			{
				//3.2删除的是非叶子节点，但删除的节点不是根节点
				if (parent->_left == cur)
					parent->_left = cur->_left;
				else
					parent->_right = cur->_left;
			}

			//删除节点
			delete cur;
		}
		//4.删除的是叶子节点且左右子树都存在
		else
		{
			//4.1假设找左子树的最右节点
			Node* leftRigthMost = cur->_left;
			parent = cur;

			//找到左子树最右边的叶子节点
			while (leftRigthMost->_right)
			{
				parent = leftRigthMost;
				leftRigthMost = leftRigthMost->_right;
			}

			//交换左子树最右边的叶子节点的值和要删除节点的值
			swap(leftRigthMost->_data, cur->_data);

			//删除左子树最右节点
			if (parent->_right == leftRigthMost)
				//一直遍历到左子树的最右节点
				parent->_right = leftRigthMost->_left;
			else
				//leftRigthMost右边刚开始就是一个空树
				parent->_left = leftRigthMost->_left;
			//举例：//leftRigthMost右边刚开始就是一个空树
			//						5
			//				4
			//		2
			//	1		3
			//要删除的节点是5，leftRigthMost是4，4的右边没有节点
			//交换节点4和节点5的值
			//						4
			//				5
			//		2
			//	1		3
			//4的左边连接2，最后删除5
			//				4
			//		2
			//	1		3
			delete leftRigthMost;	
		}

		return true;
	}

//private:	//一般要将数据成员写成private，这里为了方便演示，也可以加上一个获取函数
	Node* _root;		//根节点
};

//二叉搜索树的中序遍历是有序的
//中序遍历：左 根 右 
void inorderTraversal(BNode<int>* root) 
{
	if (root == NULL)
		return;

	inorderTraversal(root->_left);
	cout << root->_data << " ";
	inorderTraversal(root->_right);
}

//插入，中序遍历输出
void test1()
{
	BTree<int> b;
	b.insert(50);
	b.insert(90);
	b.insert(30);
	b.insert(20);
	b.insert(80);
	b.insert(40);
	b.insert(70);
	b.insert(5);
	b.insert(500);

	inorderTraversal(b._root);
	cout << endl;
	
	b.inorder();
	cout << endl;
	
	b._inorder(b._root);
	printf("\n");
	//输出：
	//5 20 30 40 50 70 80 90 500
	//5 20 30 40 50 70 80 90 500
	//5 20 30 40 50 70 80 90 500
}

//随机数插入，中序遍历输出
void test2()
{
	BTree<int> b;
	srand(time(nullptr));	//随机数种子
	int num;
	cin >> num;
	for (int i = 0; i < num; ++i)
	{
		b.insert(rand());
	}

	b.inorder();
	cout << endl;
	BTree<int> copy(b);
	copy.inorder();
	cout << endl;
}

//测试删除操作
void test3()
{
	BTree<int> b;
	b.insert(50);
	b.insert(90);
	b.insert(30);
	b.insert(20);
	b.insert(80);
	b.insert(40);
	b.insert(70);
	b.insert(5);
	b.insert(500);

	inorderTraversal(b._root);
	printf("\n");
	b.erase(10);
	b.erase(30);
	b.erase(80);
	b.erase(40);
	b.erase(500);
	inorderTraversal(b._root);
	cout << endl;
	//输出：
	//5 20 30 40 50 70 80 90 500
	//5 20 50 70 90
	//destory：5
	//destory：20
	//destory：70
	//destory：90
	//destory：50
}

int main()
{
	//test1();
	//test2();
	test3();
	return 0;
}
```



## 1.4二叉搜索树的应用

1.K模型：K模型即只有key作为关键码，结构中只需要存储Key即可，关键码即为需要搜索到的值。比如：给一个单词word，判断该单词是否拼写正确，具体方式

如下：

以单词集合中的每个单词作为key，构建一棵二叉搜索树;

在二叉搜索树中检索该单词是否存在，存在则拼写正确，不存在则拼写错误。

2.KV模型：每一个关键码key，都有与之对应的值Value，即<Key, Value>的键值对。该种方式在现实生中非常常见：比如英汉词典就是英文与中文的对应关系，通

过英文可以快速找到与其对应的中文，英文单词与其对应的中文<word, chinese>就构成一种键值对；再比如统计单词次数，统计成功后，给定单词就可快速找到

其出现的次数，单词与其出现次数就是<word, count>就构成一种键值对。

比如：实现一个简单的英汉词典dict，可以通过英文找到与其对应的中文，具体实现方式如下：

<单词，中文含义>为键值对构造二叉搜索树，注意：二叉搜索树需要比较，键值对比较时只比较Key查询英文单词时，只需给出英文单词，就可快速找到与其对应

的key。

```c++
#include <iostream>
#include <string>
#include <time.h>

using namespace std;

//二叉搜索树的节点
template <class K,class V>
//template <class T>
struct BNode
{
	//BNode(const T& data)
	BNode(const K& key,const V& value)
		//:_data(data)
		:_key(key)
		,_value(value)		//K,V构成的一个数据对
		, _left(nullptr)
		, _right(nullptr)
	{}

	K _key;		//类似于索引，可以是任何类型，不一定是个整数     
	V _value;	//类似于data
	typedef BNode<K, V> Node;
	//T _data; 
	//typedef BNode<T> Node;
	Node* _left;
	Node* _right;
};

//二叉搜索树：传统的二叉搜索树一般不存放重复的值，每个值都是唯一的
//template <class T>
template <class K,class V>
class BTree
{
public:
	//typedef BNode<T> Node;
	typedef BNode<K,V> Node;

	//构造函数：创建空树
	BTree()
		:_root(nullptr)
	{}

	//二叉搜索树的查找
	//Node* find(const T& val)
	Node* find(const K& key)
	{
		Node* cur = _root;
		while (cur)
		{
			//每一的查找类似于二分查找的操作，平均时间复杂度是O(h)，h是树的高度。
			//最差是树像链表一样，是一条直线，最差的时间复杂度是O(n)，n是树的节点个数，树的也是高度。
			if (cur->_key == key)
				return cur;
			else if (cur->_key > key)
				cur = cur->_left;
			else
				cur = cur->_right;
		}
		return nullptr;		//表示没找到
	}

	//二叉搜索树节点的插入：不插入重复的值，插入重复的值会失败
	//二叉搜索树一般不存放重复的值
	bool insert(const K& key,const V& value)
	{
		if (_root == nullptr)
		{
			//空树
			_root = new Node(key,value);
			return true;
		}

		//剩下的元素插入不是空树的时候要进行搜索，保证不是重复的数据
		//新插入的元素一般是叶子节点：避免树的节点的连接
		//插入的平均时间复杂度是O(n)，取决于搜索（查找）的性能
		Node* cur = _root;
		Node* parent = nullptr;
		while (cur)
		{
			//搜索：要记录父亲的节点，之后要插入
			parent = cur;
			if (cur->_key == key)
				return false;	//插入失败
			else if (cur->_key > key)
				cur = cur->_left;
			else
				cur = cur->_right;
		}

		//插入
		if (parent->_key > key)
			parent->_left = new Node(key,value);
		else
			parent->_right = new Node(key,value);

		return true;		//插入成功
	}

	//中序遍历
	void inorder()
	{
		_inorder(_root);
	}

	void _inorder(Node* root)
	{
		if (root)
		{
			_inorder(root->_left);
			cout << root->_key << "->" << root->_value << " ";
			_inorder(root->_right);
		}
	}

	//拷贝二叉搜索树的数据和结构
	Node* copy(Node* root)
	{
		if (root == nullptr)
			return root;

		Node* newNode = new Node(root->_key,root->_value);
		newNode->_left = copy(root->_left);
		newNode->_right = copy(root->_right);
		//newNode->_left = new Node(root->_left->_data);
		//newNode->_right = new Node(root->_right->_data);
		return newNode;
	}

	//拷贝构造
	BTree(const BTree<K,V>& btree)
		:_root(copy(btree._root))
	{
		//_root = copy(btree._root);
	}

	//销毁树
	void destory(Node* root)
	{
		if (root)
		{
			destory(root->_left);
			destory(root->_right);
			cout << "destory：" << root->_key << "->" << root->_value << endl;	//放在delete前面防止访问的是野指针
			delete root;
			//root = nullptr;
		}
	}

	//析构函数
	~BTree()
	{
		if (_root)
		{
			destory(_root);
			_root = nullptr;
		}
	}

	//二叉搜索树节点的删除
	bool erase(const K& key)
	{
		//查找
		Node* cur = _root;
		Node* parent = nullptr;
		while (cur)
		{
			if (cur->_key == key)	//找到了
				break;
			parent = cur;		//更新父亲节点的位置，方便之后删除操作
			if (cur->_key > key)
				cur = cur->_left;
			else
				cur = cur->_right;
		}

		//判断需要删除的节点是否找到了
		if (cur == nullptr)
			return false;

		//删除
		//1.删除的是叶子节点
		if (cur->_left == nullptr && cur->_right == nullptr)
		{
			//1.1特殊情况：删除的是叶子节点且是根节点
			if (cur == _root)
				_root = nullptr;
			else
			{
				//1.2一般情况：删除的是叶子节点，但不是根节点
				//判断删除的节点在父亲节点的哪一边
				if (parent->_left == cur)
					parent->_left = nullptr;
				else
					parent->_right = nullptr;
			}

			//删除节点
			delete cur;
		}
		//2.删除的是非叶子节点且要删除的节点的左边为空
		else if (cur->_left == nullptr)
		{
			//第一种情况可以归到第二种或者第三种，因为连接是nullptr（可以理解为是特例）。
			//2.1删除的是非叶子节点且是删除的节点是根节点
			if (cur == _root)
				_root = cur->_right;
			else
			{
				//2.2删除的是非叶子节点，但删除的节点不是根节点
				if (parent->_left == cur)
					parent->_left = cur->_right;
				else
					parent->_right = cur->_right;
			}

			//删除节点
			delete cur;
		}
		//3.删除的是非叶子节点且要删除的节点的右边为空
		else if (cur->_right == nullptr)
		{
			//3.1删除的是非叶子节点且是删除的节点是根节点
			if (cur == _root)
				_root = cur->_left;
			else
			{
				//3.2删除的是非叶子节点，但删除的节点不是根节点
				if (parent->_left == cur)
					parent->_left = cur->_left;
				else
					parent->_right = cur->_left;
			}

			//删除节点
			delete cur;
		}
		//4.删除的是叶子节点且左右子树都存在
		else
		{
			//4.1假设找左子树的最右节点
			Node* leftRigthMost = cur->_left;
			parent = cur;

			//找到左子树最右边的叶子节点
			while (leftRigthMost->_right)
			{
				parent = leftRigthMost;
				leftRigthMost = leftRigthMost->_right;
			}

			//交换左子树最右边的叶子节点的值和要删除节点的值
			swap(leftRigthMost->_key, cur->_key);
			swap(leftRigthMost->_value, cur->_value);

			//删除左子树最右节点
			if (parent->_right == leftRigthMost)
				//一直遍历到左子树的最右节点
				parent->_right = leftRigthMost->_left;
			else
				//leftRigthMost右边刚开始就是一个空树
				parent->_left = leftRigthMost->_left;
			//举例：//leftRigthMost右边刚开始就是一个空树
			//						5
			//				4
			//		2
			//	1		3
			//要删除的节点是5，leftRigthMost是4，4的右边没有节点
			//交换节点4和节点5的值
			//						4
			//				5
			//		2
			//	1		3
			//4的左边连接2，最后删除5
			//				4
			//		2
			//	1		3
			delete leftRigthMost;
		}

		return true;
	}

	//private:
	Node* _root;		//根节点
};

//K-V结构的二叉搜索树的插入和删除
void test()
{
	BTree<int, int> b;
	b.insert(5, 50);
	b.insert(3, 30);
	b.insert(7, 70);
	b.insert(1, 10);
	b.insert(4, 40);
	b.insert(6, 60);
	b.insert(8, 80);
	b.insert(0, 100);
	b.insert(2, 50);
	b.insert(9, 90);
	//插入的key值不能重复，插入重复的key值不会报错，会返回false，表示插入失败
	
	b.inorder();
	cout << endl;

	b.erase(5);
	b.erase(3);
	b.erase(8);
	b.erase(9);
	b.erase(4);
	b.erase(6);

	b.inorder();
	cout << endl;
	//输出：
	//0->100 1->10 2->50 3->30 4->40 5->50 6->60 7->70 8->80 9->90
	//0->100 1->10 2->50 7->70
	//destory：0->100
	//destory：1->10
	//destory：7->70
	//destory：2->50
}

int main()
{
	test();
	return 0;
}
```



## 1.5二叉搜索树的性能分析

插入和删除操作都必须先查找，查找效率代表了二叉搜索树中各个操作的性能。

对有n个结点的二叉搜索树，若每个元素查找的概率相等，则二叉搜索树平均查找长度是结点在二叉搜索树的深度的函数，即结点越深，则比较次数越多。

但对于同一个关键码集合，如果各关键码插入的次序不同，可能得到不同结构的二叉搜索树。

最优情况下，二叉搜索树为完全二叉树，其平均比较次数为：logn

最差情况下，二叉搜索树退化为单支树，其平均比较次数为：n

问题：如果退化成单支树，二叉搜索树的性能就失去了。那能否进行改进，不论按照什么次序插入关键码，

都可以是二叉搜索树的性能最佳？

后续会讲。

# 2.二叉树进阶面试题

## 606根据二叉树创建字符串

题目：

给你二叉树的根节点 root ，请你采用前序遍历的方式，将二叉树转化为一个由括号和整数组成的字符串，返回构造出的字符串。

空节点使用一对空括号对 "()" 表示，转化后需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。



提示：

- 树中节点的数目范围是 `[1, 104]`
- `-1000 <= Node.val <= 1000`



**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/05/03/cons1-tree.jpg)

输入：root = [1,2,3,4]
输出："1(2(4))(3)"
解释：初步转化后得到 "1(2(4)())(3()())" ，但省略所有不必要的空括号对后，字符串应该是"1(2(4))(3)" 。



**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/05/03/cons2-tree.jpg)

输入：root = [1,2,3,null,4]
输出："1(2()(4))(3)"
解释：和第一个示例类似，但是无法省略第一个空括号对，否则会破坏输入与输出一一映射的关系。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void _stree2str(TreeNode* root,string& str)
    {
        if(root)
        {
            //整数转字符串
            //拼接当前节点的数据
            stringstream ss;    //io流中的str函数：返回stringstream中管理的string类型
            ss << root->val;    //int类型的数据变为string类型的数据
            str += ss.str();    //追加字符串

            //处理左子树
            if(root->left)
            {
                str += '(';
                _stree2str(root->left,str);
                str += ')';
            }
            else 
            {
                //判断左子树的右子树是否存在
                if(root->right)
                    str += "()";
                else
                    return;
            }

            //处理右子树
            if(root->right)
            {
                str += '(';
                _stree2str(root->right,str);
                str += ')';                
            }
        }

    }

    string tree2str(TreeNode* root) {
        //前序遍历
        string str;
        _stree2str(root,str);
        return str;
    }
};
```

## 102二叉树的层序遍历

题目：

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。



**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000`



**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
示例 2：

输入：root = [1]
输出：[[1]]
示例 3：

输入：root = []
输出：[] 

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> v;
        //借助队列进行层序遍历
        queue<TreeNode*> q;

        if(root)
            q.push(root);

        while(!q.empty())
        {
            //获取每一层的节点的个数
            int rowSize = q.size();

            vector<int> row;                //每一次循环row都是空的，是新创建的
            //同一层的数据放在同一行
            while(rowSize--)
            {
                TreeNode* cur = q.front();
                row.push_back(cur->val);
                q.pop();

                //存入下一次节点
                if(cur->left)
                    q.push(cur->left);
                if(cur->right)
                    q.push(cur->right);
            }

            //保存一行的数据
            v.push_back(row);

        }

        return v;
    }
};
```

## 107二叉树的层序遍历||

题目：

给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）



 **提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000`



**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

输入：root = [3,9,20,null,null,15,7]
输出：[[15,7],[9,20],[3]]
示例 2：

输入：root = [1]
输出：[[1]]
示例 3：

输入：root = []
输出：[] 

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> mat;
        //队列存放每一层需要遍历的元素
        queue<TreeNode*> que;
        //首先给队列中放入第一层的节点
        if(root)
            que.push(root);
        while(!que.empty())
        {
            //获取每一层的节点个数
            int rowSize = que.size();

            vector<int> row;                        //每一次循环row都是空的，是新创建的
            
            //同一层的数据放在同一行
            while(rowSize--)
            {
                TreeNode* cur = que.front();        //获取队头元素
                que.pop();
                row.push_back(cur->val);

                //存入下一层的左右节点
                if(cur->left)
                    que.push(cur->left);
                if(cur->right)
                    que.push(cur->right);
            }
            //时间复杂度是O(n)
            
            //保存一行的数据
            mat.push_back(row);
        }

        //反转
        int begin = 0;
        int end = mat.size() - 1;
        while(begin < end)
        {
            vector<int> temp = mat[begin];
            mat[begin] = mat[end];
            mat[end] = temp;
            begin++;
            end--;
        }

        //reverse(mat.begin(),mat.end());       //迭代器逆置
        
        return mat;
    }
};  
```

## 236二叉树的最近公共祖先

题目：
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”



提示：

树中节点数目在范围 [2, 105] 内。
-109 <= Node.val <= 109
所有 Node.val 互不相同 。
p != q
p 和 q 均存在于给定的二叉树中。 



**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 

**示例 2：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
示例 3：

输入：root = [1,2], p = 1, q = 2
输出：1 

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

//前序遍历查找路径
//参数：root：树的根节点    cur：要查找的节点    st：栈，保存查找的路径，引用传参
bool getPath(TreeNode* root,TreeNode* cur,stack<TreeNode*>& st)
{
    //递归的结束条件：节点为空的时候不存在左右节点，直接返回，避免出错
    if(root == nullptr)    
        return false;
    
    st.push(root);          //根节点入栈

    //判断当前节点是否是要查找的节点    比较地址
    if(root == cur)
        return true;

    //如果当前节点不是需要查找的节点，查看左右子树
    if(getPath(root->left,cur,st))  
        return true;            //在当前根节点的左子树中找到了
    if(getPath(root->right,cur,st))
        return true;            //在当前根节点的右子树中找到了
    
    //当前的根节点的所有路径上都不存在需要查找的节点，从栈保存的路径中删除
    st.pop();
 
    return false;
}

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        //需要查找的两个节点的路径
        stack<TreeNode*> path1;
        stack<TreeNode*> path2;

        //查找路径
        getPath(root,p,path1);
        getPath(root,q,path2); 

        //路径裁剪
        while(path1.size() != path2.size())
        {
            if(path1.size() > path2.size())
                path1.pop();
            else
                path2.pop();
        }

        //查找最近祖先节点  比较地址
        while(path1.top() != path2.top())
        {
            path1.pop();
            path2.pop();
        }

        return path1.top();
    }
};
```

## 剑指offer36二叉搜索树与双向链表（双向循环链表）

题目：

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

为了让您更好地理解问题，以下面的二叉搜索树为例：

 

![img](https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png)

我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。 

下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。

 

![img](https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png)

特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;

    Node() {}

    Node(int _val) {
        val = _val;
        left = NULL;
        right = NULL;
    }

    Node(int _val, Node* _left, Node* _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
public:
    void _Convert(Node* root,Node*& prev)
    {
        if(root)
        {
            _Convert(root->left,prev);
            root->left = prev;
            if(prev)
                prev->right = root;
            prev = root;
            _Convert(root->right,prev);
        }
    }

    Node* treeToDoublyList(Node* root) {
       if(!root)
            return root;
       Node* prev = nullptr;
       //转换
       _Convert(root,prev);
       //找到最左节点
       Node* head = root;
       while(head && head->left)        //head存在，head->left是nullptr就是最左节点，因为初始化是nullptr
       {
           head = head->left;     //找到最后cur为最左节点
       }
    
       Node* tail = root;
       while(tail && tail->right)
       {
           tail = tail->right;     //找到最后cur为最右节点
       }

        head->left = tail;
        tail->right = head;

        return head;
    }
};
```

## 105从前序与中序遍历序列构造二叉树

题目：

给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

 提示:

1 <= preorder.length <= 3000
inorder.length == preorder.length
-3000 <= preorder[i], inorder[i] <= 3000
preorder 和 inorder 均 无重复 元素
inorder 均出现在 preorder
preorder 保证 为二叉树的前序遍历序列
inorder 保证 为二叉树的中序遍历序列 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
示例 2:

输入: preorder = [-1], inorder = [-1]
输出: [-1] 

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //参数：二叉树的先序遍历，二叉树的后续遍历，前序当前走到哪个位置，中序的起始位置，中序的结束位置
    TreeNode* _buildTree(vector<int>& preorder, vector<int>& inorder,int& preIdx,int startIdx,int endIdx)
    {
        //前序建立的过程：根    左  右

        //树是空的 
        if(startIdx > endIdx)
            return nullptr;
        
        //实际走的过程是一个前序过程，中序确定左右子树区间包含哪些元素
        
        //创建当前节点:前序的头结点
        TreeNode* cur = new TreeNode(preorder[preIdx]);
        
        //查找左右子树的区间
        //在中序遍历序列中查找树的根节点，中序遍历根节点的左边是左子树，右边是右子树
        int curIdx = startIdx;
        for(;curIdx < endIdx;curIdx++)
        {
            if(inorder[curIdx] == preorder[preIdx])
                break;
        }

        //左子树区间:[startIdx,curIdx - 1]
        //创建左子树
        if(startIdx < curIdx)
            cur->left = _buildTree(preorder, inorder,++preIdx,startIdx,curIdx - 1);
        else
            cur->left = nullptr;
        
        //右子树区间:[curIdx + 1],endIdx]
        //创建右子树
        if(curIdx < endIdx)
            cur->right = _buildTree(preorder, inorder,++preIdx,curIdx + 1,endIdx);
        else
            cur->right = nullptr;
        
        return cur; 
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        //preIdx是引用接收的，要给非常量的值；（作为全局变量）
        int preIdx = 0;
        return _buildTree(preorder,inorder,preIdx,0,inorder.size() - 1);      
    }
};
```

## 106从中序与后序遍历序列构造二叉树

题目：

给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
示例 2:

输入：inorder = [-1], postorder = [-1]
输出：[-1]



提示:

1 <= inorder.length <= 3000
postorder.length == inorder.length
-3000 <= inorder[i], postorder[i] <= 3000
inorder 和 postorder 都由 不同 的值组成
postorder 中每一个值都在 inorder 中
inorder 保证是树的中序遍历
postorder 保证是树的后序遍历 

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //参数：二叉树的中序遍历    二叉树的后续遍历    后续遍历当前的位置：起始是最后一个索引  中序的起始位置  中序的结束位置
    TreeNode* _buildTree(vector<int>& inorder, vector<int>& postorder,int& postIdx,int startIdx,int endIdx)
    {
        //后序遍历：左  右  根

        //树是空的 
        if(postIdx > endIdx)
            return nullptr;

        //实际过程是走后序遍历的过程，中序遍历确定区间

        //创建当前节点：后续遍历的最后一个节点
        TreeNode* cur = new TreeNode(postorder[postIdx]);

        //查找左右子树的区间
        //在中序遍历序列中查找树的根节点，中序遍历根节点的左边是左子树，右边是右子树
        int curIdx = startIdx;
        for(;curIdx < endIdx;curIdx++)
        {
            if(inorder[curIdx] == postorder[postIdx])
                break;
        }

        //右子树区间:[curIdx + 1],endIdx]
        //创建右子树
        if(curIdx < endIdx)
            cur->right = _buildTree(inorder, postorder,--postIdx,curIdx + 1,endIdx);
        else
            cur->right = nullptr;

        //左子树区间:[startIdx,curIdx - 1]
        //创建左子树
        if(startIdx < curIdx)
            cur->left = _buildTree(inorder, postorder,--postIdx,startIdx,curIdx - 1);
        else
            cur->left = nullptr;
        
        return cur;

    }

    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        int postIdx = postorder.size() - 1;
        return _buildTree(inorder, postorder,postIdx,0,postorder.size() - 1);
    }
};
```

## 144二叉树的前序遍历

题目：

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

输入：root = [1,null,2,3]
输出：[1,2,3]
示例 2：

输入：root = []
输出：[]
示例 3：

输入：root = [1]
输出：[1] 

**示例 4：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg)

```c++
输入：root = [1,2]
输出：[1,2]
```

**示例 5：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg)

输入：root = [1,null,2]
输出：[1,2]


提示：

树中节点数目在范围 [0, 100] 内
-100 <= Node.val <= 100 

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> vec;    //保存遍历的节点的值，要返回的；
        TreeNode* cur = root;

        //当前遍历的节点不为空（root节点不为空需要验证）或者栈不为空（栈刚开始为空需要去判断root）；
        while(cur || !st.empty())
        {
            //访问cur的最左边路径，直到为空节点，路径上的节点全部入栈，之后会访问栈顶元素的右子树
            while(cur)
            {
                vec.push_back(cur->val);    
                st.push(cur);
                cur = cur->left;
            }

            //获取栈顶元素
            cur = st.top();
            st.pop();
            //从栈中拿出一个节点就表示这个节点的左子树和根节点已经访问完成了
            
            //访问右子树
            cur= cur->right;        //循环访问当前节点为根的前序遍历
        }

        return vec;
    }
};
```



## 94二叉树的中序遍历

题目：

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

输入：root = [1,null,2,3]
输出：[1,3,2]
示例 2：

输入：root = []
输出：[]
示例 3：

输入：root = [1]
输出：[1]


提示：

树中节点数目在范围 [0, 100] 内
-100 <= Node.val <= 100 

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> vec;    //保存遍历的节点的值，要返回的；
        TreeNode* cur = root;

        //当前遍历的节点不为空（root节点不为空需要验证）或者栈不为空（栈刚开始为空需要去判断root）；
        while(cur || !st.empty())
        {
            //访问cur的最左边路径，直到为空节点，路径上的节点全部入栈，之后会访问栈顶元素的右子树
            while(cur)
            {    
                st.push(cur);
                cur = cur->left;
            }

            //获取栈顶元素
            cur = st.top();
            st.pop();
            //从栈中拿出一个节点就表示这个节点的左子树和根节点已经访问完成了
            
            vec.push_back(cur->val);

            //访问右子树
            cur= cur->right;        //循环访问当前节点为根的前序遍历
        }

        return vec;
    }
};
```



## 145二叉树的后序遍历

题目：

给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg)

输入：root = [1,null,2,3]
输出：[3,2,1]
示例 2：

输入：root = []
输出：[]
示例 3：

输入：root = [1]
输出：[1]


提示：

树中节点的数目在范围 [0, 100] 内
-100 <= Node.val <= 100 

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        vector<int> vec;
        TreeNode* prev = nullptr;  //记录上一个节点
        while(cur || !st.empty())
        {
            //访问最左路径
            while(cur)
            {
                st.push(cur);
                cur = cur->left;
            }
            //获取栈顶元素
            TreeNode* top = st.top();
            //判断当前节点是否可以遍历
            if(top->right == nullptr || top->right == prev)
            {
                //可以访问当前节点
                vec.push_back(top->val);
                st.pop();
                prev = top;
            }
            else
            {
                //访问右子树
                cur = top->right;
            }
        }
        return vec;
    }
};
```



# 3.树需要学习的内容

学习数据结构中的树结构，你需要掌握以下内容：

1. 树的基本概念：了解树的定义和术语，包括根节点、子节点、叶节点、父节点、兄弟节点等。
2. 二叉树：学习二叉树的概念和性质，理解每个节点最多有两个子节点，包括满二叉树、完全二叉树等特殊类型的二叉树。
3. 二叉搜索树(BST)：了解二叉搜索树的特点，即左子树的值小于根节点的值，右子树的值大于根节点的值。学习BST的插入、删除和查找操作。
4. 平衡二叉树：学习平衡二叉树的概念和常见实现方法，如AVL树和红黑树，了解如何保持树的平衡以提高性能。
5. 堆和优先队列：学习堆这种特殊的树结构，了解最大堆和最小堆的性质，以及使用堆实现优先队列的方法。
6. 树的遍历：学习树的遍历算法，包括深度优先搜索(DFS)和广度优先搜索(BFS)，了解前序遍历、中序遍历和后序遍历等不同的遍历顺序。
7. 树的应用：掌握树在实际问题中的应用，如文件系统的表示、组织结构的表示、字典的实现等。
8. 其他类型的树：了解其他类型的树结构，如多叉树、B树、Trie树等，并了解它们的特性和应用场景。

除了以上内容，你还可以学习一些常见的树算法，如最小生成树算法（如Prim算法和Kruskal算法）、树的匹配算法（如KMP算法和AC自动机算法），以及树的动

态规划和回溯等算法技巧。

通过深入学习树结构及其相关算法，你将能够更好地理解和应用树在问题解决中的优势，同时为进一步学习其他高级数据结构和算法奠定基础。
