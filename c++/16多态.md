# 1.多态的概念

下面的所有代码的编译环境都是在vs2017下的x86下的，涉及的指针都是4bytes。

多态的概念：通俗来说，就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。

# 2.多态的定义及实现

## 2.1多态的构成条件

多态是在不同继承关系的类对象，去调用同一函数，产生了不同的行为。比如Student继承了Person，Person对象买票全价，Student对象买票半价。

那么在继承中要构成多态还有两个条件：
1.必须通过基类的指针或者引用调用虚函数。（可以是本类的指针或者引用）

2.被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写。

## 2.2虚函数

虚函数：即被virtual修饰的类成员函数称为虚函数。

## 2.3虚函数的重写

虚函数的重写(覆盖)：派生类中有一个跟基类完全相同的虚函数(即派生类虚函数与基类虚函数的返回值类型、函数名字、参数列表完全相同)，称子类的虚函数重写

了基类的虚函数。

```c++
#include <iostream>
#include <string>

using namespace std;

//多态条件：
//0.前提：继承
//1.有序函数
//2.子类重写父类的虚函数
//3.调用此函数的类型是基类的指针或引用(基类包括本类自身)

//如果调用此函数的类型是值（不满足多态），就会调用父类的虚函数。

class Person 
{
public:
	//虚函数：virtual + 正常的函数定义
	virtual void BuyTicket() const
	{
		cout << "买票-全价" << endl; 
	}
};

class Student : public Person
{
public:
	//虚函数重写：子类定义了一个和父类接口完全相同的函数
	//重写的虚函数：函数名、参数列表、返回值类型都和父类对应的一致
	//不是虚函数就是函数重写了，函数重写只要求基类和派生类有相同的函数名，参数可以不一样
	//两个基类和派生类的同名函数不构成重写（覆盖）就是重定义（隐藏）
	//虚函数：virtual + 正常的函数定义

	//注意：在重写基类虚函数时，派生类的虚函数在不加virtual关键字时，虽然也可以构成重写(因为继承后
	//基类的虚函数被继承下来了在派生类依旧保持虚函数属性), 但是该种写法不是很规范，不建议这样使用
	virtual void BuyTicket() const		//virtual在子类可以不写，但推荐写上
	{
		cout << "买票-半价" << endl;
	}
};

//多态：看参数实际指向哪一个对象(切片)
void fun(const Person& p)
{
	p.BuyTicket();
}
 
//非多态：看参数的类型(值拷贝)
void func(const Person p)
{
	p.BuyTicket();
}

void test()
{
	Person p;
	Student s;
	fun(p);		//买票-全价
	fun(s);		//买票-半价
	func(p);	//买票-全价
	func(s);	//买票-全价
}

int main()
{
	test();
	return 0;
}
```

虚函数重写的两个例外：

1.协变(基类与派生类虚函数返回值类型不同)：派生类重写基类虚函数时，与基类虚函数返回值类型不同。即基类虚函数返回基类对象的指针或者引用，派生类虚

函数返回派生类对象的指针或者引用时，称为协变。（了解）

```c++
#include <iostream>
#include <string>

using namespace std;

class A{};

class B : public A{};

class Person
{
public:
	//协变：返回值类型可以不同，但是必须是有继承关系的指针或者引用。
	virtual A* BuyTicket() const
	{
		cout << "买票-全价" << endl;
		return new A;
	}
};

class Student : public Person
{
public:
	virtual B* BuyTicket() const
	{
		cout << "买票-半价" << endl;
		return new B;
	}
};

void fun(const Person& p)
{
	p.BuyTicket();
}

void test()
{
	Person p;
	Student s;
	fun(p);		//买票-全价
	fun(s);		//买票-半价
}

int main()
{
	test();
	return 0;
}
```

2.析构函数的重写**(**基类与派生类析构函数的名字不同)：如果基类的析构函数为虚函数，此时派生类析构函数只要定义，无论是否加virtual关键字，都与基类的析

构函数构成重写，虽然基类与派生类析构函数名字不同。虽然函数名不相同，看起来违背了重写的规则，其实不然，这里可以理解为编译器对析构函数的名称做了

特殊处理，编译后析构函数的名称统一处理成destructor。

```c++
#include <iostream>
#include <string>

using namespace std;

class A{};

class B : public A{};

//析构函数重写的原因是析构函数名称在底层是一样的
class Person
{
public:
	//协变：返回值类型可以不同，但是必须是有继承关系的指针或者引用。
	virtual A* BuyTicket() const
	{
		cout << "买票-全价" << endl;
		return new A;
	}

	virtual ~Person()
	{
		cout << "~Person" << endl;
	}
};

class Student : public Person
{
public:
	virtual B* BuyTicket() const
	{
		cout << "买票-半价" << endl;
		return new B;
	}
	
	//子类的析构重写父类的析构
	//如果有多态，都会把父类的析构函数会写成虚函数（会避免资源和内存泄漏的问题）
	virtual ~Student()
	{
		delete[] ptr;
		cout << "~Student" << endl;
	}

protected:
	char* ptr = new char[100];
};

void fun(const Person& p)
{
	p.BuyTicket();
}

//析构函数不是虚函数的情况（解释为什么析构函数需要设置为虚函数）
void test1()
{
	//析构函数不是虚函数，看的是左边的类型。
	Person* p = new Student();
	delete p;		//动态开辟要手动释放
	//输出：
	//~Person		没有释放Student子类开辟的空间，会有问题

	Student* s = new Student;
	delete s;
	//输出：
	//~Student
	//~Person
}

//派生类构造的顺序：先构造父类，再构造子类。
//派生类析构的顺序：先析构子类，再析构父类。

//析构函数为虚函数的情况
void test2()
{
	Person* p = new Student();		//虚函数看的是后面动态申请的对象类型，不是虚函数看的是前面指针的类型
	delete p;		//动态开辟要手动释放
	//输出：
	//~Student
	//~Person		 

	Student* s = new Student;
	delete s;
	//输出：
	//~Student
	//~Person
}

int main()
{
	//test1();
	test2();
	return 0;
}
```

## 2.4c++11override和final

从上面可以看出，C++对函数重写的要求比较严格，但是有些情况下由于疏忽，可能会导致函数名字母次序写反而无法构成重载，而这种错误在编译期间是不会报

出的，只有在程序运行时没有得到预期结果才来debug会得不偿失，因此：C++11提供了override和final两个关键字，可以帮助用户检测是否重写。

1.final：修饰虚函数或者类，表示该虚函数或者类不能再被继承。

```c++
#include <iostream>
#include <string>

using namespace std;

//final关键字的用处：（在父类用的关键字）
//1.修饰类，表示该类不能被继承，是一个不能扩展的类，最终类。
//2.修饰虚函数：给一个虚函数后面加上final关键字，表示该虚函数是最终函数，不能被重写，只能继承过去使用。（这个虚函数在子类中可以用，但子类不能重写）
class A final			//修饰类，表示该类不能被继承，是一个不能扩展的类，最终类
{

};

/* 
class B : public A		//error，报错：不能将"final"类类型用作基类
{

};
*/

class Person
{
public:
	//修饰虚函数：给一个虚函数后面加上final关键字，表示该虚函数是最终函数，不能被重写
	//这个虚函数在子类中可以用，但子类不能重写
	//final修饰的函数，表示是一个最终函数，不能改变的函数
	virtual void BuyTicket() const final		//const必须紧跟在函数后面，不能放在final后面
	{
		cout << "买票-全价" << endl;
	}

	virtual ~Person()
	{
		cout << "~Person" << endl;
	}
};

class Student : public Person
{
public:
	/* 
	virtual void BuyTicket() const		//error，报错：无法重写"final"函数
	{
		cout << "买票-半价" << endl;
	}
	*/

	virtual ~Student()
	{
		delete[] ptr;
		cout << "~Student" << endl;
	}

protected:
	char* ptr = new char[100];
};

void fun(const Person& p)
{
	p.BuyTicket();
}

void test()
{

}

int main()
{
	test();
	return 0;
}
```

2.override：检查派生类虚函数是否重写了基类某个虚函数，如果没有重写编译报错。

```c++
#include <iostream>
#include <string>

using namespace std;

//override关键字的用处：（在子类用的关键字）
//强制派生类重写虚函数
//加override的虚函数必须是基类已经存在的虚函数
//使用"override"声明的成员函数不能重定义基类成员函数

class A 
{

};


class B : public A		 
{

}; 

class Person
{
public:
	virtual void BuyTicket() const  
	{
		cout << "买票-全价" << endl;
	}

	virtual ~Person()
	{
		cout << "~Person" << endl;
	}
};

class Student : public Person
{
public:
	//virtual void BuyTicket(int a) const override{}		//error，函数重写的参数不同

	virtual void BuyTicket() const	override
	{
		cout << "买票-全价" << endl;
	} 

	virtual ~Student()
	{
		delete[] ptr;
		cout << "~Student" << endl;
	}

protected:
	char* ptr = new char[100];
};

void fun(const Person& p)
{
	p.BuyTicket();
}

void test()
{

}

int main()
{
	test();
	return 0;
}
```

## 2.5重载、覆盖（重写）、隐藏（重定义）的对比

| 重载                                                         | 重写（覆盖）                                                 | 重定义（隐藏）                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1.两个函数在同一作用域；2.函数名相同，参数不相同（参数类型、个数、顺序至少有一个不同）。 | 1.两个函数分别在基类和派生类的作用域中；2.函数名、参数和返回值都必须相同；（协变例外）3.两个函数必须是虚函数。 | 1.两个函数分别在基类和派生类的作用域中；2.函数名相同；3.两个基类和派生类的同名函数不构成重写就是重定义。 |

# 3.抽象类

## 3.1概念

在虚函数的后面写上 = 0 ，则这个函数为纯虚函数。包含纯虚函数的类叫做抽象类（也叫接口类），抽象类不能实例化出对象。派生类继承后也不能实例化出对

象，只有重写纯虚函数，派生类才能实例化出对象。纯虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承。

```c++
#include <iostream>
#include <string>

using namespace std;

//抽象类：一个类中定义了纯虚函数，这个类就叫做抽象类。（抽象类是不具有实例化的类）
class A
{
public:
	virtual void fun() = 0;		//纯虚函数
};

//继承了抽象类的类，需要把抽象类中的所有纯虚函数都实现，这个类才能被实例化。
class B : public A
{
public:
	virtual void fun()
	{
		cout << "B::fun()" << endl;
	}
};

class C : public A
{
public:
	virtual void fun()
	{
		cout << "C::fun()" << endl;
	}
};

//继承了抽象类的类，没有全部实现继承的抽象类中的纯虚函数，那么这个类也叫做抽象类。
class D : public A
{
	
};

void test()
{
	A* b = new B;
	A* c = new C;
	b->fun();
	c->fun();
	//输出：
	//B::fun()
	//C::fun()
}

int main()
{
	test();
	return 0;
}
```

## 3.2接口继承和实现继承

普通函数的继承是一种实现继承，派生类继承了基类函数，可以使用函数，继承的是函数的实现。

虚函数或纯虚函数的继承是一种接口继承，派生类继承的是基类虚函数或纯虚函数的接口，目的是为了重写，达成多态，继承的是接口。所以如果不实现多态，不

要把函数定义成虚函数。

# 4.多态的原理

## 4.1虚函数表

1.只要类中有虚函数，类对象中都会有一个虚表指针成员：__vfptr。

2.虚表是虚函数指针数组，虚表中不存放普通函数指针。

3.子类会继承父类的虚表。（子类和父类的虚表地址不一样）

4.子类的虚表中，如果有重写的虚函数，对应的函数指针也会被子类的虚函数指针覆盖。

5.虚表指针是放在对象中的，虚表没有存放在对象中（虚表一般存放在代码段，这个是有疑问的，因为代码测试完发现可能是数据段，回头看完操作系统再看这个

问题），虚函数和普通函数一样都是放在代码段的。

```c++
#include <iostream>
#include <string>

using namespace std;

class A
{
public:
	virtual void fun()
	{
		cout << "A::fun()" << endl;
	}

	void fun2()
	{
		cout << "A::fun2()" << endl;
	}

private:
	int _a = 1;
};

class B : public A
{
public:
	virtual void fun()
	{
		cout << "B::fun()" << endl;
	}
};
 
void f(){}

void test()
{
	B b;
	A a;
	cout << sizeof(A) << endl;	//8
	cout << sizeof(B) << endl;	//8
	static int si = 0;	//数据段
	int i = 1;	//栈
	int* p = new int;	//堆
	void(*ptr)();		//函数指针
	ptr = f;			//代码段
	cout << "栈：" << &i << endl;		//栈：008FFB00
	cout << "堆：" << p << endl;		//堆：00CA5120
	cout << "数据段：" << &si << endl;	//数据段：009BC2F8
	cout << "代码段：" << ptr << endl;	//代码段：009B129E	 

	typedef void(*vfptr)();
	//获取对象的前4个字节，就是虚表指针
	vfptr* vptr = (vfptr*)(*(int*)&b);
	cout << "虚表指针：" << vptr << endl;	//虚表指针：009B9B4C
}

int main()
{
	test();
	return 0;
}
```

通过观察测试我们发现a对象是8bytes，除了_a成员，还多一个__vfptr放在对象的前面(注意有些平台可能会放到对象的最后面，这个跟平台有关)，对象中的这个

指针我们叫做虚函数表指针(v代表virtual，f代表function)。一个含有虚函数的类中都至少都有一个虚函数表指针，因为虚函数的地址要被放到虚函数表中，

虚函数表也简称虚表。那么派生类中这个表放了些什么呢？我们接着往下分析。（由于虚函数表在vs2017环境下显示不全的问题，所以不能显示调试图片，后面

会打印出来）

通过观察和测试，我们发现了以下几点问题：

1.派生类对象b中也有一个虚表指针，b对象由两部分构成，一部分是父类继承下来的成员，虚表指针也就是存在部分的另一部分是自己的成员。

2.基类a对象和派生类b对象虚表(虚函数表)是不一样的，这里我们发现fun()完成了重写，所以b的虚表中存的是重写的B::fun()，所以虚函数的重写也叫作覆盖，覆

盖就是指虚表中虚函数的覆盖。重写是语法的叫法，覆盖是原理层的叫法。

3.继承下来后是虚函数，所以放进了虚表，放进虚表后进行重写，重写就是覆盖，fun2也继承下来了，但是不是虚函数，所以不会放进虚表。

**4.虚函数表本质是一个存虚函数指针的指针数组，这个数组最后面放了一个nullptr。**

5.总结一下派生类的虚表生成：

​	5.1先将基类中的虚表内容拷贝一份到派生类虚表中；

​	5.2如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数；

​	5.3派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。（如果派生类是多继承，就把新增加的虚函数放在第一个虚函数表的最	

​		  后面）

6.虚函数存在哪的？虚表存在哪的？ 

答：虚函数存在虚表，虚表存在对象中。注意上面的回答的错的。注意虚表存的是虚函数指针，不是虚函数，虚函数和普通函数一样的，都是存在代码段的，只是

他的指针又存到了虚表中。另外对象中存的不是虚表，存的是虚表指针。那么虚表存在哪的呢？实际我们去验证一下会发现vs下是存在代码段的。（Linux g++下

回头测试）

## 4.2多态的原理

满足多态的条件：

1.虚函数的覆盖；

2.对象的指针或者引用调用虚函数。

满足多态以后的函数调用，不是在编译时确定的，是运行起来以后到对象的中取找的。不满足多态的函数调用时编译时确认好的。

多态的调用不是在编译时确定的，是在运行起来以后在对象中的找到的（通过虚函数表的指针找到虚函数表，虚函数表里面存放虚函数指针，间接找到虚函数）。

普通函数的调用转换成地址时，是在编译时已经从符号表确认了函数的地址，直接call地址。

## 4.3动态绑定与静态绑定

1.静态（编译器）绑定又称为前期绑定(早绑定)，在程序编译期间确定了程序的行为，也称为静态多态，比如：函数重载、模板。

2.动态（运行时）绑定又称后期绑定(晚绑定)，是在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数，也称为动态多态。

# 5.单继承和多继承关系中的虚函数表

需要注意的是在单继承和多继承关系中，下面我们去关注的是派生类对象的虚表模型，因为基类的虚表模型前面我们已经看过了，没什么需要特别研究的。

## 5.1单继承中的虚函数表

```c++
#include <iostream>
#include <string>

using namespace std;

class Base 
{
public:
	virtual void func1() { cout << "Base::func1" << endl; }
	virtual void func2() { cout << "Base::func2" << endl; }

private:
	int a;
};

class Derive :public  Base 
{
public:
	virtual void func1() { cout << "Derive::func1" << endl; }
	virtual void func3() { cout << "Derive::func3" << endl; }
	virtual void func4() { cout << "Derive::func4" << endl; }

private:
	int b;
};

typedef void(*vfptr)();		//vfptr是函数指针

void printVTable(vfptr vfTable[])	//函数指针数组
{
	cout << "虚表地址：" << vfTable << endl;
	vfptr* fptr = vfTable;
	while (*fptr != nullptr)
	{
		(*fptr)();		//*fptr是虚函数指针
		++fptr;
	}
}

void test()
{
	Base b;
	Derive d;
	cout << "Base：" << endl;
	//思路：取出b、d对象的头4bytes，就是虚表的指针，前面我们说了虚函数表本质是一个存虚函数指针的指针数组，
	//这个数组最后面放了一个nullptr
	//1.先取b的地址，强转成一个int*的指针
	//2.再解引用取值，就取到了b对象头4bytes的值，这个值就是指向虚表的指针
	//3.再强转成vfptr*，因为虚表就是一个存vfptr类型(虚函数指针类型)的数组。
	//4.虚表指针传递给printVTable进行打印虚表
	//5.需要说明的是这个打印虚表的代码经常会崩溃，因为编译器有时对虚表的处理不干净，
	//虚表最后面没有放nullptr，导致越界，这是编译器的问题。
	//我们只需要点目录栏的 - 生成 - 清理解决方案，再编译就好了。
	vfptr* vftable = (vfptr*)(*(int*)&b);	
	//vftable就是前4个字节的值，是一个指向虚函数指针数组的指针（虚函数表指针），指向指针数组的首地址
	printVTable(vftable);
	//输出：
	//Base：
	//虚表地址：00CC9B34
	//Base::func1
	//Base::func2

	cout << "Derive：" << endl;
	vftable = (vfptr*)(*(int*)&d);
	printVTable(vftable);
	//Derive：
	//虚表地址：00CC9B64
	//Derive::func1
	//Base::func2
	//Derive::func3
	//Derive::func4
}

int main()
{
	test();
	return 0;
}
```

## 5.2多继承中的虚函数表

```c++
#include <iostream>
#include <string>

using namespace std;

class Base1
{
public:
	virtual void func1() { cout << "Base1::func1" << endl; }
	virtual void func2() { cout << "Base1::func2" << endl; }

private:
	int b1;
};

class Base2
{
public:
	virtual void func1() { cout << "Base2::func1" << endl; }
	virtual void func2() { cout << "Base2::func2" << endl; }

private:
	int b2;
};

class Derive : public Base1, public Base2
{
public:
	virtual void func1() { cout << "Derive::func1" << endl; }
	virtual void func3() { cout << "Derive::func3" << endl; }

private:
	int d1;
};

typedef void(*vfptr)();

void printVTable(vfptr vfTable[])
{
	cout << "虚表地址：" << vfTable << endl;
	vfptr* fptr = vfTable;
	while (*fptr != nullptr)
	{
		(*fptr)();
		++fptr;
	}
}

void test()
{
	Derive d;
	cout << "Derive：" << endl;
	vfptr* vTableb1 = (vfptr*)(*(int*)&d);
	printVTable(vTableb1);
	//输出：
	//Derive：
	//虚表地址：002A9B94
	//Derive::func1
	//Base1::func2
	//Derive::func3
	//派生类新添加的虚函数的虚函数指针放在第一个虚函数表继承的虚函数的虚函数指针的后面

	vfptr* vTableb2 = (vfptr*)(*(int*)((char*)&d + sizeof(Base1)));		//指针偏移
	printVTable(vTableb2);
	//虚表地址：002A9BA8
	//Derive::func1
	//Base2::func2
}

int main()
{	
	test();
	return 0;
}
```

## 5.3菱形继承、菱形虚拟继承

实际中我们不建议设计出菱形继承及菱形虚拟继承，一方面太复杂容易出问题，另一方面这样的模型，访问基类成员有一定得性能损耗。所以菱形继承、菱形虚拟

继承我们的虚表我们就不看了，一般我们也不需要研究清楚，因为实际中很少用。如果好奇心比较强的宝宝，可以去看下面的两篇链接文章。

链接：

1.c++虚函数表解析：https://coolshell.cn/articles/12165.html

2.c++对象的内存布局：https://coolshell.cn/articles/12176.html

3.程序内存分布：https://zhuanlan.zhihu.com/p/348026261

# 6.继承和多态常见的面试问题

## 6.1概念考察

1.下面哪种面向对象的方法可以让你变得富有( )

A: 继承 B: 封装 C: 多态 D: 抽象

答案：继承。

封装体现的是管理，多态是实际函数的执行行为。

2.( )是面向对象程序设计语言中的一种机制。这种机制实现了方法的定义与具体的对象无关，而对方法的调用则可以关联于具体的对象。

A: 继承 B: 模板 C: 对象的自身引用 D: 动态绑定

答案：动态绑定

3.面向对象设计中的继承和组合，下面说法错误的是？（）

A：继承允许我们覆盖重写父类的实现细节，父类的实现对于子类是可见的，是一种静态复用，也称为白盒复用

B：组合的对象不需要关心各自的实现细节，之间的关系是在运行时候才确定的，是一种动态复用，也称为黑盒复用（这里的静态、动态和多态是没有关系的）

C：优先使用继承，而不是组合，是面向对象设计的第二原则

D：继承可以使子类能自动继承父类的接口，但在设计模式中认为这是一种破坏了父类的封装性的表现

答案：c

继承是一种破坏父类封装性的语法，继承是和封装冲突的。

继承和组合，优先使用组合。

高内聚和低耦合是软件设计中的两个重要原则。

高内聚（High Cohesion）指的是一个模块或类应该有着清晰的单一责任，模块内部的元素（方法、属性等）相互关联，彼此紧密合作以完成相同的任务。高内聚

的模块通常具有更好的可读性、可维护性和可测试性。模块内部的修改不会轻易影响到其他模块。

低耦合（Low Coupling）指的是模块或类之间的相互依赖关系应该尽量减少，模块间的接口应该简洁明确，模块间的耦合度应该尽量降低。低耦合的设计更加灵

活，允许系统中的各个模块独立变化，提高了代码的可重用性和可扩展性。

高内聚和低耦合是相辅相成的原则，它们能够提高软件系统的质量和可维护性。通过将功能相关的代码放在一起，实现高内聚；通过减少模块之间的依赖，实现低

耦合。这样的设计能够使代码更容易理解、测试和修改，并且提供更大的灵活性和可重用性。

在软件开发中，我们可以通过合理的模块划分、接口设计和设计模式等方式来实现高内聚和低耦合。这样的设计可以提高代码的质量、可维护性和可扩展性，同时

也有助于团队合作和项目的长期发展。

4.以下关于纯虚函数的说法,正确的是( )

A：声明纯虚函数的类不能实例化 B：声明纯虚函数的类成虚基类

C：子类必须实现基类的 D：纯虚函数必须是空函数

答案：a

空函数是指函数体是空的，纯虚函数是 = 0；

```c++
class A
{};

class B : virtual public A
{};

class C : public virtual A
{};

A是虚基类
```

5.关于虚函数的描述正确的是( )

A：派生类的虚函数与基类的虚函数具有不同的参数个数和类型 B：内联函数不能是虚函数

C：派生类必须重新定义基类的虚函数 D：虚函数可以是一个static型的函数

答案：b

派生类的虚函数与基类的虚函数具有不同的参数个数和类型，是虚函数的隐藏。

虚函数也可以隐藏，但是虚函数不是为了重写，定义虚函数是没有意义的，虚函数就是为了实现多态。

内联函数不能是虚函数，内敛函数是在调用的地方已经展开了，展开就没有符号了，如果内敛函数是虚函数的话，在虚函数表中是找不到内敛函数的符号的，所以

内敛函数不会是虚函数。

虚函数不能是static型的函数，多态的原理是要访问虚函数表，虚函数表指针是在对象里面的，但static修饰的函数是没有对象的，是通过类名访问static成员的，

通过类名不能拿到虚表指针的。

6.关于虚表说法正确的是（ ）

A：一个类只能有一张虚表

B：基类中有虚函数，如果子类中没有重写基类的虚函数，此时子类与基类共用同一张虚表

C：虚表是在运行期间动态生成的

D：一个类的不同对象共享该类的虚表

答案：d

一个类可以有多张虚表，多继承就有多张虚表。

基类中有虚函数，如果子类没有重写基类的虚函数，只是将基类的虚函数表拷贝了一份，可以理解为深拷贝，是两张虚函数表，两张虚函数表的地址不一样。

同一个类下的不同对象使用同一张虚函数表（虚表）。（可以通过对象的虚函数表指针的指向测验）

虚函数表是在编译的时候已经编译好的，只是在运行的时候通过虚函数表找到需要执行函数的地址。

7.假设A类中有虚函数，B继承自A，B重写A中的虚函数，也没有定义任何虚函数，则（ ）

A：A类对象的前4个字节存储虚表地址，B类对象前4个字节不是虚表地址

B：A类对象和B类对象前4个字节存储的都是虚基表的地址

C：A类对象和B类对象前4个字节存储的虚表地址相同

D：A类和B类中的内容完全一样，但是A类和B类使用的不是同一张虚表  

答案：d，但是d说的内容完全一样不包括虚函数表的地址，这样d才是对的。

只要有虚函数，对象的前4个字节（32为操作系统）就是虚函数表的地址。

如果有虚拟继承（虚拟继承是为了避免多继承的二义性，或者当有多个类继承同一个类的时候最好使用虚拟继承，避免之后另一个类多继承的时候出错）就有虚基

表地址，但是虚基表地址一定在虚函数表地址的下面。

8.下面程序输出结果是什么? （） 

```c++
#include<iostream>
using namespace std;

class A 
{
public:
	A(char *s) { cout << s << endl; }
	~A() {}
};

class B :virtual public A
{
public:
	B(char *s1, char*s2) :A(s1) { cout << s2 << endl; }
};

class C :virtual public A
{
public:
	C(char *s1, char*s2) :A(s1) { cout << s2 << endl; }
};

class D :public B, public C
{
public:
	D(char *s1, char *s2, char *s3, char *s4) :B(s1, s2), C(s1, s3), A(s1)
	{
		cout << s4 << endl;
	}
};

int main() 
{
	D *p = new D("class A", "class B", "class C", "class D");
	delete p;
	return 0;
}
```

A：class A class B class C class D B：class D class B class C class A

C：class D class C class B class A D：class A class C class B class D

答案：a

9.多继承中指针偏移问题？下面说法正确的是( )  

```c++
class Base1 { public: int _b1; };
class Base2 { public: int _b2; };
class Derive : public Base1, public Base2 { public: int _d; };

int main() {
	Derive d;
	Base1* p1 = &d;
	Base2* p2 = &d;
	Derive* p3 = &d;
	return 0;
}
```

A：p1 == p2 == p3 B：p1 < p2 < p3 C：p1 == p3 != p2 D：p1 != p2 != p3

答案：c

10.以下程序输出结果是什么（）  

```c++
class A
{
public:
	virtual void func(int val = 1) { std::cout << "A->" << val << std::endl; }
	virtual void test() { func(); }
};

class B : public A
{
public:
	void func(int val = 0) { std::cout << "B->" << val << std::endl; }
};

int main(int argc, char* argv[])
{
	B*p = new B;
	p->test();
	return 0;
}
```

A: A->0 B: B->1 C: A->1 D: B->0 E: 编译出错 F: 以上都不正确

答案：b

原因：对象是B类型的，调用继承A的test函数，因为this指针指向的对象是B，所以执行的是B中重写的func()函数，func()最开始定义的地方是在A中的，缺省值看

的是第一次出现的地方（声明和定义的地方），在A中，所以使用的是A中的func()中的缺省值，所以输出是B->1。（B中只是重写了func()函数，不是申明和定义

的地方）

## 6.2问答题

**1.什么是多态？**

答：

多态（Polymorphism）是面向对象编程中的一个重要概念，它允许以统一的方式处理不同的数据类型或类对象。

多态性使得我们可以使用基类定义的接口来操作派生类的对象，而无需关心具体的派生类类型。通过多态性，我们可以在运行时确定具体要调用的函数或方法，实

现动态绑定。

多态性的实现依赖于以下两个关键概念：

1. 虚函数（Virtual Function）：在基类中声明一个虚函数，派生类可以通过重写（覆盖）该虚函数来提供自己的实现。在程序运行时，根据对象的实际类型来

   决定调用哪个版本的虚函数。

2. 指针或引用的多态性：通过使用基类的指针或引用来引用派生类的对象。这样，可以通过基类的指针或引用调用虚函数，以实现对派生类的多态访问。

多态性的好处在于可以编写灵活的、可扩展的代码。通过将接口和实现解耦，可以在不破坏现有代码的情况下添加新的派生类，并以一致的方式进行处理。

以下是一个简单的示例代码，展示了多态的应用：

```c++
class Shape 
{
public:
    virtual void draw() {
        // 基类的虚函数实现
    }
};

class Circle : public Shape 
{
public:
    void draw() override {
        // 派生类的虚函数实现
    }
};

class Square : public Shape 
{
public:
    void draw() override {
        // 派生类的虚函数实现
    }
};

int main() 
{
    Shape* shape1 = new Circle();
    Shape* shape2 = new Square();

    shape1->draw();  // 动态绑定，调用 Circle 的 draw 函数
    shape2->draw();  // 动态绑定，调用 Square 的 draw 函数

    delete shape1;
    delete shape2;

    return 0;
}
```

在上述示例中，通过基类指针 `shape1` 和 `shape2` 调用 `draw()` 函数。由于 `draw()` 函数是虚函数，在运行时会根据对象的实际类型来决定调用哪个版本的函

数。

这就是多态性的实现方式之一，它可以根据具体对象的类型来进行动态绑定，从而实现调用不同派生类的同名函数。



**2.什么是重载、重写(覆盖)、重定义(隐藏)？**

答：

重载（Overloading）是指在同一个作用域内，通过定义具有相同名称但参数列表不同的多个函数或方法。重载的目的是为了提供更加灵活和方便的使用方式，可

以根据传入的参数类型或数量来决定调用哪个版本的函数。

重载函数或方法在编译时会根据调用时提供的参数匹配最合适的版本。参数匹配的规则包括参数个数、参数类型和参数顺序。

例如：

```c++
#include <iostream>

using namespace std;

void print(int num) 
{
    // 打印整数
}

void print(double num)
{
    // 打印浮点数
}

int main()
{
	print(5);          // 调用 print(int)
	print(3.14);       // 调用 print(double)
	return 0;	
}
```

重写（Override）也被称为覆盖，是指派生类定义了与基类中完全相同的函数，并且函数声明前加上 `override` 关键字。重写的目的是改变继承关系中某个函数

的行为，使其在派生类中执行不同的操作。

在运行时，当通过基类指针或引用调用虚函数时，会根据对象的实际类型来动态绑定（动态分派）调用正确的函数版本。

例如：

```c++
#include <iostream>

using namespace std;

class Base 
{
public:
    virtual void doSomething()
    {
        // 基类的虚函数实现
    }
};

class Derived : public Base 
{
public:
    void doSomething() override 
    {
        // 派生类的虚函数实现
    }
};

int main()
{
	Base* obj = new Derived();
	obj->doSomething();  // 动态绑定，调用 Derived 的 doSomething 函数
	return 0;
}
```

重定义（Hide）是指派生类中定义了与基类中同名但参数列表不同的函数，从而隐藏了基类的函数。在重定义中，函数的名称相同但签名不同，因此无法进行动态

绑定。

例如：

```c++
#include <iostream>

using namespace std;

class Base 
{
public:
	void print() 
    {
		cout << "Base" << endl;
	}
};

class Derived : public Base 
{
public:
	void print(int num) 
    {
		cout << "Derived: " << num << endl;
	}
};

int main()
{
	Derived obj;
	//obj.print();      //error
	obj.Base::print();	//Base，调用 Base 的 print() 函数

	return 0;
}
```

在上述示例中，派生类 `Derived` 中定义了一个带有参数的 `print()` 函数，该函数与基类 `Base` 中的无参 `print()` 函数同名但参数列表不同。因此，在派生类对

象上直接调用 `print()` 函数将调用派生类的版本，而通过指定作用域解析符号 `Base::print()` 可以调用基类的版本。

总结：

- 重载是指在同一个作用域内定义多个具有相同名称但参数列表不同的函数或方法。
- 重写（覆盖）是指派生类中重新定义了基类中的虚函数，并通过动态绑定实现根据对象的类型调用正确的函数版本。
- 重定义（隐藏）是指派生类中定义了与基类同名但参数列表不同的函数，从而隐藏了基类的函数。



**3.多态的实现原理？**

答：

多态的实现原理主要涉及两个关键概念：虚函数和指针/引用的多态性。

1. 虚函数（Virtual Function）：在基类中声明一个虚函数。派生类可以通过重写（覆盖）该虚函数来提供自己的实现。虚函数使用关键字 `virtual` 声明，用于

   表示该函数可以被派生类重写。虚函数允许在运行时根据对象的实际类型来动态绑定（动态分派）调用正确的函数版本。

2. 指针/引用的多态性：通过使用基类的指针或引用来引用派生类的对象。由于派生类对象也是基类对象的一种，因此可以使用基类的指针或引用来引用派生类的

   对象。这样，在编译时静态类型是基类，但在运行时实际类型可能是派生类。通过基类的指针或引用调用虚函数时，会根据对象的实际类型来决定调用哪个版

   本的函数。

多态性的实现步骤如下：

1.声明一个基类，并在其中定义一个虚函数。

```c++
class Shape 
{
public:
    virtual void draw()
    {
        // 基类的虚函数实现
    }
};
```

2.派生类继承基类，并重写基类中的虚函数。

```c++
class Circle : public Shape 
{
public:
    void draw() override
    {
        // 派生类的虚函数实现
    }
};
```

3.使用基类指针或引用来引用派生类对象，并调用虚函数。

```c++
int main()
{
	cppCopy CodeShape* shape1 = new Circle();
	shape1->draw();  // 动态绑定，调用 Circle 的 draw 函数
}
```

在上述示例中，通过基类指针 `shape1` 引用了一个派生类 `Circle` 的对象。在调用 `shape1->draw()` 时，由于 `draw()` 是虚函数，会根据 `shape1` 实际指向的对

象类型来动态绑定（动态分派）调用正确的函数版本。因此，会调用派生类 `Circle` 中重写的 `draw()` 函数。

这样，通过虚函数和基类指针/引用的多态性，实现了多态性的特性，即在编译时期并不知道实际对象类型的情况下，依然能够根据运行时对象的实际类型来调用

正确的函数版本。



**4.inline函数可以是虚函数吗？答：不能，因为inline函数没有地址，无法把地址放到虚函数表中。**

答：

内联函数与虚函数的特性存在一些冲突，因此虚函数不能被声明为内联函数。

内联函数是在编译时将函数的实际代码插入到调用函数的地方，以避免函数调用的开销。虚函数的调用涉及虚表和运行时的动态绑定过程，无法在编译时确定实际

调用的函数。

虚函数需要在运行时进行动态绑定，以根据对象的实际类型调用正确的函数。而内联函数在编译时就展开，无法实现动态绑定的特性。

因此，虚函数不能被声明为内联函数。如果在类定义中将虚函数标记为 `inline`，编译器会忽略内联标记，并将其视为普通的虚函数。

需要注意的是，即使不能将虚函数声明为内联函数，编译器仍然可以选择在适当的情况下优化虚函数的调用，比如使用虚函数表进行间接调用。

如果您需要在类定义中定义函数并希望对其进行内联优化，而该函数不涉及动态绑定，可以将其声明为普通的非虚函数，并在类定义中将其定义为内联函数。



**5.静态成员可以是虚函数吗？答：不能，因为静态成员函数没有this指针，使用类型::成员函数的调用方式无法访问虚函数表，所以静态成员函数无法放进虚函数**

**表。**

答：

静态成员函数不能声明为虚函数。

虚函数是用于实现运行时的动态绑定（动态分派），而静态成员函数不属于任何对象或实例，它们是属于整个类的。静态成员函数在编译时就被解析和绑定，而不

是在运行时根据对象类型进行动态绑定。因此，static 成员函数不能被声明为虚函数。

虚函数需要通过对象的实际类型来选择合适的函数版本，而静态成员函数没有对象实例与之关联，所以无法使用动态绑定的机制。

然而，可以通过静态成员函数调用非静态成员函数，进而使用非静态成员函数的虚函数特性。因为非静态成员函数是与具体对象相关联的，可以根据对象类型进行

动态绑定。（解释：静态成员函数没有this指针，所以不能直接调用非静态成员函数，但是可以通过创建本类对象调用）（这个做法不提倡，对于虚函数来说即繁

琐，作用也不大）

```c++
#include <iostream>

using namespace std;

class MyClass {
public:
	static void staticFunc()
	{
		//nonStaticFunc();		//error，静态成员函数不能直接调用非静态成员函数，因为没有this指针

		MyClass obj;
		obj.nonStaticFunc();	//静态成员函数中创建本类对象调用非静态成员函数
	}

	void nonStaticFunc()
	{
		cout << "静态成员函数中创建本类对象调用非静态成员函数" << endl;
	}
};

int main()
{
	MyClass::staticFunc();
	//输出：
	//静态成员函数中创建本类对象调用非静态成员函数
	return 0;
}
```



```c++
#include <iostream>

using namespace std;

class Base
{
public:
	virtual void foo() 
	{
		cout << "Base::foo()" << endl;
	}
};

class Derived : public Base 
{
public:
	void foo() override 
	{
		cout << "Derived::foo()" << endl;
	}

	static void bar() 
	{
		//下面的做法不提倡，相当于突破语法限制去硬着做
		Derived obj;
		obj.foo();		//通过对象调用虚函数
	}
};

int main() 
{
	Derived::bar();		//输出：Derived::foo()
	return 0;
}
```

在上述示例中，静态成员函数 `bar()` 内部创建了一个 `Derived` 类的对象 `obj`，然后通过对象调用非静态成员函数 `foo()`，从而实现了使用虚函数的效果。

总结，静态成员函数不能声明为虚函数。虚函数是用于实现运行时的动态绑定，而静态成员函数没有对象实例与之关联，无法使用动态绑定的机制。但可以通过静

态成员函数中示例本类对象来间接调用非静态成员函数来使用虚函数的特性。



**6.构造函数可以是虚函数吗？答：不能，因为对象中的虚函数表指针是在构造函数初始化列表阶段才初始化的。**

答：

构造函数不能声明为虚函数。

在 C++ 中，虚函数用于实现运行时的动态绑定（动态分派）。但是，在对象被创建的过程中，构造函数负责初始化对象，因此在对象创建之前，无法确定对象的

类型，无法进行动态绑定。

当我们通过创建一个新对象或派生类对象时，编译器会自动调用相应的构造函数来初始化对象。构造函数在编译期间就被确定，而不是在运行时根据对象类型进行

动态绑定。因此，构造函数不能被声明为虚函数。

虚函数的关键特性是在运行时根据对象的实际类型来选择正确的函数版本，但在构造函数执行期间，对象的类型尚未完全确定，因此无法使用虚函数的动态绑定机

制。

需要注意的是，析构函数可以是虚函数。因为在对象销毁时，可以根据对象的实际类型调用适当的析构函数实现多态性。



**7.析构函数可以是虚函数吗？什么场景下析构函数是虚函数？答：可以，并且最好把基类的析构函数定义成虚函数。参考本节课件内容**

答：

析构函数可以是虚函数，当派生类有自己的资源的时候需要正确调用派生类的析构函数释放资源。

在面向对象编程中，当一个基类指针或引用指向一个派生类对象时，如果基类的析构函数不是虚函数，那么当通过基类指针或引用删除对象时，只会调用到基类的

析构函数，而不会调用到派生类的析构函数。这可能导致派生类的资源没有被正确释放，造成内存泄漏或其他问题。

通过将基类的析构函数声明为虚函数，可以解决上述问题。当基类的析构函数是虚函数时，当通过基类指针或引用删除对象时，会自动调用到实际对象的析构函

数，从而保证了派生类的析构函数能够被正确调用。

以下是一个简单的示例说明虚析构函数的作用：

```c++
#include <iostream>

using namespace std;

// 基类
class Base 
{
public:
    virtual ~Base()
    { 
    	// 虚析构函数
        cout << "Base destructor" << endl;
    }
};

// 派生类
class Derived : public Base 
{
public:
    ~Derived()
    { 
    	// 派生类的析构函数
        cout << "Derived destructor" << endl;
    }
};

int main() 
{
    Base* basePtr = new Derived();

    delete basePtr;
    
    return 0;
}
```

在上述代码中，`Base` 是基类，`Derived` 是派生类。当创建一个 `Derived` 类的对象，并用基类指针 `basePtr` 指向该对象时，如果基类的析构函数不是虚函数，

那么通过 `delete basePtr` 删除对象时，只会调用到 `Base` 的析构函数，而不会调用到 `Derived` 的析构函数。

但是当将基类的析构函数声明为虚函数时，通过 `delete basePtr` 删除对象时，会先调用 `Derived` 的析构函数再调用 `Base` 的析构函数，从而正确释放派生类的

资源。

因此，在使用多态性时，需要将基类的析构函数声明为虚函数，以确保通过基类指针或引用删除对象时能够正确调用到派生类的析构函数。

对于编译器来说，基类和派生类的析构函数在函数名上是相同的。



**8.对象访问普通函数快还是虚函数更快？答：首先如果是普通对象，是一样快的。如果是指针对象或者是引用对象，则调用的普通函数快，因为构成多态，运行时**

**调用虚函数需要到虚函数表中去查找。**

答：

在对象访问函数的性能方面，通常普通函数比虚函数更快。

普通函数的调用是静态绑定（或静态分派），在编译时就可以确定要调用的具体函数。这意味着编译器可以直接生成对应的函数调用代码，效率很高。

而虚函数的调用是动态绑定（或动态分派），在运行时根据对象的实际类型来确定要调用的函数。为了实现动态绑定，每个类都会有一个虚函数表（vtable），需

要在运行时进行查找和解析。这个过程包含了额外的开销，可能会导致一定的性能损失。

需要注意的是，虚函数通常被用于实现多态性，使得在基类指针或引用下使用派生类的特定实现。虽然虚函数的调用可能更慢，但它提供了更灵活的设计和扩展

性。

在实际应用中，性能差异取决于具体的场景和要求。如果程序对性能要求非常高，且不需要多态性的特性，那么使用普通函数可能更好。如果程序需要多态性，可

以通过虚函数来实现更灵活的设计，尽管会带来一些性能损失。

总结起来，普通函数的调用比虚函数更快，但虚函数提供了多态性的特性。在选择函数的类型时，需要根据具体情况考虑性能和设计的权衡。



对于普通对象（非指针对象或引用对象），在访问普通函数和虚函数时，它们的速度是相同的。这是因为普通对象的类型在编译时就确定了，编译器可以直接调用

该对象对应的函数，不需要进行运行时的查找。

然而，当使用指针对象或引用对象时，情况就不同了。在这种情况下，如果调用的是普通函数，编译器会根据指针或引用的静态类型来确定要调用的函数，不涉及

运行时的查找。这个过程更加高效。

相比之下，如果调用的是虚函数，编译器需要在运行时通过虚函数表进行查找，以确定要调用的实际函数。这个过程需要额外的开销，因此相对来说会慢一些。

总结起来，对于普通对象，访问普通函数和虚函数的速度是相同的。但对于指针对象或引用对象，访问普通函数会更快，因为不需要进行运行时的查找。然而，这

种差异通常是微小的，并且在大多数情况下可以忽略不计。优化代码性能时，应当根据具体情况进行评估和选择。



**9.虚函数表是在什么阶段生成的，存在哪的？答：虚函数表是在编译阶段就生成的，一般情况下存在代码段(常量区)的。**

答：

虚函数表（Virtual Function Table）是在编译阶段生成的，存储在每个类的只读数据区域。

虚函数表是用于实现动态绑定的机制。当一个类声明了虚函数时，编译器会为该类产生一个虚函数表，其中包含了该类及其基类的虚函数指针。虚函数表是一个数

组，每个元素都是指向虚函数的指针。

对于每个类对象，编译器会在对象中添加一个指向对应虚函数表的指针，通常称为虚函数表指针（vfptr）。这个指针指向该对象所属类的虚函数表。通过虚函数指

针，在运行时可以根据对象的实际类型来进行函数调用，实现动态绑定。

虚函数表的生成是在编译阶段完成的，随着类的定义和编译一起进行。它存在于只读数据区域，因此在程序执行期间是不可修改的。

需要注意的是，不同编译器可能在虚函数表的实现上有所区别，但基本原理是相同的。这些细节对于开发者来说是透明的，我们只需要了解虚函数表的作用和使用

方式即可。



只读数据区是在代码段，只读数据区通常是指存储在程序的代码段（也称为文本段）中的数据。代码段是一个特殊的内存区域，用于存储程序的指令和常量数据。

在代码段中，程序的指令以二进制形式存储，这部分内存是只读的，因为它包含了程序的执行指令，不允许被修改。而只读数据，例如常量、静态变量等，也通常

存储在代码段中。对于只读数据区，程序可以读取其中的数据，但不能对其进行写操作。这确保了存储在代码段中的数据在程序执行期间保持不变，提高了程序的

安全性和可靠性。需要注意的是，不同的操作系统和编译器可能会有不同的内存布局和段结构，因此具体的实现方式可能会有所差异。然而，通常情况下，只读数

据区是位于代码段中的。

代码段和文本段实际上是指同一个概念。它们都指代存储程序指令的内存区域。

在操作系统中，内存被划分为不同的段（segments），其中之一就是代码段或文本段（Code Segment/Text Segment）。这个段用于存储程序的机器指令，也就

是所谓的代码或文本。代码段通常是只读的，因为程序在运行时不应该被修改。

有些操作系统和编译器使用术语代码段（Code Segment）来描述这个内存区域，而另一些使用术语文本段（Text Segment）。两者的含义是相同的，只是命名不

同而已。

所以，代码段和文本段是同一个概念的不同名称，用来表示存储程序指令的内存区域。



**10.C++菱形继承的问题？虚继承的原理？**

答：

C++中的菱形继承是指一个派生类同时继承了两个直接或间接基类，而这两个基类又共同继承了同一个基类的情况。这种继承关系形成了一个菱形形状，因此也称

为菱形继承问题。

下面以代码示例来说明菱形继承的问题：

```c++
#include <iostream>

using namespace std;

class Base 
{
public:
    int baseData;
};

class Derived1 : public Base 
{
public:
    int derived1Data;
};

class Derived2 : public Base 
{
public:
    int derived2Data;
};

class Derived3 : public Derived1, public Derived2 
{
public:
    int derived3Data;
};

int main() 
{
    Derived3 d3;
    d3.derived1Data = 10;
    d3.derived2Data = 20;
    // d3.baseData = 77;   // 编译错误，无法确定访问哪个基类的baseData
    return 0;
}
```

在上述代码中，类 `Derived1` 和类 `Derived2` 都直接继承了类 `Base`，而类 `Derived3` 继承了 `Derived1` 和 `Derived2`。这就形成了一个菱形继承结构。

菱形继承会引发以下问题：

1. 冗余数据：由于 `Derived3` 继承了两个基类，它会拥有两份 `baseData` 的副本，导致内存空间的浪费。
2. 二义性：当访问 `Derived3` 中的成员时，比如访问 `baseData`，由于无法确定具体是从哪个基类继承的，因此会导致编译错误。

为了解决菱形继承问题，C++提供了虚继承（virtual inheritance）的机制。虚继承可以用来消除菱形继承带来的二义性和冗余数据。

虚继承的原理是通过在派生类中嵌入一个虚基类指针（vptr），指向实际存储虚基类对象的位置。这样，所有共享同一个虚基类的派生类都会使用同一个虚基类对

象，避免了冗余数据的产生。

以下是修改后的示例代码，使用虚继承解决了菱形继承问题：

```c++
#include <iostream>

using namespace std;

class Base 
{
public:
    int baseData;
};

class Derived1 : virtual public Base 
{
public:
    int derived1Data;
};

class Derived2 : virtual public Base 
{
public:
    int derived2Data;
};

class Derived3 : public Derived1, public Derived2 
{
public:
    int derived3Data;
};

int main() 
{
    Derived3 d3;
    d3.derived1Data = 10;
    d3.derived2Data = 20;
    d3.baseData = 30;   	//正常访问基类的baseData
    cout << d3.baseData << endl;  // 输出:30
    return 0;
}
```

在上述代码中，通过在基类 `Base` 的继承修饰符前添加 `virtual` 关键字，实现了虚继承。派生类 `Derived1` 和 `Derived2` 都使用了虚继承，从而解决了菱形继承

问题。这样，`Derived3` 可以正常访问基类 `Base` 中的成员。

通过虚继承，可以确保菱形继承问题不再存在，并且避免了冗余数据的产生。



**11.什么是抽象类？抽象类的作用？答：抽象类强制重写了虚函数，另外抽象类体现出了接口继承关系。**  

答：

抽象类是在面向对象编程中的概念，它是不能被实例化的类，只能被用作其他类的基类。抽象类通常用于定义一组相关的类所共有的行为、属性和方法，但它本身

并不完整，需要子类来实现其中的具体细节。

抽象类的作用是通过提供一个公共接口，约束继承它的子类必须实现特定的方法或拥有特定的属性。它主要有以下几个作用：

1. 定义和封装通用行为：抽象类可以定义一组共享的方法，这些方法在多个子类中都有相似的实现。通过将这些通用行为封装在抽象类中，可以避免在每个子类

   中重复编写相同的代码，提高代码的可维护性和复用性。

2. 规范子类的结构和行为：抽象类可以定义一组抽象方法，这些方法只有方法签名而没有具体实现。子类必须实现这些抽象方法才能正常编译和运行。通过这种

   方式，抽象类可以规范子类的结构和行为，确保子类具有特定的功能。

3. 实现多态性：抽象类可以用作多态性的实现方式。通过将抽象类作为参数类型或返回值类型，可以统一处理不同子类的对象，并根据实际类型来调用相应的实现逻辑。

需要注意的是，抽象类本身不能被实例化，即不能创建抽象类的对象。只能通过继承抽象类并实现其中的抽象方法，创建具体子类的对象。

以下是一个简单的抽象类的示例：

```c++
#include <iostream>

using namespace std;

// 抽象类
class Animal 
{
public:
    virtual void speak() = 0;  // 纯虚函数，没有具体实现
};

// 具体子类
class Cat : public Animal 
{
public:
    void speak() 
    {
        cout << "Meow!" << endl;
    }
};

// 具体子类
class Dog : public Animal 
{
public:
    void speak() 
    {
        cout << "Woof!" << endl;
    }
};

int main() {
    Cat cat;
    cat.speak();  // 输出: Meow!

    Dog dog;
    dog.speak();  // 输出: Woof!

    return 0;
}
```

在上述代码中，`Animal` 是一个抽象类，其中声明了一个纯虚函数 `speak()`，它没有具体的实现。子类 `Cat` 和 `Dog` 继承自 `Animal`，并实现了 `speak()` 方法。

通过创建具体子类的对象，可以调用相应的方法。

总结来说，抽象类是为了定义和封装通用行为、规范子类的结构和行为，并实现多态性。它是面向对象编程中的重要概念，用于提供一种约定和规范，使得代码更

加灵活、可维护和可扩展。