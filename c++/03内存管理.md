# 1.内存分布

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

//内存分布区
int globalVar = 1;	//全局数据段
static int staticGlobalVar = 1;	//数据段

int main()
{
	static int staticVar = 1;	//数据段，数据段包括了全局数据段和静态数据
	int localVar = 1;	//栈
	int num1[10] = { 1, 2, 3, 4 };	//栈
	char char2[] = "abcdef";	//字符数组，char2在栈上，右边"abcd"是常量字符串，在代码段，这句话是把常量字符串复制之后放到数组中了，char2在栈上，*char也在栈上
	const char* pChar3 = "abcde";	//不能使用char*，pChar3在栈上，指向常量字符串"abcd"，*pChar3在代码段上
	int* ptr1 = (int*)malloc(sizeof(int) * 4);	//ptr1在栈上，右边开辟的空间在堆上，ptr1在栈上，指向堆，*ptr1是在堆上
	int* ptr2 = (int*)calloc(4, sizeof(int));
	int* ptr3 = (int*)realloc(ptr2, sizeof(int) * 4);
	cout << sizeof(num1) << endl;	//40
	cout << sizeof(char2) << endl;	//7	有7个元素，后面有个'\0'
	cout << sizeof(pChar3) << endl;	//4/8	是一个指针，32位为4个字节，64位为8个字节
	cout << sizeof(ptr1) << endl;	//4/8	是一个指针
	cout << strlen(char2) << endl;	//6	关注'\0'的位置
	cout << strlen(pChar3) << endl;	//5
	free(ptr1);
	free(ptr3);
	return 0;
}
```

![image-20230609220955013](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230609220955013.png)

C/C++内存分布（从高地址到低地址）：

1.内核空间（用户代码不可读写）；

2.栈（向下增长）：又叫堆栈，非静态局部变量、函数参数和返回值等等，栈是向下增长的；

3.内存映射段（文本映射、动态库、匿名映射）：是高效的I/O映射方式，用于装载一个共享的动态内存库（共享内存在这里）。 

用户可使用系统接口创建共享内存，做进程间通信；

4.堆（向上增长）：用于程序运行时动态内存分配，堆是可以向上增长的；

5.数据段（全局数据、静态数据）：存储全局数据和静态数据；

6.代码段（可执行代码、只读常量）：可执行的代码、只读常量、字符串常量；

```c++
//申请2G的内存和4G的内存
void test2()
{
	char*ptr = (char*)malloc(0x7fffffff);	//申请2个G的空间
	char*ptr = (char*)malloc(0Xffffffff);	//申请4个G的空间，在32位操作系统中会报错
}
//申请空间系统有个限制（32位最多2G，64位可以超过2G），语言也有一个内存的最高限制。
```



# 2.c语言中动态内存管理方式

## 2.1malloc

向内存申请一块连续的空间，申请成功了返回这块空间的地址，失败了返回NULL。

```c++
//函数原型：void* malloc (size_t size);
int* ptr = (int*)malloc(10 * sizeof(int));  //ptr就是申请空间的首地址
```

注意点：

1.**对malloc申请的空间要进行检查,因为有可能申请失败；**

2.**malloc的返回值类型是void*，因为malloc函数并不知道需要开辟的空间的类型，所以在具体使用的时候要进行强转；**



## 2.2calloc

calloc 和 malloc 的使用方法一样，但是 **calloc 会把空间里的数据全部初始化为0，malloc是随机值**。

```c++
//函数原型：void* calloc (size_t num, size_t size);
int* ptr = (int*)calloc(10，sizeof(int));  //ptr就是申请空间的首地址
```



## 2.3realloc

调整已开辟的动态空间的大小，可以扩充，也可以缩小。

```c++
//函数原型：void* realloc(void* ptr, size_t size);  //ptr：要调整的空间  size：新的空间的大小  
int* p2 = (int*)calloc(4, sizeof (int));
int* p3 = (int*)realloc(p2, sizeof(int)*10);	//这里的p2不用释放，只需要释放p3，在扩充的时候编译器会自动释放p2的空间
//当realloc的第一个参数为NULL时，realloc当做malloc使用，相当于创建一块空间；
int* ptr = (int*)realloc(NULL, sizeof(int)*10);
//上面的realloc等价于下面的malloc
int* ptr = (int*)malloc(10 * sizeof(int)); 
```

返回值用新空间的首地址接收，在调整空间大小的时候会把原来空间的内容拷贝到新空间里，还会释放原来的空间。

扩充空间的两种可能性：

1.原始空间的后面有足够的空间让我们申请，就会直接在后面追加空间，原来空间不发生变化；

2.原始空间的后面没有足够的空间让我们申请，这时realloc函数就会在堆空间上找一个合适大小的连续空间来使用，这样函数返回的是一个新的内存地址；

注意点：新创建的地址可能会失败，要判断新的空间创建成功没，成功了赋给原空间地址，防止原空间丢失，造成内存泄漏；



## 2.4malloc、calloc、realloc的区别

1.malloc：在堆上申请一块内存，不会初始化；

2.calloc：在堆上申请一块内存，初始化为0；

3.realloc：对存在的内存空间进行扩容或者缩减，在扩容的时候编译器会做一些处理（要是原先空间后面连续的空间不够，在堆上会开辟一块新的空间，将原先空间的数据拷贝到新的空间，释放原来的空间），手动free的时候只用释放新的空间，不用释放原来的空间。



## 2.5free

进行内存的释放。

free(开辟空间的首地址);  

为啥要进行free操作：避免内存的泄漏，因为有的程序要一直运行，比如阿里云服务器。

```c++
//函数原型：void free (void* ptr);
int* ptr = (int*)malloc(sizeof(int) * 10);
free(ptr);

//特例：
void* a = (void*)10;  
free(a);  
//解释：可以传不是动态开辟的空间，但是free函数啥也不做；  
//备注：这个不要尝试，会造成程序奔溃。
```



# 3.c++内存管理方式

C语言内存管理方式在C++中可以继续使用，但有些地方无能为力而且使用起来比较麻烦，所以C++提出了自己的内存管理方式。

**C++中通过new 和 delete操作符进行动态内存管理。**

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

int main()
{
	//内置类型:
	//动态申请一个int类型的空间
	int* ptr = new int;
	//动态申请一个int类型的空间并初始化为10
	int* ptr1 = new int(10);
	//动态申请10个int类型的空间
	int *ptr2 = new int[10];
	cout << *ptr << endl;   //没有初始化的初始值都一样
	cout << *ptr1 << endl;	//10
	cout << *ptr2 << endl;
	delete ptr;
	delete ptr1;
	delete[] ptr2;
	//申请和释放的时候new[]和delete[]都在一起
	return 0;
}
//输出结果：
//-842150451
//10
//-842150451
```

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

//自定义类型
class Test
{
public:
	Test()
		:_data(0)
	{
		cout << "Test():" << this << endl;
	}

	~Test()
	{
		cout << "~Test():" << this << endl;
	}

private:
	int _data;
};

int main()
{
	//申请的那个Test类型的空间
	Test* ptr = new Test;	//自定义类型：new 申请空间 + 调用构造函数进行空间内容的初始化
	delete ptr;				//自定义类型：delete 析构函数清理资源（比如顺序表） + 对象空间释放（4个字节）
	//申请10个Test类型的对象
	Test* p2 = new Test[10];	//不能使用带参的构造函数连续初始化Test* p2 = new Test[10](3);	是错的	
	delete[] p2;				
	return 0;
}

//输出结果，数组中最后一个调用构造函数的，第一个被析构
Test():0078DA00
~Test():0078DA00
Test():0078DA04
Test():0078DA08
Test():0078DA0C
Test():0078DA10
Test():0078DA14
Test():0078DA18
Test():0078DA1C
Test():0078DA20
Test():0078DA24
Test():0078DA28
~Test():0078DA28
~Test():0078DA24
~Test():0078DA20
~Test():0078DA1C
~Test():0078DA18
~Test():0078DA14
~Test():0078DA10
~Test():0078DA0C
~Test():0078DA08
~Test():0078DA04
```

注意：**申请和释放单个元素的空间，使用new和delete操作符，申请和释放连续的空间，使用new[]和delete[]。**  

注意：**在申请自定义类型的空间时，new会调用构造函数，delete会调用析构函数，而malloc和free不会。**



# 4.operator new和operator delete函数（重点）

operator new函数原型：void* operator new(size_t n);

operator new 不是 new 的运算符重载函数。	

operator delete函数原型：void operator delete(void* ptr);

operator delete 不是 delete 的运算符重载函数。

**new和delete是用户进行动态内存申请和释放的操作符，operator new和operator delete是系统提供的全局函数，new在底层调用operator new全局函数来申请空间，delete在底层通过调用operator delete全局函数来释放空间；**

operator new：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回，申请空间失败尝试执行

空间不足应对措施； 

如果该应对措施用户设置了，则继续申请，否则抛异常；（比如malloc申请内存失败了，这里会抛出bad_alloc类型异常）；

operator delete：该函数最终是free来释放空间的；

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

int main()
{
	//operator new使用很像malloc，operator delete使用很像free
	//operator new 是 malloc + 异常
	int* ptr = (int*)operator new(sizeof(int));		//失败了抛出异常
	int* ptr2 = (int*)malloc(sizeof(int));			//失败了返回指针空值

	operator delete(ptr);
	free(ptr2);
    return 0;
}
```

内置类型：

new调用operator new全局函数，operator new调用malloc；

delete调用operator delete全局函数，operator delete调用free；

new[]调用operator new[]，operator new[]调用operator new，operator new调用malloc；

delete[]调用operator delete[]，operator delete[]调用operator delete，operator delete调用free；

自定义类型：

new调用operator new全局函数，operator new调用malloc函数，malloc调用构造函数；

delete调用析构函数，析构函数调用operator delete全局函数，operator delete调用free函数；

new[]调用operator new[]全局函数，operator new[]调用operator new，operator new调用malloc函数，之后调用构造函数初始化对象；

delete[]调用n次析构函数清理资源，再调用operator delete[]全局函数，operator delete[]调用operator delete，operator delete调用free函数；



## 4.1重载类专属operator new/operator delete + 内存池

下面代码演示了，针对链表的节点ListNode通过**重载类专属** **operator new/ operator delete**，实现链表节点使用内存池申请和释放内存，提高效率。

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

struct ListNode
{
	ListNode* _next;
	ListNode* _prev;
	int _data;
    
	void* operator new(size_t n)
	{
		void* p = nullptr;
		p = allocator<ListNode>().allocate(1);
		cout << "memory pool allocate" << endl;
		return p;
	}
    
	void operator delete(void* p)
	{
		allocator<ListNode>().deallocate((ListNode*)p, 1);
		cout << "memory pool deallocate" << endl;
	}
};

class List
{
public:
	List()
	{
		_head = new ListNode;
		_head->_next = _head;
		_head->_prev = _head;
	}
    
	~List()
	{
		ListNode* cur = _head->_next;
		while (cur != _head)
		{
			ListNode* next = cur->_next;
			delete cur;
			cur = next;
		}
		delete _head;
		_head = nullptr;
	}
    
private:
	ListNode* _head;
};

int main()
{
	List l;
	return 0;
	//输出:
	//memory pool allocate			内存池分配
	//memory pool deallocate		内存池释放
}
```

就是针对某种数据结构类型（比如链表），针对链表的节点重载operator new和operator delete， 实现链表节点

使用内存池申请（先申请一大块空间）和释放内存，提高效率；



解释上面的代码的执行过程：

构造函数的时候是如何分配内存的？

答：在构造函数中，分配内存是通过调用 `operator new` 运算符来完成的。具体的步骤如下：

1. 在 `List` 的构造函数中，创建了一个头结点 `_head`，并将其的 `_next` 和 `_prev` 指针都指向自己，形成一个空链表。
2. 当创建头结点时，会自动调用 `operator new` 运算符来分配内存。
3. 在节点的重载 `operator new` 中，通过调用 `allocator<ListNode>().allocate(1)` 从内存池中分配一个 `ListNode` 的内存块。
4. `allocate(1)` 表示只分配一个 `ListNode` 大小的内存块。
5. `allocate` 函数会返回一个指向分配到的内存块的指针，并将内存块的大小记录在内存块的前几个字节中，以便在释放内存时知道要释放的内存大小。
6. 分配到的内存块的指针会赋值给 `_head`，使得 `_head` 成为一个指向新分配内存的指针。

总结起来，构造函数中的内存分配过程是通过调用 `operator new` 运算符，在内存池中分配了一个 `ListNode` 大

小的内存块，并将其指针赋值给 `_head`。这样就完成了头结点的内存分配。



析构函数的时候是如何释放内存的？

在析构函数中，释放内存是通过调用 `operator delete` 运算符来完成的。具体的步骤如下：

1. 在 `List` 的析构函数中，从头结点的 `_next` 指针开始，依次删除链表中的所有节点。
2. 对于每个节点的删除操作，会先保存下一个节点的指针，然后调用 `delete` 运算符释放当前节点的内存。
3. 在节点的重载 `operator delete` 中，会调用 `allocator<ListNode>().deallocate((ListNode*)p, 1)` 将节点的内存归还给内存池。
4. `deallocate((ListNode*)p, 1)` 表示将指针 `p` 指向的内存块大小为 1 的 `ListNode` 类型内存块归还给内存池。
5. `deallocate` 函数会将该内存块标记为空闲状态，以便下次分配内存时可以重新使用。

综上所述，析构函数中的内存释放过程是通过调用 `delete` 运算符删除节点，并在节点的重载 `operator delete` 中调用 `deallocate` 函数将节点的内存归还给内存池。这样就完成了链表中所有节点的内存释放。



# 5.new和delete的实现原理

1.内置类型：如果申请的是内置类型的空间，new和malloc，delete和free基本类似，不同的地方是：new/delete

申请和释放的是单个元素的空间，new[]和delete[]申请和释放的是连续空间，**而且new在申请空间失败时会抛异**

**常，malloc会返回NULL**。

2.自定义类型：

new的原理：调用operator new函数申请空间，在申请的空间上执行构造函数，完成对象的构造；

delete的原理：在空间上执行析构函数，完成对象中资源的清理工作，调用operator delete函数释放对象的空

间；

new T[N]的原理：调用operator new[]函数，在operator new[]中实际调用operator new函数在申请的空间上执

行N次构造函数；

delete[]的原理：在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理，调用operator delete[]释放

空间，实际在operator delete[]中调用operator delete来释放空间； 



# 6.定位new表达式（placement-new）（了解）

定位new表达式可以显示调用构造函数。

定位new表达式是在已分配的原始空间内存中调用构造函数初始化一个对象；

使用格式：new(place_address) type或者new(place_address)  type(initialazer-list)。place_address必须是一个

指针，initialazer-list是类型的初始化列表。

定位new表达式的使用场景：定位new表达式在实际中一般是配合内存池使用。因为内存池分配出的内存没有初始

化，所以如果是自定义类型的对象，需要使用new的定义表达式进行显示调构造函数进行初始化。

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <assert.h>

using namespace std;

//定位new表达式
class Test
{
public:
	Test()
		: _data(0)
	{
		cout << "Test():" << this << endl;
	}

	~Test()
	{
		cout << "~Test():" << this << endl;
	}

private:
	int _data;
};

int main()
{
	//pt现在指向的只不过是与Test对象相同大小的一段空间，还不能算是一个对象，因为构造函数没有执行
	Test* pt = (Test*)malloc(sizeof(Test));
	new(pt) Test; //注意：如果Test类的构造函数有参数时，此处需要传参
	//new定位表达式：new(指针) 类型(参数列表（可选）)	new(pt) Test(10);
	//delete pt;		//下面两步合起来就是delete
	pt->~Test();	//释放空间之前显示调用析构函数清理资源
	free(pt);		//释放空间
	return 0;
	//输出结果：
	//Test():00C99A80
	//~Test() :00C99A80
}
```



# 7.malloc/free和new/delete的区别

共同点：malloc/free和new/delete的共同点是：都是从堆上申请空间，并且需要用户手动释放。  

不同点：

1.malloc和free是函数，new和delete是操作符；

2.malloc申请的空间不会初始化，new可以初始化；

3.malloc申请空间时，需要手动计算空间大小并传递，new只需在其后面跟上空间的类型即可；

4.**malloc的返回值为void*，在使用时必须强转，new不需要，因为new是操作符（new是关键字），new后跟的是空间的类型；**

5.malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常；

6.申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数和析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理。



补充：

## 7.1关键字和操作符的区别？

在C++中，并不是所有的操作符都是关键字。关键字通常指那些由编程语言定义并具有固定含义的单词，例如 

`if`、`else`、`for`、`class`等等，它们用于表示特定的语法结构或者具有特定的含义。

与此不同，操作符是一种特殊的符号或字符串，用于表示一种特定的运算或操作，例如 `+`、`-`、`*`、`/`、`=`、

`==`、`<`、`>`等等。在C++中，操作符并不是关键字，而是由编译器预定义并赋予特定功能的。

回到最开始的问题，**`new` 既是操作符，又是关键字。**作为操作符，它用于在堆上动态分配内存。作为关键字，它

表示创建对象并返回该对象的指针。



# 8.什么是内存泄漏，内存泄漏的危害

什么是内存泄漏：内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不是指内

存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的

浪费。

内存泄漏的危害：长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会导致响

应越来越慢，最终卡死。

```c++
int main()
{
	//1.内存申请了忘记释放
	int* p1 = (int*)malloc(sizeof(int));
	int* p2 = new int;
	//2.异常安全问题
	int* p3 = new int[10];
	Func(); //这里Func函数抛异常导致 delete[] p3未执行，p3没被释放.
	delete[] p3;
	return 0;
}
```



# 9.内存泄漏分类（了解）

C/C++程序中一般我们关心两种方面的内存泄漏：

1.堆内存泄漏（Heap leak）：堆内存指的是程序执行中依据须要分配通过malloc / calloc / realloc / new等从堆中

分配的一块内存，用完后必须通过调用相应的free或者delete 删掉。假设程序的设计错误导致这部分内存没有被

释放，那么以后这部分空间将无法再被使用，就会产生Heap Leak。

2.系统资源泄漏：指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导

致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。



# 10.如何检测内存泄漏

1.在linux下检测内存泄漏：https://blog.csdn.net/gatieme/article/details/51959654

2.在windows下检测内存泄漏：https://blog.csdn.net/GZrhaunt/article/details/56839765

3.其他内存检测工具比较：https://www.cnblogs.com/liangxiaofeng/p/4318499.html



# 11.如何避免内存泄漏

1.工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。ps：这个理想状态。但是

如果碰上异常时，就算注意释放了，还是可能会出问题。需要下一条智能指针来管理才有保证；

2.采用RAII思想或者智能指针来管理资源；

3.有些公司内部规范使用内部实现的私有内存管理库。这套库自带内存泄漏检测的功能选项；

4.出问题了使用内存泄漏工具检测。ps：不过很多工具都不够靠谱，或者收费昂贵。

总结：内存泄漏非常常见，解决方案分为两种：

1.事前预防型。如智能指针等；

2.事后查错型。如内存泄漏检测工具。  



# 12.如何一次在堆上申请4G内存

```c++
//在堆上一次申请4G内部（64位操作系统才可以，32位操作系统不行）
void test8()
{
	void* p = new char[0xfffffffful];		//32位下数组的总大小不得超过0x7fffffff，只能在64位下申请4G内存 
	cout << "new:" << p << endl;
}
```