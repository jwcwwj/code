# 1.继承

## 1.1继承方式

public（用的最多）

private

protected

父类私有的成员在子类中不可见。

## 1.2成员访问权限

public继承：从父类继承的成员权限不变。

protected继承：父类的的public成员变成子类protected成员，其它成员权限不变。

private继承：父类的的public、protected成员变成子类private成员，其它成员权限不变。

总结：取继承方式和成员属性最小的。（由大到小：public  ->  protected  ->  private）

## 1.3切片

切片操作：子类的对象、指针、引用赋值给父类的对象、指针、引用。

父类对象不能赋值给子类对象。



父类的指针、引用通过强制转换可以赋值给子类的指针、引用，但是不安全，有访问越界的问题。

父类的指针和引用不能直接赋值给子类的指针和引用，有两种方式：

1.强制类型转换：父类的引用转成子类的引用，父类的指针转成子类的指针。

2.使用智能指针static_cast转换。

两种方法都不是安全的。

在多态中可以使用动态转换（dynamic_cast），是安全的，静态转换是不安全的。

正确使用动态转换（dynamic_cast）是安全的，一般在多态中使用。

## 1.4成员函数

## 1.4.1构造

子类自动调用父类构造（初始化列表），完成父类成员的初始化。

### 1.4.2拷贝构造

子类的默认拷贝构造自动调用父类的拷贝构造（初始化列表），完成父类成员的初始化。

子类的自定义拷贝构造自动调用父类的默认拷贝构造函数，除非显示指定调用拷贝构造。

### 1.4.3赋值运算符

子类的默认赋值运算符自动调用父类的赋值运算符。

子类的自定义赋值运算符不会自动调用父类的赋值运算符。

### 1.4.4析构

任何情况下子类析构都会自动调用父类的析构。

## 1.5友元

父类的友元不能传递 ，不能作为子类的友元（友元关系不能继承）。

## 1.6static

static成员整个继承体系中全局唯一。

## 1.7菱形继承

多继承的一种。

缺陷：二义性、数据冗余。

虚拟继承：		

​	虚基表：存放当前位置相对于公共父类成员的偏移量。

​	虚基表指针：存放在对象模型中，直接父类的第一个成员。

# 2.多态

## 2.1实现多态	

前提：继承。

调用函数的类型为指针或引用。

被调用的函数为虚函数，虚函数被覆盖/重写。

## 2.2函数覆盖/重写

存在于继承中，父类子类中函数都为虚函数，函数的接口完全一致（函数名、参数、返回值（协变除外））

协变：返回值构造父子关系的指针或者引用。

## 2.3函数隐藏/重定义

存在于继承中，函数名相同构成隐藏。

函数覆盖是虚函数，函数隐藏是普通函数。

## 2.4抽象类

包含纯虚函数的类。

纯虚函数：virtual 函数名 = 0;

接口继承。

不能实例化。

纯虚函数 + 子类的override声明 = 实现多态。（override关键字作用是强制重写）

## 2.5底层实现

### 2.5.1虚表

函数指针数组。

存放：虚函数指针。

子类的重写虚函数可以覆盖父类的对应函数指针。

根据具体的对象的虚表（虚函数表）访问不同的函数实现多态。

单继承子类虚表：先存放父类的虚函数指针，子类新增的虚函数指针按照声明的顺序依次向后存放。



多继承子类虚表：

虚表数量和直接父类的数量相同。

子类新增的虚函数指针按照声明的顺序依次存放在第一个直接父类的虚表尾部。



多态：运行时候的多太爱。

函数重载：编译时候的多态。

### 2.5.2虚表指针

存放在对象的头部。

# 3.关联容器

## 3.1二叉搜索树

删除：分三种情况

1.叶子：直接删除，父亲的指向置空。

2.只有一个孩子：

左孩子：直接删除，父亲的指向为左孩子。

右孩子：直接删除，读取的指向为右孩子。

3.左右孩子都存在：

找到左子树的最右节点，当前节点和最右节点内容置换，删除交换后的最右节点。

找到右子树的最左节点，当前节点和最左节点内容置换，删除交换后的最左节点。

## 3.2AVL树

高度平衡的二叉搜索树，引入了平衡因子。

## 3.3红黑树

效率更高的AVL树，旋转的次数比较少。

实现map和set。

操作性能：插入、查找、删除：O(logN)。 

## 3.4哈希表

哈希表的插入、查找、删除操作的时间复杂度都是O(1)。

应用：位图和布隆过滤器。

































