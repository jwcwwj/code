项目名称：点餐系统。

项目描述：使用户可以通过浏览器访问服务器获取菜品信息并进行点餐；以及可以使管理员通过浏览访问服务器实现订单以及菜品的管理。

市场调研：整合所学知识；给毕设准备的项目；校内实训做的项目；

技术调研：线程、socket、http、json、mysql、stl

概要设计：框架的设计--不太严谨的MVC框架。

model：数据管理模块--管理数据（菜品、订单），外界想要访问数据必须通过这个模块完成，不能直接访问。

view：视图界面模块--浏览器前端界面，用户或者管理员的操作都是通过前端界面完成。

controller：业务控制模块--搭建服务器针对前端的请求进行对应业务处理。

![image-20231108133112201](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20231108133112201.png)

详细设计：

数据管理模块：

1.数据的存储：mysql数据库。

2.数据库表的设计：

菜品信息表：菜品ID、菜品名称、菜品单价、添加时间。

订单信息表：订单ID、订单菜品、订单状态、修改时间。

3.数据管理模块代码的设计：

菜品数据类：添加菜单、删除菜品、修改菜品、获取菜品（所有、单个）

订单数据类：添加订单、删除订单、修改订单（菜品、状态）、获取订单（所有、指定ID、复杂一点也可以指定状态）

业务控制模块：接收客户端请求，进行处理满足用户需求。

1.搭建服务器：HTTP服务器。（采用httplib库搭建）

2.通信接口设计：什么样的请求对应什么样的业务处理和响应。

​	2.1.静态页面请求：html页面。（以及依赖的css/js文件。）

index.html--菜品信息的展示以及下单界面。

GET /index.html HTTP/1.1			 

...										



HTTP/1.1 200 OK

Content-Type:text/html

Content-Length：文件长度



/index.html文件数据

​	2.2.动态数据请求：菜品数据、订单数据。

通信接口采用restful风格接口设计：

基于http协议，使用xml或者json格式定义正文序列化方式。

定义操作类型：新增-POST；删除-DELETE；修改-PUT；获取-GET

新增菜品：

POST/dish HTTP/1.1

...

\r\n

{"name":"红烧肉","price":2850}



HTTP/1.1 200 OK

...

HTTP/1.1 500

{result:false,reason:""}



删除菜品：

DELETE/dish/1 HTTP/1.1

...

\r\n



HTTP/1.1 200 OK



修改菜品：

PUT/dish/1 HTTP/1.1

...

\r\n

{name:"蚂蚁上树",price:38}



HTTP/1.1 200 OK



获取所有菜品：

GET /dish HTTP/1.1

...

\r\n



HTTP/1.1 200 OK

...

\r\n

[{id:1,name:"红烧肉",price:28},

{id:2,name:"盐煎肉",price:28}]



获取单个菜品：

GET /dish/1 HTTP/1.1



HTTP/1.1 200 OK

...

\r\n

{id:1,name:"红烧肉",price:28}



dish中文是菜，order中文是订单。

为什么选择mysql数据库？

答：免费的，mysql适用于简单业务，可以跨设备访问，不在一块主机上也可以访问数据库。oracle收费，免费的有好几种，比如sqlite，sqlite比较简单，sqlite是

本地用的数据库，只要包含sqlite库就能生成一个数据库在本地使用的，没有服务器，只能在本地访问，无法跨主机访问。



前端界面模块： html的编写渲染

实现：html+css+js	vue.js



mysql是线程安全的。



一个项目中的目录结构：

src：源码

lib：使用的静态库。

inc：静态库依赖的头文件。

etc：项目依赖的配置文件。

bin：最终生成的项目的二进制代码。

tmp：程序运行产生的临时文件。

test：测试代码。



环境搭建：

1.mysql服务安装。

2.gcc/g++升级。（httplib依赖高版本的gcc/g++。）

3.安装jsoncpp开发包

```shell
sudo apt install libjsoncpp-dev
```

jsoncpp基本应用认识：

1.Json::Value类：json与外界进行数据中转的一个对象类。

重载了大量的操作符：赋值运算符。

包含了大量的类型转换函数。

2.Json::Reader类：实现反序列化。

将json格式字符串转换为多个数据对象，存储在Json::Value对象中。

.parse(std::string& buf,Json::Value &val);	将buf反序列化存储到val中。

3.Json::Write类：实现序列化

基类-子类：Json::FastWrite / Json::StyledWrite

将Json::Value对象中的数据序列化成为json格式的字符串。

std::string write(Json::Value &val);

```cpp
//文件名：json.cpp
//第一种序列化
#include <iostream>
#include <string>
#include <jsoncpp/json/json.h>

//序列化    seria
void seria()
{
    const char* name = "张三";
    int id = 10001;
    const char* sex = "男";
    int score[3] = {88, 77, 99};

    Json::Value val;
    val["姓名"] = name;
    val["学号"] = id;
    val["性别"] = sex;
    for(int i = 0; i < 3; i++)
    {
        val["成绩"].append(score[i]);
    }

    Json::StyledWriter writer;
    std::cout << writer.write(val) << std::endl;
}

int main()
{
    seria();
    return 0;
}
```

```shell
#序列化
g++ -std=c++11 json.cpp -o json_test -ljsoncpp
```

或者makefile

```makefile
json_test:json.cpp
	g++ -std=c++11 $^ -o $@ -ljsoncpp
```

运行结果：

![image-20231108213247596](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20231108213247596.png)

```cpp
//第二种序列化
//文件名：json.cpp
#include <iostream>
#include <string>
#include <jsoncpp/json/json.h>

//序列化    seria
void seria()
{
    const char* name = "张三";
    int id = 10001;
    const char* sex = "男";
    int score[3] = {88, 77, 99};

    Json::Value val;
    val["姓名"] = name;
    val["学号"] = id;
    val["性别"] = sex;
    for(int i = 0; i < 3; i++)
    {
        val["成绩"].append(score[i]);
    }

    //Json::StyledWriter writer;
    Json::FastWriter writer;
    std::cout << writer.write(val) << std::endl;
}


int main()
{
    seria();
    return 0;
}
```

```makefile
json_test:json.cpp
	g++ -std=c++11 $^ -o $@ -ljsoncpp
```

运行结果：

![image-20231109132721822](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20231109132721822.png)

```c++
//反序列化
//文件名：json.cpp
#include <iostream>
#include <string>
#include <jsoncpp/json/json.h>

//序列化    seriastring seria()
std::string seria()
{
    const char* name = "张三";
    int id = 10001;
    const char* sex = "男";
    int score[3] = {88, 77, 99};

    Json::Value val;
    val["姓名"] = name;
    val["学号"] = id;
    val["性别"] = sex;
    for(int i = 0; i < 3; i++)
    {
        val["成绩"].append(score[i]);
    }

    //Json::StyledWriter writer;
    Json::FastWriter writer;
    std::string str = writer.write(val);
    std::cout << str << std::endl;
    return str;
}

//反序列化
void unseria(std::string &str)
{
    Json::Value val;
    Json::Reader reader;
    bool ret = reader.parse(str, val);
    if(ret == false)
    {
        std::cout << "parse json failed" << std::endl;
        return;
    }
    
    std::cout << val["姓名"].asString() << std::endl;
    std::cout << val["性别"].asString() << std::endl;
    std::cout << val["学号"].asInt() << std::endl;
    int num = val["成绩"].size();
    for(int i = 0; i < num; i++)
    {
        std::cout << val["成绩"][i].asInt() << std::endl;
    }
    return;
}

int main()
{
    std::string str = seria();
    unseria(str);
    return 0;
}
```

```makefile
json_test:json.cpp
	g++ -std=c++11 $^ -o $@ -ljsoncpp
```

运行结果：
![image-20231109145855387](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20231109145855387.png)



mysql数据库的基本操作：SQL

客户端操作：mysql -uroot -p

注意事项：

1.sql语句中，每条语句都应该以;结尾。

2.sql语句中，并不区分大小写。

3.sql语句中，数据库名称、表名称、字段名称不能直接使用sql关键字。

库的操作：

创建数据库：create database if not exists dbname;

查看数据库：show databases;

选择所使用的数据库：use dbname;

查看当前使用的数据库：select database();

删除数据库：drop database dbname;

表的操作：

常用数据类型：int-整形、decimal(m,d)-浮点型、varchar-字符长度、datetime。

创建表：
create table if not exists tbname

(

​	id int ,

​	name varchar(32)),

​	sex bit,

​	score decimal(4,2),

​	birth datetime

);

查看所有表：show tables;

查看指定表结构：desc tbname;

修改表结构：alter关键字

删除指定表：drop table tbname;

表中字段约束：

primary key	逐渐约束	约定指定字段的值，非空且唯一。

unique key	唯一约束	约定指定字段必须唯一。

not null	非空约束	约定制定字段的值不能为NULL。

auto_increment	自增属性（只能用于整形的主键字段）。

create table if not exists tbname

(

​	id int primary key auto_increment ,

​	name varchar(32)) not null unique,

​	sex bit,

​	score decimal(4,2),

​	birth datetime

);

表中数据的存储：增删改查。

新增：

insert tbname(id,name,sex)	values(null,"张三",0);

insert tbname values(null,"李四",1,88.88,"2020-10-8 12:00:00");

删除：

delete from tbname where id=2;

修改：

update tbname set score=66.78,birth="2020-8-6 21:00:00" where id=1;

查询：

查询表中所有数据：select * from tbname; 

指定列查询：select id,name,score from tbname;

按序查询：select id,name,score from tbname order by id desc;	降序

分页查询：select * from tbname order by id desc limit 3 offset 3;

条件查询：where



```db.sql
create database if not exists order_sys;

use order_sys;

-- tb_dish 菜品信息表
create table if not exists tb_dish
(
    id int primary key auto_increment,
    name varchar(32) unique not null,
    price int not null,
    ctime datetime      -- 创建时间
);

-- tb_order 订单表
create table if not exists tb_order
(
    id int primary key auto_increment,
    dishes varchar(255) comment '[1, 2]',       -- json格式字符串       comment是注释
    status int comment '0-未完成；1-完成',      -- 状态
    mtime datetime                              -- 修改时间
);

-- now()    mysql里面的内置函数，表示取系统当前时间。
insert tb_dish values(null,"红烧肉",2800,now()), (null,"红烧茄子",1800,now());
insert tb_order values(null,"[1,2]",0,now()), (null,"2",0,now());
```

把自己写的.sql文件直接在客户端执行，

```shell
sudo mysql -uroot < db.sql		#db.sql就是自己写的mysql文件
```

mysql代码操作：使用c语言接口，因为c++接口不好用。

​	1.初始化操作句柄；

​	2.通过句柄连接mysql服务器；

​	3.设置客户端字符集(utf8)；

​	4.选择使用的数据库；

数据操作：

​	5.执行语句：

​	增删改：执行语句--执行语句成功即可；

​	查询：执行语句-

​		将查询结果获取到本地

​		获取结果中数据条数、列数

​		遍历结果集获取每一条数据的每一列

​		释放本地结果集

6.关闭句柄释放资源

7.额外接口：获取接口执行失败原因。



接口介绍：

```c
MYSQL* mysql = NULL;

//初始化mysql的操作句柄	参数：mysql对象，为空则动态申请句柄空间进行初始化
//返回值：成功返回初始化的mysql操作句柄，失败返回NULL
MYSQL* mysql_init(MYSQL* mysql);

//连接服务器	参数：初始化完成的操作句柄	连接的mysql服务器的IP地址（主机）	用户名	密码	选择你所使用的数据库名称（一般默认）
//mysql服务端口，给0表示默认，默认是3306，如果改变了mysql服务器的端口，比如服务器是自己搭建的，这里就要指定你所访问的端口
//通信管道文件或者socket文件或者套接字文件路径（一般直接置NULL。不创建）	客户端标志位，通常置0
//返回值：成功返回句柄地址，失败返回NULL
MYSQL* mysql_real_connect(MYSQL* mysql, char* host, char* usernamr, char* passwd, char* dbname, int port, char* socket, int flag);

//设置当前客户端的字符集	初始化完成的mysql操作句柄	字符集名称，通常设置为utf8
//返回值：成功返回0，失败返回非0
int mysql_set_character(MYSQL* mysql, char* name);

//选择要进行操作的数据库	初始化完成的mysql操作句柄	要切换选择的数据库名称	
//返回值：成功返回0，失败返回非0
int mysql_select_db(MYSQL* mysql, const char* db);

//执行sql语句	初始化完成的mysql操作句柄	要执行的sql语句
//返回值：成功返回0，失败返回非0
int mysql_query(MYSQL* mysql, const char* stmt_str);

//保存查询结果到本地	初始化完成的mysql操作句柄	
//成功返回结果集的地址，失败返回NULL(结果集是一个结构体)
//特殊说明：mysql_query与mysql_store_result存在线程安全问题，要加锁保护
MYSQL_RES* mysql_store_result(MYSQL* mysql);

//获取结果集的行数	保存到本地的结果集地址
//返回值：结果集中数据的条数
int mysql_num_rows(MYSQL_RES* res);

//获取结果集的列数	保存到本地的结果集地址
//结果集中每一条数据的列数
int mysql_num_fields(MYSQL_RES* res);

//遍历获取的结果集中的每一条数据	保存到本地的结果集地址
//返回值：MYSQL_ROW实际上是一个char**的指针，将每一条数据做成了字符串指针数组	row[0]表示第0列，row[1]表示第1列
//注意点：并且这个接口会保存当前读取结果位置，每次获取的都是下一条数据
MYSQL_ROW mysql_fetch_row(MYSQL_RES* result);

//释放结果集	保存到本地的结果集地址
//返回值：void
void mysql_free_result(MYSQL_RES* result);

//关闭数据库客户端连接，销毁句柄
//返回值：
void mysql_close(MYSQL* mysql);

//获取mysql接口执行错误原因（获取最近一次操作失败原因）
//返回值：
const char* mysql_error(MYSQL* mysql);



```























