# 1.本节目标

1.学习yum工具，进行软件安装。

2.掌握vim编辑器使用，学会vim的简单配置。

3.掌握gcc/g++编译器的使用，并了解其过程，原理。

4.掌握简单gdb使用于调试。

5.掌握简单的Makefile编写，了解其运行思想。

6.编写自己的第一个Linux 程序：进度条。

7.学习 git 命令行的简单操作, 能够将代码上传到 Github 上。



# 2.常用工具的安装和使用

常用工具：软件包管理工具、编辑器、编译器、调试器、项目构建工具、项目管理工具。

## 2.1软件包管理工具yum

yum是centos和红帽子系列的软件包管理工具，apt是Ubuntu和Debian系列的软件包管理工具。

软件包管理工具：yum，类似于手机上的应用商店。（管理当前系统中能够安装的工具以及可以卸载的工具，并且实现安装以及卸载操作）

```shell
#下面的是Ubuntu中的，centos中把apt换成yum
#查看所能安装的软件工具
sudo apt list					#查看所有工具
sudo apt search keyord			#根据关键字查找指定的工具

sudo apt install package_name	#安装一个指定的软件工具	sudo apt install git
sudo apt remove package_name	#卸载已经安装的软件工具
```

## 2.2编辑器：vim

vim中默认不能使用鼠标，所有操作只能通过键盘完成，因此为了完成各种各样的操作，因此vim分出了多种操作模式，不同的操作模式下，相同的按键有不同的

功能。

vim操作模式分类：共有12种，最常用的是三种：普通、插入、底行。

普通：完成文本的操作（复制粘贴），以及光标的移动操作（光标的上下移动操作），以及其他指令操作（撤销、返回、全文对齐、跳转读的位置等操作）。

插入：插入数据。

底行：这里更多用于保存退出文件。

模式切换：vim 文件

打开文件后，默认处于普通模式。

普通到插入：i（光标在哪里就从哪里开始插入），o（在光标所在行下方添加新行开始插入），a（从光标所在位置的下一个位置开始插入）IAO（自己测试）

插入到普通：ESC（键盘左上角的键）

普通到底行：因为冒号

底行到普通：ESC（任意模式下按ESC键都可以回到普通模式）

 

不同模式下的常见操作：

1.底行模式下的操作：保存（:w）   退出（:q）	保存并退出（:wq）	不保存强制退出（:q!）	全文字符串替换（:%s/要替换的字符串/替换之后的字符串/g）

替换指定行区间的字符串（:12,13s/要替换的字符串/替换之后的字符串/g）（12到13行）（举个例子 :15,17 s/argv/environ/g）

```shell
:2s/pipe2/fifo_read/g  	#将该文件中第二行中所有的pipe2替换为fifo_read
```

不保存强制退出用于：在打开一个文件没有写的权限（只读）的时候，修改了文件，然后保存，告诉没有修改的权限无法保存，然后退出，告诉没有保存已经修改

的内容，会陷入死循环，这个时候需要强制退出。

2.普通模式下的操作：

光标移动操作（vim中不能使用鼠标）：左下上右（hjkl / 左下上右按键）、上下翻页（ctrl + f / b），文档首行和末尾行（gg / G）

文本内容操作（复制粘贴）：复制（yy / nyy）（n表示从光标位置开始复制n行）、粘贴（p / np）（n表示将复制的内容粘贴n次）、

剪切删除（dd / ndd）（删除行）（n表示从光标位置开始删除n行，删除之后粘贴就是剪切，不粘贴就是删除）、

删除光标所在字符（x）、删除单词（dw）

其它典型操作（撤销、返回）：撤销上一次操作（u）、撤销过头了反向撤销（ctrl + r）、全文对齐（gg = G）



```shell
vim minishell.c +33		#直接打开文件到第33行
```



### 2.2.1配置vim

```shell
vim ~/.vimrc

#用vim打开~/.vimrc文件将下面的内容粘贴进去(不想要的注释掉)
""显示行号
set nu	
""设置tab长度为4个空格
set ts=4
"set tabstop=4
""设置每次退格的时候退回缩进的长度
set sts=4
"set softtabstop=4
""设置缩进长度
set sw=4
"set shiftwidth=4
""设置自动缩进
set ai
"set autoindent
""设置不将tab替换为空格
set noexpandtab
""set expandtab

if has("autocmd")
	"这里需要开启自动检测文件类型
	filetype indent on
	""对任意类型文件进行如下设置
	autocmd FileType * setlocal ts=4 sts=4 sw=4 ai et nu
	"对makefile需要将tab替换空格功能去掉，不进行替换
	autocmd FileType make setlocal ts=4 sts=4 sw=4 noet nu
endif

""如果你在 Ubuntu 中安装并使用了 neovim，配置文件的位置为 ~/.config/nvim/init.vim。
```

vim中打开一个文件后，通常会创建一个临时文件以.sw*结尾。

vim打开文件后，创建临时文件，编辑的时候会修改这个临时文件，只有在保存的时候，才会将修改的信息，写入到源文件中。

a.txt	a.txt.swp

注意：正常退出vim的时候会删除临时文件，并且在文件没有正常关闭退出vim的时候，这个临时文件不会被删除。

之后每次打开a.txt文件的时候，会出现一个提示界面，正确做法是用临时文件覆盖源文件（shift + r（好像是）（覆盖）），最后保存退出，退出之后删除临时文

件（使用ls -a查看隐藏文件），之后打开源文件就不会提示了。

## 2.3编译器gcc/g++

编程时所使用的c、c++语言都属于高级语言，不是cpu指令，这种语言无法直接被cpu识别。

各种语言出现的目的，是为了简化编程，并且实现跨平台移植性（一段程序能够在不同的平台上编译后运行）。

上层使用统一语言的语法规则，构建不同语言，然后不同语言拥有不同的编译器，将上层高级语言代码解释成为对应平台的cpu指令，能够被cpu识别执行。

编译过程：将高级语言代码解释成为机器指令经过了哪些阶段。

预处理阶段：展开所有代码（引入头文件、宏替换、删除注释等操作）

编译阶段：检查语义语法错误，如果没有错误则将c语言解释成为汇编语言。

汇编阶段：将汇编代码解释成为二进制的cpu指令。

链接阶段：将所有的指令代码打包到一起（不仅是打包我们自己的代码，还有链接库文件中的库函数指令代码），成为组织成为可执行程序。

gcc：C语言编译器、g++：c++语言编译器

-E：只进行预处理

-S：只进行编译处理

-c：只进行汇编处理

-o：指定输出文件名称。

```shell
gcc -E test.c -o test.i
gcc -S test.i -o test.s
gcc -C test.s -o test.o
gcc test.o -o test.exe
```

库：通常被认为是库函数，说白了就是一个文件，文件中包含大量的函数实现的二进制代码指令（比如我们所使用printf函数）。

代码中用到了标准库中的printf函数，则生成可执行程序时就必须能够知道printf的具体指令，这就是链接库的必要性。

### 2.3.1库的链接方式

库被分为两种：动态库和静态库。

动态链接：链接动态库生成可执行程序，并没有把库中函数的实现指令直接拿过来写入可执行程序中，而是在可执行程序中记录了库中函数的符号信息表，在运行

可执行的时候需要去加载动态库到内存中，如果动态库不存在，则程序无法运行。

静态链接：静态链接库生成可执行程序，直接将库中我们用到的函数的实现代码指令，写入到了可执行程序文件中，程序运行的时候没有什么依赖。

动态链接的优缺点：生成可执行程序比较小，运行时动态库被加载到内存中，可以多个程序使用同一份内存中库函数代码，缺点是运行时需要依赖动态库的存在，

不存在则无法运行。

静态链接的优缺点：程序运行没有其其他依赖，可以直接运行，但是可执行程序比较大，并如果多个程序使用同一个库中的函数，则这些程序同时运行时，则相同

的库函数代码在内存中会存在多份，各是各的。

gcc编译器中默认的链接方式是动态链接。

gcc / g++编译器：

编译器的作用，程序编译的过程是什么样的，每个阶段完成了什么工作，库的链接方式分类有哪些，有什么区别。



linux中运行一个程序:1.绝对路径：从根目录开始到可执行文件。2.相对路径：当前目录中（./文件名）。

## 2.4gdb调试器

调试器的功能：调试并且观察程序的运行过程，通常目的都是为了排查程序的运行错误。

程序的错误分类：编译错误、链接错误（打包成可执行程序的时候出错了）、运行时错误（语义语法没有毛病，运行时逻辑不对，以及程序运行时崩溃 ）。

调试器就是为了排查程序的运行时错误。

调试程序的前提：程序必须是一个debug版本。（gcc / g++默认生成release版本程序，若要生成调试版（debug版本）则使用 - g 选项gcc -g test.c -o test）

可执行程序的分类：

debug调试版：不对代码进行优化，并且加入程序调试信息。

release发布版：不包含调试信息，并且会对代码进行优化。

gdb常用调试指令：

```shell
#第一种
gdb ./文件名

#第二种
gdb
file 文件名			#加载程序文件
```

流程控制：

run：直接运行程序。（r）

start：开始逐步调试。

list：查看调试行附近代码。（l）			查看指定行（11行）代码（list 11）（显示指定行上下个5行的代码）				查看指定文件指定行代码（list 文件名:行

号）

next：下一步，逐过程。（逐过程：遇到函数直接运行完毕，不会进入函数）（简写是n）

until：until test.c:16（直接运行到程序的16行）（打断点）

step：下一步，逐语句。（逐语句：遇到函数则进入函数继续调试）（s）

continue：继续从当前调试位置运行（c）（逐步调试过程中，如果不想逐步调试了，想要程序继续向下直接运行的时候）（每次指向看一个循环中的断点的时

候用continue，不是next，更快）



打断点：

break：打断点（break test.c:14（在test.c文件的14行打断点））（break function_name（给指定的函数打断点））（b）

info break：查看断点信息（断点ID）（i b）

![image-20230808184656819](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230808184656819.png)

![image-20230808184726963](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230808184726963.png)

delete：删除全部断点信息。（d）

delete 2：删除指定num断点（断点ID）

watch i：监控变量（在变量发生改变的时候会停下来，告诉变量原来的值和新的值）（watch 变量名称（variable_name））

quit：退出gdb（q）



内存控制：

print：查看或设置变量内容（打印变量i（print i））	（设置变量i为9（print i= 9））（print var_name）（print var_name = val）

backtrace：查看函数调用栈，通常用于检测程序运行时崩溃位置（遇到Segmentation fault段错误，段错误是运行时错误，查看函数调用栈快速定位错误）

（bt）

![image-20230808194306096](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230808194306096.png)

函数调用栈：是一个先进后出的结构，函数调用栈栈顶位置的函数就是程序发生崩溃的位置，正常执行结束后的函数调用栈应该是空的。

![image-20230808195404736](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230808195404736.png)

## 2.5make/Makefile：项目的自动化构建工具

### 2.5.1makefile

Makefile：是一个文本文件，记录一个项目的构建规则流程。

makesile的编写规则：（大小写无所谓）

```makefile
#最简单的makefile文件
#目标对象:依赖对象
#\t为了生成目标对象要执行的指令
test:test.c
	gcc test.c -o test.exe
```

预定义变量的使用：用于指令中

$@：表示目标对象。

$^：表示所有依赖对象。

$<：表示依赖对象的第一个。



程序的编译过程：预处理、编译、汇编、链接。（在项目构建中会整体分为两步：编译和链接）

这样的好处是：如果只是修改了一个.c文件，以前直接对所有的.c文件进行编译生成可执行程序的过程来说，需要重新编译所有的.c文件生成可执行程序，效率低

下。

因此分为两步进行操作，先把每个.c文件都生成自己的.o文件，然后再把所有的.o文件链接到一起，好处是一旦一个.c文件发生改变只需要对这一个.c文件进行编译

生成.o文件，之后将所有的.o文件重新链接一次就可以生成可执行程序。（其他的.c文件不需要重新编译）

![image-20230809063303720](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230809063303720.png)

修改test.c代码，只需要重写编译test.c，不需要编译其他文件。（只需要编译修改的文件，没有修改的文件不需要编译，节省了项目的构建时间）

![image-20230809063627794](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230809063627794.png)

```makefile
#只会执行第一个目标
test:test.o test1.o test2.o
    gcc $^ -o $@
    
test.o:test.c
    gcc -c $^ -o $@
test1.o:test1.c
	gcc -c $^ -o $@
test2.o:test2.c
	gcc -c $^ -o $@
```

```makefile
#修改
#只会执行第一个目标
test:test.o test1.o test2.o
	gcc $^ -o $@

%.o:%.c
	gcc -c $< -o $
```

```makefile
#修改
#执行程序的名称：要生成这个程序依赖的源码文件
#$(wildcard ./*.c)	获取当前目录下所有以.c结尾的文件的文件名称
src=$(wildcard ./*.c)		#test.c tes1.c test2.c

#test:test.c test1.c test2.c
#test:$(src)
#	gcc $^ -o $@

#将src变量的内容中的.c替换成为.o，然后存放到obj变量中
obj=$(patsubst %.c,%.o,$(src))	#test.o test1.o test2.o

#只会执行第一个目标
#test:test.o test1.o test2.o
test:$(obj)
	gcc $^ -o $@

%.o:%.c
	gcc -c $< -o $@
```

![image-20230809072812641](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230809072812641.png)

```makefile
#执行程序的名称：要生成这个程序依赖的源码文件
#$(wildcard ./*.c)	获取当前目录下所有以.c结尾的文件的文件名称
src=$(wildcard ./*.c)		#test.c tes1.c test2.c

#test:test.c test1.c test2.c
#test:$(src)
#	gcc $^ -o $@

#将src变量的内容中的.c替换成为.o，然后存放到obj变量中
obj=$(patsubst %.c,%.o,$(src))	#test.o test1.o test2.o


.PHONY:test	 	#伪对象，作用是每次make都会重新生成，没有这个语句会提示是已经是最新的文件
#只会执行第一个目标
#test:test.o test1.o test2.o
test:$(obj)
	gcc $^ -o $@

%.o:%.c
	gcc -c $< -o $@

#伪对象：声明一个对象与外部文件无关，每次都需要重新生成（不会因为当前文件是最新的不需要重新生成）
#如果有对象不管外部是否存在，每次无论如何都要执行语句，则可以声明为伪对象
.PHONY:clean	#通常伪对象是为了防止额外生成的对象与外部文件重名，说明与外部对象无关，每次都需要重新执行语句生成
#clean是第二个对象	不会真正的执行到，而是想要执行清理.o文件的时候，在外部指定对象执行:make clear
clean:
	rm -rf $(obj)		#删除.o文件
#	rm -rf $(obj) test  #和上面相比多删除了一个test文件
```

伪对象：声明一个目标对象与外部文件无关，表示每次这个对象不管是否是最新都要重新生成。（.PHONY:）

![image-20230809094206433](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230809094206433.png)



### 2.5.2make

make：是一个解释程序，对Makefile中记录的构建规则流程逐步解释执行，完成项目的构建。

make的解释执行规则：

1.在命令行中敲击make指令，则表示运行make解释程序，程序会在当前目录下找到名称为makefile/Makefile的文件，解释执行其中的项目构建规则；

2.在规则中，找到要生成的第一个目标对象。（判断目标对象是否已经存在，存在的话是否需要重新生成）

如何判断目标对象是否存在：依赖对象改变了就要重新生成目标对象。（如果依赖对象靠近当前时间就要重新执行make指令，生成新的目标对象）

3.make每次在makefile中只会找到第一个目标对象进行生成，生成之后就会退出。（也就是说不会去生成第二个对象）

4.make在生成目标对象的时候，会先查找依赖对象的生成规则，先生成依赖对象，然后再去生成目标对象。

 make执行makefile文件中的内容（第一个目标），make clean指定目标执行。



### 2.5.3makefile语法学习

掌握下面的makefile语法之后就可以自己写makefile来管理项目的构建过程。

1. 目标（Target）：目标用于定义需要生成的文件或执行的操作。它的基本语法如下：

```makefile
target: dependencies
    command
```

其中，`target` 是目标的名称，`dependencies` 是目标所依赖的对象，可以是文件或其他目标。`command` 是生成目标时需要执行的操作命令。

1. 依赖项（Dependency）：依赖项指的是目标所依赖的对象，可以是文件或其他目标。如果依赖项的内容发生变化，那么目标就需要重新生成。例如：

```makefile
main.o: main.c utils.h
    gcc -c main.c
```

这里，`main.o` 是目标，它依赖于 `main.c` 和 `utils.h` 这两个文件。

1. 命令（Command）：命令用于在生成目标时执行的操作。在 Makefile 中，命令必须以 Tab 键开头，并且应该位于目标行之后。例如：

```makefile
target: dependencies
    command1
    command2
```

在上述示例中，`command1` 和 `command2` 是在生成目标时要执行的操作命令。

1. 变量（Variable）：变量用于存储文本字符串，可以在 Makefile 中重复使用。您可以使用变量来存储编译器选项、源文件列表等。变量的定义语法如下：

```makefile
variable = value
```

通过 `$()` 或 `${}` 来引用变量的值。例如：

```makefile
CC = gcc
CFLAGS = -Wall -O2

target: dependencies
    $(CC) $(CFLAGS) -o target dependencies
```

在上述示例中，`CC` 和 `CFLAGS` 是变量，分别存储编译器和编译选项。

1. 函数（Function）：Makefile 提供了许多内置函数，用于处理变量的值。您可以使用这些函数来获取文件列表、替换字符串、取得文件名等操作。函数的调用语法如下：

```makefile
$(function_name arguments)
```

例如，`$(wildcard)` 函数用于获取指定模式的文件列表，`$(patsubst)` 函数用于替换字符串中的模式匹配。

1. 模式规则（Pattern Rule）：模式规则用于表示一类目标的依赖关系和生成规则。它可以通过通配符来匹配一组文件，并为每个文件提供相应的依赖项和命令。例如：

```makefile
%.o: %.c
    gcc -c $< -o $@
```

在上述示例中，以 `.o` 结尾的目标依赖于同名的 `.c` 文件，并通过相应的命令生成。

1. .PHONY：`.PHONY` 声明的目标不对应具体的文件名，表示一个动作或操作。它可以防止由于存在同名文件而无法执行相应的命令。例如：

```makefile
.PHONY: clean

clean:
    rm -f *.o
```

在上述示例中，`clean` 是一个声明为 `.PHONY` 的目标，用于清理生成的目标文件。

1. 注释：使用 `#` 符号进行注释。在 Makefile 中，注释可以出现在任意位置，用于解释代码的用途或提供其他相关信息。
2. 自动变量（Automatic Variable）：Makefile 提供了许多自动变量，用于在命令中引用目标、依赖项等信息。自动变量的值会根据上下文自动设置。一些常用的自动变量包括：

- `$@`：当前目标的名称。
- `$^`：所有依赖项的列表。
- `$<`：第一个依赖项的名称。



### 2.5.4为什么makefile通配符不是*而是%

在 Makefile 中，`%` 是通配符符号，用于匹配文件名中的任意字符序列，而不是像通常情况下使用的 `*`。

这样设计的原因是为了与正则表达式的语法保持一致。在正则表达式中，`*` 表示匹配零个或多个前面的字符，而 `.` 则表示匹配任意一个字符。为了避免混淆和歧义，Makefile 中采用 `%` 作为通配符，表示匹配任意字符序列。

在模式规则中，`%` 可以用来表示通配一个或多个字符，从而实现一类目标的依赖关系和生成规则。例如，`%.o: %.c` 表示以 `.o` 结尾的目标可以匹配同名的任何 `.c` 文件，从而将其作为依赖项并执行相应的命令。

总结起来，Makefile 使用 `%` 作为通配符是为了保持与正则表达式的一致性，并且能够清晰地表达模式匹配的意图。

## 2.6git

git是项目的版本控制工具。

github是一个服务器。

每个产品伴随着开发偶会有很多的版本（1.0要求能用就行，继续进行优化，功能的扩展......）

游戏今天更新了新版本，但是出现了大量的闪退，无法正常游戏（一个小时后搞不定，赶紧回滚回来使用上一个正常版本继续运行，新版本重新回炉问题排查）

项目版本管理工具：整体归档项目周期的各个阶段，便于项目的管理（便于出错后，回到上个版本）

```shell
#git：三板斧操作
#1.在github建立远程仓库

#2.将远程仓库克隆到本地
git clone https://github.com/jwcwwj/example.git			 

#3.提交本次修改记录
git add --all ./

#4.提交本地仓库版本管理
git commit -m "本次修改的备注信息"

#5.将本地版本同步到远程仓库
git push origin master(mast是主分支)
```

远程仓库子分支到本地仓库：git clone

本地仓库到远程仓库子分支：git push

本地仓库：git add



```shell
git init														#在当前目录下创建一个新的Git仓库
git add --all ./												#将当前目录中的所有文件添加到 Git 仓库的暂存区
git config --global user.email "your-email@example.com"			#设置你的电子邮件地址
git config --global user.name "Your Name"						#设置你的用户名（姓名或者昵称）
git config user.email "your-email@example.com"					#只在当前仓库中设置身份标识而不影响全局设置
git config user.name "Your Name"								#只在当前仓库中设置身份标识而不影响全局设置
git commit -m "nihao"											#提交了本地修改，使用提交信息"nihao"进行提交
git branch -M main												#对默认分支名称进行重命名，重命名为main（默认分支命名为master）
git remote add origin https://github.com/jwc/example.git	#用于将远程仓库与本地仓库进行关联
git push -u origin main											#将本地仓库的提交推送到远程仓库，并建立起本地主分支与远程主分支之间的关联

git branch 														#检查所有可用的本地分支
git remote -v													#查看远程连接的详细信息
git branch -a													#查看所有本地和远程支持
```

`git commit -m "nihao"`

使用提交信息 "nihao" 进行提交。在使用该命令之前，请确保您已经设置了正确的用户名和电子邮件地址，以便将其作为提交的作者信息。

这个命令将把您当前工作目录中的修改提交到 Git 仓库中。提交操作是将修改保存到 Git 的版本历史记录中的一步。

请注意，在提交之前，您应该先使用 `git add` 命令将要提交的文件添加到暂存区。例如，如果您想提交当前目录下的所有修改，可以在执行 `git add --all` 之后再执行 `git commit -m "nihao"`。

请记住，提交信息应该清楚、明确地描述您的更改内容。这样可以方便他人理解您的提交，并在需要时查找相关信息。您可以根据实际情况替换 "nihao" 为适当的提交信息。



`git branch -M main` 是 Git 命令，用于重命名当前仓库的默认分支。

在过去，Git 的默认分支名称通常为 "master"。然而，为了避免潜在的含义问题，Git 社区决定将默认分支名称更改为 "main"。这是一个以促进包容性和多样性为目标的举措，以减少对带有种族主义背景的术语的依赖。

因此，`git branch -M main` 的作用是将当前仓库的默认分支从 "master" 改为 "main"。它会重命名已存在的分支，并在您的本地仓库和远程仓库中进行更新。

请注意，执行此命令之前，请确保您的仓库中已经存在一个名为 "master" 的分支。如果没有，请先创建一个分支，然后再执行 `git branch -M main`。



`git remote add origin https://github.com/jwc/example.git` 是 Git 命令，用于将远程仓库与本地仓库进行关联。

当您在 GitHub 或其他代码托管服务上创建一个新的仓库时，会获得一个远程仓库的 URL，如 `https://github.com/jwc/example.git`。使用 `git remote add` 命令，您可以将该远程仓库添加为本地仓库的一个远程连接，并为该连接指定一个名称（通常命名为 "origin"）。

具体而言，`git remote add origin` 的意思是将远程仓库的 URL `https://github.com/jwc/example.git` 与本地仓库关联，并将该远程连接命名为 "origin"。这将允许您在将来通过 "origin" 这个名称引用远程仓库。

一旦远程仓库与本地仓库成功关联，您就可以使用其他 Git 命令来与远程仓库进行交互，例如 `git push` 将本地提交推送到远程仓库，或者 `git pull` 获取远程仓库的最新更改。

请注意，"origin" 只是一个约定俗成的名称，您可以选择其他名称来表示远程仓库连接。但通常建议将主要远程仓库命名为 "origin"。



`git push -u origin main` 是 Git 命令，用于将本地仓库的提交推送到远程仓库，并建立起本地主分支与远程主分支之间的关联。

具体而言，这个命令完成以下两个主要的操作：

1. `git push`: 这部分表示将本地的提交推送（即上传）到远程仓库。通过这个命令，您可以将在本地进行的版本控制的更改同步到与之关联的远程仓库中。
2. `-u origin main`: 这部分表示将您当前本地仓库的主分支（通常是 "main" 或 "master"）推送到名为 "origin" 的远程仓库。"origin" 是您在先前使用 `git remote add` 命令时为远程仓库指定的名称。

当使用 `-u` 或 `--set-upstream` 选项时，该命令还会建立起本地主分支与远程主分支之间的关联。这意味着，以后在该分支上执行 `git push` 命令时，Git 会自动将更改推送到远程主分支。

因此，对于首次将本地主分支推送到远程仓库，您可以使用 `git push -u origin main` 命令。在此之后，您只需要使用 `git push` 命令，Git 将自动将更改推送到远程主分支。

请注意，"main" 是一个示例分支名称，您可以根据自己的实际情况将其替换为您本地仓库的主分支名称。

### 2.6.1遇到的问题

如果本地没有仓库，那么 `git push -u origin master` 命令将无法执行，因为它是将本地仓库的提交推送到远程仓库的命令。

在您的情况下，您需要先克隆（clone）一个远程仓库到本地，然后才能执行推送操作。可以使用以下命令来进行克隆：

```shell
git clone https://github.com/jwc/example.git
```

这将把名为 "example" 的远程仓库克隆到当前目录下的一个新文件夹中。

然后，您可以进入克隆的仓库目录，将您的文件添加到本地仓库，并执行以下命令来推送到远程仓库：

```
cd example
# 将您的文件添加到本地仓库
git add .
# 提交更改
git commit -m "Initial commit"
# 推送到远程仓库
git push -u origin master
```

请注意，"origin" 是远程仓库的名称，"master" 是要推送的本地分支。根据实际情况，您可能需要更改这些名称。

# 3.进度条程序

printf是向终端显示打印数据。

linux中一切皆文件，终端显示是显示器设备，在linux中被当做文件进行操作，也就是说将数据写入显示器设备文件，数据就会被显示在显示器上。

显示器文件在编程中被称之为：标准输出设备（标准输入（键盘）、标准输出（显示器）、标准错误（把错误信息显示给显示器文件））

printf打印数据在不换行的情况下，数据是一次性打印了多次写入的数据。

数据不是直接写入标准输入文件的。

数据先被写入缓冲区，在由缓冲区写入标准输出文件。

缓冲区写入标准输出文件的条件：缓冲区数据满了，或者要退出程序了，或者手动刷新缓冲区了，这时候数据才会被写入实际文件。（缓冲区有大小和时间限制，

、达到了就要写入文件）

输入写入一次文件就要操作一次设备，操作一次设备效率是很低的，比如要操作机械硬盘，要先等待机械硬盘准备好了，准备好了是硬盘首先要找到自己要写入数

据的区域，磁盘指到了区域，数据才能写入磁盘。（每次数据写入设备都要进行一次设备操作，叫做IO操作，引入缓冲区提高IO效率）

缓冲区中：小的数据现在在缓冲区中堆积，攒成大数据一次性写入文件，只进行了一次IO操作，提高了IO效率。

每个文件都会有自己的缓冲区，标准输入文件的缓冲区有个特性，换行刷新缓冲区。

刷新缓冲区就是把数据写入文件。

缓冲区就是一块内存空间。

数据到缓冲区是内存写入（效率高），缓冲区到标准输出设备试一次设备交互（效率低）。

```c
//progress_bar.c（进度条程序）
#include <stdio.h>
#include <unistd.h>     //usleep

int main()
{
    char buf[11] = {0};
    for(int i = 0; i < 10; ++i)
    {
        buf[i] = '-';
        printf("%s\r",buf);        
        usleep(100000);     //微秒  100000微秒 = 100毫秒    为了让程序运行到这里休眠一下，让肉眼可以看见执行的结果
        fflush(stdout);     //手动刷新标准输出缓冲区
    }
    return 0;
}
```

```makefile
#makefile文件
progress_bar:progress_bar.c
	gcc $^ -o $@
```

## 3.1回车符和换行符的区别

\r：是回车符，光标移动到起始位置。

\n：是换行符，光标移动到下一行。

回车符（Carriage Return）和换行符（Line Feed）是两个在计算机中用于控制文本换行的特殊字符。它们在不同的操作系统和编码标准中有不同的表示方式和使用规则。

回车符（\r）表示将光标移动到当前行的开头位置，即将光标移到行首。换行符（\n）表示将光标移动到下一行的开头位置，即将光标移到下一行行首。

在不同的操作系统中，回车符和换行符的组合使用方式有所不同：

1. Windows系统：Windows使用回车符和换行符的组合（\r\n）来表示新的一行。因此，在Windows中，每行的结尾都是一个回车符和一个换行符。
2. Unix/Linux系统：Unix和Linux系统使用换行符（\n）来表示新的一行。因此，在Unix/Linux系统中，每行的结尾只有一个换行符。
3. macOS系统：早期的Mac OS（包括Classic Mac OS和macOS之前的版本）使用回车符（\r）来表示新的一行。但是，现代的macOS已经采用了和Unix/Linux系统相同的换行符（\n）来表示新的一行。

需要注意的是，在不同的文本编辑器和编程语言中，可能会对回车符和换行符的解释方式有所差异。有些文本编辑器和编程语言可以自动检测并处理不同操作系统的换行符，而有些则需要手动设置换行符的类型。



# 4.总结

常用工具：yum、vim、gcc/g++、gdb、make/Makefile、git

yum：软件包管理工具

查看：yum list、yum search		安装：yum install		卸载：yum remove

vim：命令行下的编辑器

操作模式：12种	常见：3种：普通、插入、底行

模式切换：任意到普通：ESC		普通到插入：i、a、o		普通到底行：英文冒号

底行常见操作：	:w	:q	:wq	:q!（不要使用ctrl + z退出vim）

普通常见操作：光标移动：hjkl	wb	ctrl+f/b	gg/G		文本操作：nyy/p/ndd/x/dw		其他：u/ctrl+r	gg=G

gcc/g++：编译器，将我们所写的高级语言代码，解释成为机器能够识别的指令。

程序的编译过程：预处理、编译、汇编、链接。

链接方式：动态链接，链接动态库。		静态链接，链接静态库。		gcc默认链接方式是动态链接。

gcc常见操作选项：-E、-S、-c、-o、-g（-l（小写的L）、-L、-I（大写的i）、--share、-fPIC、-O）

gdb：调试器，调试程序的运行过程、发现程序中存在的问题。

1.通过gcc -g生成debug调试版程序。（不会发生代码优化，并且会加入调试信息）

2.gdb程序文件：gdb加载程序指令代码。

3.调试指令：run、start、step、next、until、continue、list、break、info break、delete、watch、print、backtrace。

make/Makefile：项目自动化构建工具。

Maekfile：文本文件，记录项目的构建流程规则。

make：makefile的解释器，解释其中的流程规则逐步执行完成项目的构建。

makefile的编写规则：目标对象、依赖对象、执行的指令。	预定义变量：$@、$^、$<.			伪对象：无论如何都要执行指令生成的对象，通过.PHONY声明。

make的解释规则：在当前目录下找到makefile，找到第一个目标对象，生成他的依赖对象，然后在根据指令生成目标对象。（递归的过程）

git：项目版本管理工具

克隆远程仓库：git clone；

提交本地记录：git add --all  ./

提交本地版本管理：git commit -m "备注信息"

提交同步本地到远程仓库：git push origin main（分支）
