# 1.本节目标

1.学习进程创建,fork/vfork

2.学习到进程等待

3.学习到进程程序替换, 微型shell，重新认识shell运行原理

4.学习到进程终止,认识$?  



进程控制：创建、退出、等待、替换。



# 2.进程创建

```c
pid_t fork();
```

通过复制父进程创建一个子进程。

父子进程代码共享，数据独有。

返回值：错误返回-1，对于父进程返回值大于0（子进程pid），对于子进程返回0.

创建子进程的流程：

1.程序运行：程序加载到内存里面；

2.创建子进程：创建pcb，创建虚拟地址空间，创建页表，但是这时候映射同一块地址（物理内存）；

3.写时拷贝技术：当内存发生数据改变的时候，子进程重新开辟空间，拷贝数据。（子进程不直接开辟空间，是等到修改的时候才开辟空间）

写时拷贝技术：创建子进程后，子进程与父进程各自有自己的虚拟地址空间，但是数据映射的实际上是同一块物理内存，等待内存发生改变的时候为子进程重新开

辟一块独立的空间，保存子进程的数据。（保持进程的独立性）

写时拷贝技术提高fork创建子进程的效率。

fork中父子进程谁先运行不一定，取决于cpu调度谁的pcb，但大多数情况下是父进程先运行。

![image-20230813044216844](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230813044216844.png)

```c
#include <stdio.h>
#include <unistd.h>
 
int g_val = 100;
  
int main(int argc, char* argv[])
{
    pid_t pid = fork();
    if(pid < 0)
    {
        return -1;          //创建子进程失败
    }
    else if(pid == 0)
    {
        //子进程会返回0
        g_val = 200;
        printf("child g_val = %d--%p\n", g_val, &g_val);
    }
    else
    {
        //父进程返回子进程的pid，是大于0的
        sleep(3);
        printf("parent g_val = %d--%p\n", g_val, &g_val);
    }
    return 0;
}
```

输出结果：
![image-20230813053643129](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230813053643129.png)



```c
pid_t vfork(void);
```

通过复制父进程创建一个子进程，父子进程共用虚拟地址空间。

创建子进程后，父进程会阻塞直到子进程exit退出或者（程序替换）之后才会运行。



vfork函数为什么先使用子进程之后才能使用父进程？

公用同一个虚拟地址空间，同时运行会造成栈混乱。（函数栈调用）



vfork函数中子进程改变了某个数据，父进程也就改变了。



创建一个子进程出来之后，大多数情况下都是让子进程干其他事情，大多数时候都是进行程序替换，给子进程重新开辟空间，让子进程干自己的事。

自从有了fork函数之后，vfork就很少有人用了，几乎被淘汰了。

![image-20230813044940612](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230813044940612.png)

vfork创建的子进程不能在main函数中return退出，只能exit退出或者程序替换。



# 3.进程退出

退出一个进程。

三种方式：

1main函数中调用return。（其他函数中使用return是退出函数）

2使用库函数void exit(int status);	在任意位置调用都可以退出进程，退出之前刷新文件缓冲区。

3使用系统调用接口void _exit(int status);	在任意位置调用都可以退出进程，但不会刷新文件缓冲区。（最快的退出方法）

三种方式各有不同，以后在合适的场景使用合适的方式即可。



进程是为了完成一个任务，进程在有些操作系统上称为task（任务）。

进程的退出返回值：

```shell
echo $?			#上一条命令的最终return或者exit结果（返回值）
```

1正常退出：通过三种退出方式退出的进程。（结果是否符合预期）

2.异常退出：程序因为某些错误异常崩溃退出。



进程的退出返回值保存在进程的pcb里面。

进程的返回值，实际上只使用了一个字节进行保存。（退出返回值在0到255之间）



普及两个接口：查看上一次系统调用接口使用错误原因的接口

1.

```c
void perror(const char* s);		//输出错误原因在字符串s之后
```

```c
//示例
#include <stdio.h>
#include <unistd.h>

int main()
{
    fork();
    perror("调用fork成功：");
    return 0;
}

//输出： 
//调用fork成功：Success
//调用fork成功：Success
```



2.

```c
char *strerror(int errnum);			//保存上一次系统调用错误的原因，是一个字符串
```

error.h中有一个全局变量errno，每次都保存上一次系统调用错误原因的编号。

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>

int main()
{
    perror("调用fork成功：");
    for(int i = 0; i < 255; i++)
    {
        printf("错误原因：%s\n", strerror(i));				//这里的i需要输入一个整形数字，以后的使用替换为error.h中的全局变量error
    }
    return 0;
}
```



# 4.进程等待

概念：父进程等待子进程的退出，获取退出子进程的返回值，释放退出子进程的资源。	目的：为了避免产生僵尸进程。

操作：pid_t wait(int* status);	阻塞函数

status：一个整形空间的地址，用于获取退出子进程返回值。

返回值：成功返回退出子进程的pid（（和int的取值范围一样）），失败返回-1。

等待任意一个子进程的退出，如果当前没有子进程退出则一直阻塞等待。

只要有退出的子进程，这个接口就会立即进行处理后返回。

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
 
int main()
{
    pid_t pid = fork();
    if(pid < 0)
    {
        perror("fork error\n");
        exit(-1);
    }
    else if(pid == 0)
    {
        //child
        sleep(5);
        exit(0);
    }
    else
    {
        //parents
        int childpid = wait(NULL);
        printf("%d ----- %d\n", pid, childpid);
        while(1)
        {
            sleep(1);
        }
    }
    return 0;
}
```



针对函数（接口）说的：

阻塞函数：为了完成一个功能，发起一个调用，若当前不具备完成条件，则一直等待。

非阻塞函数：为了完成一个功能，发起一个调用，若当前不具备完成条件，则立即返回。





pid_t waitpid(pid_t childpid, int* status, int options);

可以等待任意一个子进程退出，也可以只等待指定的子进程。

可以阻塞等待子进程退出，也可以非阻塞等待子进程退出。

参数：指定的某个子进程的pid		一个整形空间的地址，用于获取退出子进程返回值		选项信息

childpid：-1表示等待任意子进程，大于0表示等待指定的子进程。

status：用于获取退出子进程的返回值。

options：0表示默认阻塞等待，WNOHANG设置非阻塞等待。

返回值：错误返回-1，没有子进程退出返回0，有子进程退出返回子进程id。（小于-1返回进程组）

```shell
vim ~/.bashrc			#配置（其中alias是起别名）
```

文件后缀名为 `.rc` 通常表示资源文件（Resource File）。

资源文件是一种存储应用程序或系统所使用的非代码数据的文件。它包含了应用程序所需的图像、文本、配置设置、界面布局等信息。资源文件通常分离出来，以便于在不重新编译代码的情况下对应用程序进行本地化或进行其他修改。

`.rc` 后缀的资源文件在不同的编程环境中有不同的含义和用途。以下是一些示例：

1. 在 Windows 程序开发中，`.rc` 文件通常是指资源脚本文件（Resource Script File），其中包含了应用程序的资源声明，如对话框、菜单、图标等。这些资源可以使用 Visual Studio 等工具进行编辑和管理。
2. 在 Linux/Unix 程序开发中，`.rc` 文件也可以表示运行时配置文件（Runtime Configuration File）。这些文件用于定义程序的运行时行为，例如设置环境变量、配置路径、指定默认选项等。

需要注意的是，尽管 `.rc` 后缀通常与资源文件关联，但在不同的上下文中可能会有其他的解释和用途。因此，请根据具体情况判断该文件是何种类型，并参考相应的文档或说明来了解更多详细信息。



```c
//作用和上面写的wait作用一样
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
 
int main()
{
    pid_t pid = fork();
    if(pid < 0)
    {
        perror("fork error\n");
        exit(-1);
    }
    else if(pid == 0)
    {
        //child
        sleep(5);
        exit(0);
    }
    else
    {
        //parents
        //int childpid = wait(NULL);
        int childpid = waitpid(-1,NULL,0);         //-1表示等待任意子进程，0表示默认阻塞        等同于wait
  		//憋住：waitpid中的第一个参数不能乱给，要是给一个没有的进程id，不用等待，直接返回-1.
        printf("%d ----- %d\n", pid, childpid);
        while(1)
        {
            sleep(1);
        }
    }
    return 0;
}
```

```c
//等待部分时间
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
 
int main()
{
    pid_t pid = fork();
    if(pid < 0)
    {
        perror("fork error\n");
        exit(-1);
    }
    else if(pid == 0)
    {
        //child
        sleep(5);
        exit(0);
    }
    else
    {
        //parents
        //int childpid = wait(NULL);
        sleep(10);
        int childpid = waitpid(pid,NULL,WNOHANG);         //-1表示等待任意子进程，0表示默认阻塞        等同于wait
 
        printf("%d ----- %d\n", pid, childpid);
    }
    return 0;
}
//输出：12120 ----- 12120
```

 

```c
//非阻塞等待一般才去循环操作，循环等待
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
   
int main()
{
    pid_t pid = fork();
    if(pid < 0)
    {
        perror("fork error\n");
        exit(-1);
    }
    else if(pid == 0)
    {
        //child
        sleep(5);
        exit(0);
    }
    else
    {
        //parents
        //int childpid = wait(NULL);
        int childpid;
        while((childpid = waitpid(pid,NULL,WNOHANG)) == 0)
        {
            printf("没有子进程退出，你可以休息一下...\n");
            sleep(1);
        }
        printf("%d ----- %d\n", pid, childpid);
    }
    return 0;
}
```





```c
//非阻塞等待一般才去循环操作，循环等待
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
   
int main()
{
    pid_t pid = fork();
    if(pid < 0)
    {
        perror("fork error\n");
        exit(-1);
    }
    else if(pid == 0)
    {
        //child
        sleep(5);
        exit(0);
    }
    else
    {
        //parents
        //int childpid = wait(NULL);
        int childpid;
        while((childpid = waitpid(pid,NULL,WNOHANG)) == 0)
        {
            printf("没有子进程退出，你可以休息一下...\n");
            sleep(1);
        }
        printf("%d ----- %d\n", pid, childpid);
    }
    return 0;
}
```





退出子进程返回值/wait的参数获取到的值/waitpid的参数获取到的值：status

```c
//非阻塞等待一般才去循环操作，循环等待
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
   
int main()
{
    pid_t pid = fork();
    if(pid < 0)
    {
        perror("fork error\n");
        exit(-1);
    }
    else if(pid == 0)
    {
        //child
        sleep(5);
        exit(99);
    }
    else
    {
        //parents
        int status;
        int childpid;
        while((childpid = waitpid(pid,&status,WNOHANG)) == 0)
        {
            printf("没有子进程退出，你可以休息一下...\n");
            sleep(1);
        }
        printf("%d ----- %d ----- %d\n", pid, childpid, status);
    }
    return 0;
}
//输出：12485 ----- 12485 ----- 25344
```

解释一下为什么status为什么是99?

99		   对应的16进制		0x63

25344    对应的16进制		0x6300

![image-20230814072008230](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230814072008230.png)

代码转换：（二进制）

1.判断进程是否正常退出：status & 0x7f == 0;			

2.获取退出的实际返回值：(status >> 8) & oxff

系统提供的宏：

1.判断进程是否正常退出：WIFEXITED(status)

2.获取退出的实际返回值：WEXITSTATUS(status)

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

int main()
{
    pid_t pid = fork();
    if(pid < 0)
    {
        perror("fork error\n");
        exit(-1);
    }
    else if(pid == 0)
    {
        //child
        sleep(5);
        exit(99);
    }
    else
    {
        //parents
        int status;
        int childpid;
        while((childpid = waitpid(pid,&status,WNOHANG)) == 0)
        {
            printf("没有子进程退出，你可以休息一下...\n");
            sleep(1);
        }
        if((status & 0x7f) != 0)
        {
            printf("程序异常退出\n");
            return -1;
        }
        int ret = (status >> 8) & 0xff;
        printf("%d ----- %d ----- %d\n", pid, childpid, ret);
    }
    return 0;
}
//输出：
//没有子进程退出，你可以休息一下...
//没有子进程退出，你可以休息一下...
//没有子进程退出，你可以休息一下...
//没有子进程退出，你可以休息一下...
//没有子进程退出，你可以休息一下...
//12858 ----- 12858 ----- 99
```



# 5.程序替换

程序替换：替换一个进程（psb）正在调度运行的程序（指令集）。

运行一个程序，就是把程序加载到内存当中，创建一个pcb，实现操作系统对它的调度运行。

 ![image-20230814081920656](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230814081920656.png)

程序替换：

当应用程序访问虚拟地址时，如果对应的物理页面不在内存中，操作系统需要通过一种叫做页面置换（page swapping）的机制将所需的数据从磁盘读取到内存中，并更新页表。

页面置换是内存管理的重要部分，用于将磁盘上的数据移动到内存中，以便应用程序可以访问它。当物理内存空间不足时，操作系统需要选择某些页面进行置换，腾出空闲的物理页面用于加载新的数据。

操作系统使用各种页面置换算法来选择要置换的页面。常见的算法包括最近未使用（LRU）算法、先进先出（FIFO）算法、最少经常使用（LFU）算法等。这些算法根据页面的访问模式和频率来决定哪些页面最有可能被再次使用，然后置换出较少使用的页面。

当一个页面被置换出去时，它的内容会写入到磁盘上的一个页面文件（或交换文件）中，以便在需要时可以再次加载到内存中。同时，页表会被更新，将虚拟地址与新载入的物理页面重新映射。

通过页面置换机制，操作系统能够在有限的物理内存下提供给应用程序一个伪装的、比实际物理内存更大的地址空间。这样，应用程序可以处理比物理内存更大的数据集，提高系统的灵活性和性能。



程序控制块（PCB，Process Control Block）是操作系统用来管理和跟踪进程信息的数据结构，它包含了与一个进程相关的各种属性和状态信息。PCB通常存在于操作系统内核的内存中。

每当一个进程被创建，操作系统会为该进程分配一个独立的PCB，用来存储该进程的相关信息。这些信息包括进程标识符（PID）、优先级、程序计数器（PC）、寄存器的值、内存分配情况、打开的文件等。

PCB在操作系统内核的内存空间中管理，通常以链表或数组的形式组织。操作系统通过PCB来跟踪和管理所有活动进程的状态和执行情况。当进程调度时，操作系统可以快速访问和更新PCB中的信息，以便恢复、暂停、切换和终止进程。

需要注意的是，PCB通常只存在于操作系统内核的内存中，无法直接由用户程序进行访问。用户程序可以通过系统调用接口与操作系统交互，但对于PCB的具体操作和修改，是由操作系统内部负责管理的。



在一个进程中执行程序替换接口，就能实现改变当前调用进程运行的程序。

程序替换，只是替换了运行的程序，pcb还是原来的pcb，没有改变，只不过里边的一些信息被重新初始化了（虚拟地址空间、页表.....），修改为新的程序的信息

和数据。（进程id没有发生改变）



接口：

exec函数族：一个系统调用接口 + 5个库函数。

```shell
man execl			#查看exec函数族
```

```c
extern char **environ; 		//存储所有环境变量
int execl(const char *pathname, const char *arg, .../* (char  *) NULL */);
int execlp(const char *file, const char *arg, .../* (char  *) NULL */);
int execle(const char *pathname, const char *arg, .../*, (char *) NULL, char *const envp[] */);
int execv(const char *pathname, char *const argv[]);
int execvp(const char *file, char *const argv[]);

//系统调用接口
int execvpe(const char *file, char *const argv[],char *const envp[]);   /	
    int execvpe(const char *file, char *const argv[],char *const envp[]);
//5个库函数封装了系统调用接口，实际每个库函数都是3个参数，两个参数的最后由系统调用接口设置环境变量。（环境变量具有父子传递的作用）


//参数：
//pathname：替换的新程序的文件路径名
//arg：程序运行参数		后面的...表示不订定参（没有参数了以NULL作为结尾）
//envp：环境变量

//pathname给命令的全路径（/usr/bin），file给命令名称就可以（ls）

//exec函数有p时，程序文件若是命令程序可以不用带路径，带p的函数，常用于执行替换命令程序时使用。
//exec函数有e时，表示由我们自己设定环境变量，否则默认使用原有的环境变量，默认去path环境变量指定的路径下找程序。
//exex函数有e时，表示由我们自己设定环境变量，否则默认使用原有的环境变量	
//exec函数有l时arg是不定参一个一个给，有v时argv是字符串指针数组给。
```

```shell
whereis ls					#查看ls程序在哪
```

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

int main(int argc,char* argv[])
{
    pid_t pid = fork();

    if(pid < 0)
    {
        perror("fork error");
        exit(-1);
    }
    else if(pid == 0)
    {
        int ret =execl("/usr/bin/ls", "ls", "-l", NULL);
        
        if(ret < 0)
        {
            perror("程序替換失敗");
            return -1;
        }
    
        //无论替换成功还是失败下面两行都不会执行，替换成功执行替换之后的程序，替换失败直接退出
        printf("程序替换成功\n");
        exit(0);
    }
    wait(NULL);
    printf("子进程已经退出\n");

    return 0;
}

//输出结果：
-rwxrwxr-x 1 jwc jwc 16912 8月  14 12:27 exchange
-rw-rw-r-- 1 jwc jwc   693 8月  14 12:27 exchange.c
-rw-rw-r-- 1 jwc jwc    89 8月  14 12:16 makefile
-rwxrwxr-x 1 jwc jwc 16768 8月  14 11:28 myenv
-rw-rw-r-- 1 jwc jwc   350 8月  14 11:28 myenv.c
-rwxrwxr-x 1 jwc jwc 16912 8月  14 05:25 wait
-rw-rw-r-- 1 jwc jwc   482 8月  14 07:34 wait.c
-rwxrwxr-x 1 jwc jwc 17008 8月  14 07:37 waitpid
-rw-rw-r-- 1 jwc jwc   781 8月  14 07:37 waitpid.c
子进程已经退出
```



```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

int main(int argc,char* argv[])
{
    pid_t pid = fork();

    if(pid < 0)
    {
        perror("fork error");
        exit(-1);
    }
    else if(pid == 0)
    {
        int ret =execl("/ls", "ls", "-l", NULL);
        
        if(ret < 0)
        {
            perror("程序替換失敗");
            return -1;
        }
    
        //无论替换成功还是失败下面两行都不会执行，替换成功执行替换之后的程序，替换失败直接退出
        printf("程序替换成功\n");
        exit(0);
    }
    wait(NULL);
    printf("子进程已经退出\n");

    return 0;
}

//输出结果：
程序替換失敗: No such file or directory
子进程已经退出
```



```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

int main(int argc,char* argv[])
{
    pid_t pid = fork();

    if(pid < 0)
    {
        perror("fork error");
        exit(-1);
    }
    else if(pid == 0)
    {
        int ret =execlp("ls", "ls", "-l", NULL);
        
        if(ret < 0)
        {
            perror("程序替換失敗");
            return -1;
        }
    
        //无论替换成功还是失败下面两行都不会执行，替换成功执行替换之后的程序，替换失败直接退出
        printf("程序替换成功\n");
        exit(0);
    }
    wait(NULL);
    printf("子进程已经退出\n");

    return 0;
}

//输出结果
总用量 100
-rwxrwxr-x 1 jwc jwc 16912 8月  14 12:31 exchange
-rw-rw-r-- 1 jwc jwc   685 8月  14 12:31 exchange.c
-rw-rw-r-- 1 jwc jwc    89 8月  14 12:16 makefile
-rwxrwxr-x 1 jwc jwc 16768 8月  14 11:28 myenv
-rw-rw-r-- 1 jwc jwc   350 8月  14 11:28 myenv.c
-rwxrwxr-x 1 jwc jwc 16912 8月  14 05:25 wait
-rw-rw-r-- 1 jwc jwc   482 8月  14 07:34 wait.c
-rwxrwxr-x 1 jwc jwc 17008 8月  14 07:37 waitpid
-rw-rw-r-- 1 jwc jwc   781 8月  14 07:37 waitpid.c
子进程已经退出

```



```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main(int argc,char* argv[])
{
    for(int i = 0; argv[i] != NULL; i++)
    {
        printf("argv[%d] = %s\n", i, argv[i]);
    }

    extern char **environ;


    for(int i = 0; environ[i] != NULL; i++)
    {
        printf("environ[%d] = %s\n", i, environ[i]);
    }
    return 0;
}

//输出结果：
jwc@jwc-virtual-machine:~/桌面/2.进程控制$ ./myenv -l -al
argv[0] = ./myenv
argv[1] = -l
argv[2] = -al
environ[0] = SHELL=/bin/bash
environ[1] = LANGUAGE=zh_CN:zh
environ[2] = PWD=/home/jwc/桌面/2.进程控制
environ[3] = LOGNAME=jwc
environ[4] = XDG_SESSION_TYPE=tty
environ[5] = MOTD_SHOWN=pam
environ[6] = HOME=/home/jwc
environ[7] = LANG=zh_CN.UTF-8
environ[8] = LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:
environ[9] = SSH_CONNECTION=192.168.0.87 60143 192.168.0.202 22
environ[10] = LESSCLOSE=/usr/bin/lesspipe %s %s
environ[11] = XDG_SESSION_CLASS=user
environ[12] = TERM=xterm
environ[13] = LESSOPEN=| /usr/bin/lesspipe %s
environ[14] = USER=jwc
environ[15] = DISPLAY=localhost:11.0
environ[16] = SHLVL=1
environ[17] = XDG_SESSION_ID=100
environ[18] = XDG_RUNTIME_DIR=/run/user/1000
environ[19] = SSH_CLIENT=192.168.0.87 60143 22
environ[20] = XDG_DATA_DIRS=/usr/local/share:/usr/share:/var/lib/snapd/desktop
environ[21] = PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
environ[22] = DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus
environ[23] = SSH_TTY=/dev/pts/1
environ[24] = _=./myenv
environ[25] = OLDPWD=/home/jwc/桌面
```



```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

int main(int argc,char* argv[])
{
    pid_t pid = fork();

    if(pid < 0)
    {
        perror("fork error");
        exit(-1);
    }
    else if(pid == 0)
    {
        //int ret =execlp("myenv", "myenv", "-l", NULL);          // myenv是去PATH环境变量指定的位置下找的，找不到替换失败,
        int ret =execlp("./myenv", "myenv", "-l", NULL);          // ./myenv是在当前目录下找的，找到替换成功
        
        if(ret < 0)
        {
            perror("程序替換失敗");
            return -1;
        }
    
        //无论替换成功还是失败下面两行都不会执行，替换成功执行替换之后的程序，替换失败直接退出
        printf("程序替换成功\n");
        exit(0);
    }
    wait(NULL);
    printf("子进程已经退出\n");

    return 0;
}

//输出结果：
argv[0] = myenv
argv[1] = -l
environ[0] = SHELL=/bin/bash
environ[1] = LANGUAGE=zh_CN:zh
environ[2] = PWD=/home/jwc/桌面/2.进程控制
environ[3] = LOGNAME=jwc
environ[4] = XDG_SESSION_TYPE=tty
environ[5] = MOTD_SHOWN=pam
environ[6] = HOME=/home/jwc
environ[7] = LANG=zh_CN.UTF-8
environ[8] = LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:
environ[9] = SSH_CONNECTION=192.168.0.87 60143 192.168.0.202 22
environ[10] = LESSCLOSE=/usr/bin/lesspipe %s %s
environ[11] = XDG_SESSION_CLASS=user
environ[12] = TERM=xterm
environ[13] = LESSOPEN=| /usr/bin/lesspipe %s
environ[14] = USER=jwc
environ[15] = DISPLAY=localhost:11.0
environ[16] = SHLVL=1
environ[17] = XDG_SESSION_ID=100
environ[18] = XDG_RUNTIME_DIR=/run/user/1000
environ[19] = SSH_CLIENT=192.168.0.87 60143 22
environ[20] = XDG_DATA_DIRS=/usr/local/share:/usr/share:/var/lib/snapd/desktop
environ[21] = PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
environ[22] = DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus
environ[23] = SSH_TTY=/dev/pts/1
environ[24] = _=./exchange
environ[25] = OLDPWD=/home/jwc/桌面
子进程已经退出
    
//总结：如果替换掉的是命令程序，可以不加路径，如果是自己的程序，要加路径
```



```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

int main(int argc,char* argv[])
{
    pid_t pid = fork();

    if(pid < 0)
    {
        perror("fork error");
        exit(-1);
    }
    else if(pid == 0)
    {
        char* env[3];
        env[0] = "MYVAL=1000";
        env[1] = NULL;
        int ret =execle("./myenv", "myenv", "-l", NULL, env);          // 参数一定是以NULL作为结尾的，在NULL之后才是真正的环境变量
        
        //int ret =execle("./myenv", "myenv", "-l", NULL, NULL);       // 如果自己给定的环境变量是NULL，表示没有环境变量(不想改变当前的环境变量，就给个NULL)
        
        //很少会以这种方式设置环境变量的，通常设置环境变量也不会改变原有的，会用putenv和setenv这些函数来设置环境变量，而不是程序替换的时候设置环境变量
        //程序替换掉的时候，直接指定，很大概率上会把原有的变没了

        if(ret < 0)
        {
            perror("程序替換失敗");
            return -1;
        }
    
        //无论替换成功还是失败下面两行都不会执行，替换成功执行替换之后的程序，替换失败直接退出
        printf("程序替换成功\n");
        exit(0);
    }
    wait(NULL);
    printf("子进程已经退出\n");

    return 0;
}

//输出结果：
argv[0] = myenv
argv[1] = -l
environ[0] = MYVAL=1000
子进程已经退出
```



```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

int main(int argc,char* argv[])
{
    pid_t pid = fork();

    if(pid < 0)
    {
        perror("fork error");
        exit(-1);
    }
    else if(pid == 0)
    {
        char* env[3];
        env[0] = "MYVAL=1000";
        env[1] = NULL;
        //int ret =execle("./myenv", "myenv", "-l", NULL, env);          // 参数一定是以NULL作为结尾的，在NULL之后才是真正的环境变量
        
        //int ret =execle("./myenv", "myenv", "-l", NULL, NULL);       // 如果自己给定的环境变量是NULL，表示没有环境变量(不想改变当前的环境变量，就给个NULL)
        
        //很少会以这种方式设置环境变量的，通常设置环境变量也不会改变原有的，会用putenv和setenv这些函数来设置环境变量，而不是程序替换的时候设置环境变量
        //程序替换掉的时候，直接指定，很大概率上会把原有的变没了

        char* myarg[4];
        myarg[0] = "./myenv";
        myarg[1] = "-a";
        myarg[2] = "-l";
        myarg[3] = NULL;

        int ret = execve("./myenv", myarg, env);


        if(ret < 0)
        {
            perror("程序替換失敗");
            return -1;
        }
    
        //无论替换成功还是失败下面两行都不会执行，替换成功执行替换之后的程序，替换失败直接退出
        printf("程序替换成功\n");
        exit(0);
    }
    wait(NULL);
    printf("子进程已经退出\n");

    return 0;
}

//输出结果：
argv[0] = ./myenv
argv[1] = -a
argv[2] = -l
environ[0] = MYVAL=1000
子进程已经退出
```



```
xshell中进入和退出全屏的操作：alt + enter
```



# 6.自己实现一个mini的shell

从零开始编写一个minishell。

shell是什么？

shell是一个命令行解释器。

1.捕捉键盘输入；	scanf（按空格截止）	fgets	gets

2.解析输入信息；（命令名称、运行参数）

3.创建子进程；（子进程也是一个shell）	fork

​		让子进程执行对应命令名称的程序。（程序替换）	execvp

​				子进程程序替换失败必须退出，成功运行完命令程序会自己退出的（正常退出）。（只希望有一个终端）	exit

4.等待子进程退出。（避免子进程是僵尸进程，僵尸进程会造成资源泄漏。）		wait

```shell
ps aux | wc -l		#查看当前总共运行了多少个进程
wc					#是一个用于统计文件中字节数（-c选项）、行数（-l选项）、单词数（-w选项）和字符数（-m选项）的命令
int chdir(const char *path);		#改变系统工作目录（函数）
```

```c
//实现一个minishell
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

int main(int argc,int* argv[])
{
    while(1)
    {
        printf("[user@host path]$ ");
        fflush(stdout);
        char buf[1024] = {0};
        fgets(buf, 1023, stdin);
        buf[strlen(buf) - 1] = '\0';

        int myargc = 0;
        char* ptr = buf, *myargv[32] = {NULL};
        while(*ptr != '\0')
        {
            if(*ptr != ' ')
            {
                myargv[myargc] = ptr;
                myargc++;
                while(*ptr != '\0' && *ptr != ' ')
                    ptr++;
                *ptr = '\0';
            }
            ptr++;
        }
        myargv[myargc] = NULL;

        /*
           for(int i = 0; i < myargc; i++)
           {
           printf("[%s]\n", myargv[i]);
           }
        */

        if(strcmp("cd", myargv[0]) == 0)
        {
            chdir(myargv[1]);
            continue;
        }

        pid_t pid = fork();
        if(pid < 0)
        {
            perror("fork error");
            continue;
        }
        else if(pid == 0)
        {
            //子进程
            execvp(myargv[0], myargv);
            perror("execvp error");     //系统调用错误的原因
            exit(-1);           //替换成功执行不到，替换失败退出
        }

        wait(NULL);        //父进程等待
    }

    return 0;
}
```



# 7.总结

进程控制：创建、退出、等待、替换。

1.创建：

pid_t fork(void)	复制父进程创建子进程，父子进程代码共享，数据独有。

返回值：父进程返回值大于0（子进程的pid），子进程返回0，失败返回-1。

进程创建流程：写时拷贝技术。

pid_t vfork(void)	复制父进程创建子进程。	父子进程共用同一个虚拟地址空间。

父进程创建子进程之后会阻塞，直到子进程exit退出或程序替换后才运行。

2.退出：

退出方式：main函数中rreturn		调用库函数exit		调用系统调用接口_exit

终止场景：正常退出（上面三种方式退出的进程）、异常退出（在我们程序运行过程中还没有运行到正常退出位置时候，突然程序因为某个错误崩溃退出了）

获取上一次系统调用错误原因的接口：perror、strerror。

3.等待：

父进程等待子进程退出。

目的：获取退出子进程的返回值，以及释放资源，避免僵尸进程的产生。

wait：等待任意一个子进程的退出，以及有退出的子进程直接进行处理。

waitpid：可以等待任意一个子进程的退出，也可以等待任意的子进程退出，并且可以将自己的接口设置为非阻塞方式，waitpid的默认是阻塞接口。

阻塞接口（函数）：为了完成一个功能，发起一个调用，但是不具备完成条件，一直等待。

非阻塞接口（函数）：为了完成一个功能，发起一个调用，但是不具备完成条件，立即返回。

waitpid要是非阻塞等待一般是循环等待。（WNOHANG）

进程返回值的获取：status。（二进制和宏）

4.替换

替换进程正在调度运行的程序。

如何替换：加载一个新的程序到内存中，更新当前进程的页表映射信息到新的程序上。

为什么要有进程替换：希望创建的子进程能够完成一个新的任务。

为什么不是父进程完成这个任务呢：自己完成这个任务是由有风险的，子进程完成这个任务崩了对父进程没有任何的影响，父进程再创建一个子进程再去完成这个

任务。（多进程更加稳定）（比如shell完成一个命令，命令异常崩了，会毁坏shell，也就是终端坏了，下一个shell命令没有办法运行了）

库函数：

execl：

execlp：

execle：

execv：

execvp：

系统调用接口：

execve：

l和v的区别：参数的赋予方式不一样，l是一个一个参数给的（不定参），v是给一个字符串指针数组。

有没有p的区别：新的程序是否需要带路径。（没有p必须要带路径，有了p可以不带也可以带，不带这个程序就必须在PATH环境变量指定的位置能够找到。）

有没有e的区别：是否自己设置环境变量。（有e就是要自己设置这个进程有哪些环境变量，没有e代表使用默认当前进程继承自父进程的环境变量，没有e默认用的

都是父进程的环境变量。）（父子进程环境变量具有继承的特性。）



# 8.pid和id的区别

"pid" 和 "id" 是两个不同的概念，具有不同的含义和用途：

1. PID（进程标识符）：PID 是操作系统中用于唯一标识一个正在运行的进程的数字标识符。每个正在运行的进程都会被分配一个唯一的 PID。PID 的范围通常是从 0 到最大整数值（取决于操作系统）。PID 在操作系统中具有重要的作用，例如通过 PID 可以查找和管理进程、监视资源使用情况、进行进程间通信等。
2. ID（标识符）：ID 是一个更加泛化的术语，可以指代许多不同的标识符，具体含义取决于上下文。在计算机科学和信息技术领域，ID 可能指代用户 ID、文件 ID、会话 ID 等。这些标识符用于唯一标识不同的实体或对象，以便进行识别、管理和授权。每种类型的 ID 在相应的领域都有不同的意义和用途。

总结来说，PID 是用于标识和管理正在运行的进程的数字标识符，而 ID 是一个更广义的术语，可以用于标识许多不同类型的对象，如用户、文件、会话等。
