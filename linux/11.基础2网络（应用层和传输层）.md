# 1.目标

针对TCP/IP四层模型中各层的典型协议进行解析。

网络基础2：应用层和传输层的典型协议解析。



# 2.应用层协议：自定制协议，知名协议HTTP

应用层负责应用程序之间的沟通，程序员自己定义数据的组织格式。

## 2.1自定义协议

自定制协议：程序员自己定制数据格式。

### 2.1.1例子：网络版计算器

网络版计算器：客户端将两个数字，以及运算符，传输给服务端。

服务端对数据进行运算，将结果返回给客户端。

在网络通信中，操作系统只认二进制数据串，数字的传输会涉及到网络字节序的转换，将这两个数字和跟运算符按照某种格式组织到一起转换成字符串发送过去，

这是最简单的。

比如：

int num1 =11;

int num2 = 22;

char operator = '+';

11;22;+;	(;是特殊字符，按照;作为间隔符)（这里要拆分字符串）

还有一种比较的方法是使用结构体组织数据：

struct data_t

{

​	int num1;

​	int num2;

​	char op;

}tmp;

tmp.num1 = 11;

tmp.num2 = 22;

tmp.op = '+';

```c++
//文件名：tcpsocket.hpp（文件没有改变过，网络计算器只是改变了服务端和客户端的代码）
#include <cstdio>
#include <iostream>
#include <string>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <unistd.h>

#define LISTEN_BACKLOG 5
#define CHECK_RET(q) if((q) == false){return -1;}

struct data_t 
{
    int num1;
    int num2;
    char op;    //运算符operator的简写
};

class TcpSocket
{
    private:
        int _sockfd;        //操作句柄

    public:
        TcpSocket()
            :_sockfd(-1)
        {
            
        }

        int GetFd()
        {
            return _sockfd;
        }

        void SetFd(int fd)
        {
            _sockfd = fd;
        }

        //创建套接字
        bool Socket()
        {
            //tcp提供的是字节流传输服务，需要使用流式套接字SOCK_STREAM
            _sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if(_sockfd < 0)
            {
                //创建失败
                perror("socket error");
                return false;
            }
            return true;
        }

        //绑定地址信息
        bool Bind(const std::string &ip, const uint16_t port)
        {
            struct sockaddr_in addr;
            addr.sin_family = AF_INET;
            addr.sin_port = htons(port);
            addr.sin_addr.s_addr = inet_addr(ip.c_str());       //返回字符串的首地址，和下面取字符串的首元素的地址一样
            //addr.sin_addr.s_addr = inet_addr(&ip[0]);
            socklen_t len = sizeof(sockaddr_in);
            int ret = bind(_sockfd, (sockaddr*)&addr, len);
            if(ret < 0)
            {
                perror("bind error");
                return false;
            }
            return true;
        }

        //切换到监听状态
        bool Listen(int backlog = LISTEN_BACKLOG)
        {
            //listen(描述符, 同一时间连接数);
            int ret = listen(_sockfd, backlog);
            if(ret < 0)
            {
                perror("listen error");
                return false;
            }
            return true;
        }

        //连接服务器
        bool Connect(const std::string &ip, const int port)
        {
            struct sockaddr_in addr;
            addr.sin_family = AF_INET;
            addr.sin_port = htons(port);
            addr.sin_addr.s_addr = inet_addr(ip.c_str());       //返回字符串的首地址，和下面取字符串的首元素的地址一样
            //addr.sin_addr.s_addr = inet_addr(&ip[0]);
            socklen_t len = sizeof(sockaddr_in);
            //connect(描述符, 服务端地址, 地址长度);
            int ret = connect(_sockfd, (sockaddr*)&addr, len);
            if(ret < 0)
            {
                perror("connect error");
                return false;
            }
            return true;
        }

        //服务端获取新连接
        bool Accept(TcpSocket* sock, std::string *ip = NULL, uint16_t* port = NULL)
        {
            //原来的套接字是监听套接字，新创建的套接字是通信套接字
            //int accept(监听套接字, 回去客户端地址, 长度);
            sockaddr_in addr;
            socklen_t len = sizeof(sockaddr_in);
            int newfd = accept(_sockfd, (sockaddr*)&addr, &len);
            if(newfd < 0)
            {
                perror("accept error");
                return false;
            }

            sock->_sockfd = newfd;
            if(ip != NULL)
            {
                *ip = inet_ntoa(addr.sin_addr);
            }

            if(port != NULL)
            {
                *port = ntohs(addr.sin_port);
            }
            return true;
        }

        //接收数据
        bool Recv(std::string *buf)
        {
            //int recv(描述符, 空间, 数据长度, 标志位);     标志位给0是默认阻塞接收
            //返回值：实际获取大小  返回值是0不是没有接收数据，是连接断开了     -1是出错了
            char tmp[4096] = {0};       
            int ret = recv(_sockfd, tmp, 4096, 0);
            if(ret < 0)
            {
                //出错
                perror("recv error");
                return false;
            }
            else if(ret == 0)
            {
                //连接断开
                perror("peer shutdown");
                return false;
            }
            buf->assign(tmp, ret);      //拷贝字符串，参数是字符串首地址和字符串长度。
            return true;
        }

        //发送数据
        bool Send(const std::string &data)
        {
            //int send(描述符, 数据, 长度, 标志位);         标志位为0表示阻塞发送
            int total = 0;      //记录发送了多少数据
            
            while(total < data.size())
            {
                //发送数据一般不是一次性发送的，一般是多次发送，从上一次
                int ret = send(_sockfd, data.c_str() + total,  data.size() - total, 0);
                //int ret = send(_sockfd, &data[0] + total, data.size() - total, 0);      //和上面作用一样
                if(ret < 0)
                {
                    perror("send error");
                    return false;
                }
                total += ret;
            }
            return true;
        }

        bool Close()
        {
            if(_sockfd != -1)
            {
                close(_sockfd);
            }
            return true;
        }
};
```

```c++
//文件名：tcp_cli.cpp
#include "tcpsocket.hpp"

//客户端
int main(int argc, char* argv[])
{
    //客户端可以不绑定地址信息，但是必须知道服务端的地址信息
    if(argc != 3)
    {
        printf("usage：./tcp_cli srv_ip srv_port\n");
        return -1;
    }

    std::string srv_ip = argv[1];
    uint16_t srv_port = std::stoi(argv[2]);

    TcpSocket cli_sock;
    //1.创建套接字
    CHECK_RET(cli_sock.Socket());
    //2.绑定地址信息（不推荐绑定）
    //3.向服务端发起连接
    CHECK_RET(cli_sock.Connect(srv_ip, srv_port));
    while(1)
    {
        //4.收发数据
        struct data_t tmp;
        tmp.num1 = 11;
        tmp.num2 = 22;
        tmp.op = '+';
        
        /*
         *第一种发送和接收数据方法：字符串发送
        std::string buf;
        buf.resize(sizeof(struct data_t));      //预留字符串空间为结构体大小
        memcpy(&buf[0], &tmp, sizeof(struct data_t));   //内存拷贝，不用字符串拷贝是因为遇到0为停止
        //客户端向服务端发送数据，客户端出问题直接退出，服务端接收出问题不能直接退出，还要接收下一个客户端
        CHECK_RET(cli_sock.Send(buf));
    
        //sned(sockfd, (void*)&tmp, sizeof(struct data_t), 0);       标识符发送，举个例子(0是标志位，表示阻塞发送)
        
        //接收数据
        //清空缓冲区
        buf.clear();
        CHECK_RET(cli_sock.Recv(&buf));
        */

        //第二种发送和接收数据的方法：标识符发送
        int fd = cli_sock.GetFd();
        send(fd, (void*)&tmp, sizeof(struct data_t), 0);
        
        //接收数据
        int result;
        recv(fd, &result, sizeof(int), 0);

        //打印接收的数据
        std::cout << result << std::endl;
    }
    //5.关闭套接字
    CHECK_RET(cli_sock.Close());
    return 0;
}
```

```c++
//文件名：tcp_srv.cpp
#include "tcpsocket.hpp"
#include <pthread.h>

void *thr_entry(void* arg)
{
    bool ret;
    TcpSocket* cli_sock = (TcpSocket*)arg;
    while(1)
    {
        //5.收发数据    使用获取的新建套接字进行通信
        int fd = cli_sock->GetFd();
        struct data_t tmp;
        recv(fd, &tmp, sizeof(struct data_t), 0);
        int result;
        if(tmp.op == '+')
        {
            result = tmp.num1 + tmp.num2;
        }
        else if(tmp.op == '-')
        {
            result = tmp.num1 - tmp.num2;
        }
        else 
        {
            //其余操作，只是演示
            result = 100;
        }

        //发送
        send(fd, &result, sizeof(int), 0);

        /*
        std::string buf;
        ret = cli_sock->Recv(&buf);
        if(ret == false)
        {
            cli_sock->Close();
            delete cli_sock;
            return NULL;
        }
        std::cout << "client say: " << buf << std::endl;

        buf.clear();
        std::cout << "server say: ";
        std::cin >> buf;
        ret = cli_sock->Send(buf);

        if(ret == false)
        {
            cli_sock->Close();
            delete cli_sock;
            return NULL;
        }
        */
    }
    //关闭套接字
    cli_sock->Close();
    delete cli_sock;
    return NULL;
}

//服务端
int main(int argc, char* argv[])
{
    //通过程序运行参数指定服务端要绑定的地址
    //  ./tcp_rev 192.168.0.203(IP地址) 9000(端口号)
    if(argc != 3)
    {
        //参数包含文件名本身，如果不是3，就是传参错误
        printf("usage：./tep_rev 192.168.0.203 9000\n");
        return -1;
    }

    std::string srvip = argv[1];
    uint16_t srvport = std::stoi(argv[2]);  //stoi是将字符串转换为整数类型
    TcpSocket lst_lock;     //监听套接字
    //1.创建套接字
    CHECK_RET(lst_lock.Socket());
    //2.绑定地址信息
    CHECK_RET(lst_lock.Bind(srvip, srvport));
    //3.开始监听
    CHECK_RET(lst_lock.Listen());
    while(1)
    {
        //4.获取新建连接
        TcpSocket* cli_sock = new TcpSocket();
        std::string cli_ip;
        uint16_t cli_port;
        bool ret = lst_lock.Accept(cli_sock, &cli_ip, &cli_port);
        if(ret == false)
        {
            continue;
        }

        std::cout << "get newconn" << cli_ip << "-" << cli_port << "\n";

        

        //创建线程专门负责与指定客户端的通信
        pthread_t tid;
        pthread_create(&tid, NULL, thr_entry, (void*)cli_sock);
        pthread_detach(tid);    //分离线程，之后就不用关心了
    }
    //6.关闭套接字
    lst_lock.Close();
    return 0;
}
```

### 2.1.2序列化和反序列化概念

序列化：将数据对象按照指定协议进行组织实现持久化存储或者网络通信传输的二进制数据串的过程。

反序列化：按照指定协议，将二进制数据串解析得到各个数据对象的过程。

课后可以调研一下：序列化方式的种类以及各自使用的场景。

json序列化，protobuf序列化

解析性能是解析数据，传输性能是传输数据，解析性能和传输性能不挂钩，解析性能好的传输性能不一定好，传输性能好的解析性能不一定好。

自定义协议：程序员自定定制数据格式，但是定制的同时需要考虑传输性能以及解析性能，如何组织更加适用当前的应用场景。



## 2.2HTTP协议：超文本传输协议

http协议格式	http协议实现	http协议的数据结构都是一个说法。

https协议：对http进行了加密。

html、xml

```html
<html>
    <body>
    <h1 align = "center" color = "red">Hello World</h1>
    </body>    
</html>
```

Fiddler 4工具/软件：专门用来抓浏览器的包的。（http通信包的）

Wireshark工具/软件：抓流进网卡的数据包。

### 2.2.1Fiddler的下载和安装

下载地址（经典版、不收费）：https://www.telerik.com/download/fiddler

只能抓取http/https协议的包，默认只能抓取http协议的包，需要配置抓取https协议的包。



配置https：

Tools->options->HTTPS，进去之后全部勾上左边选项（有一个红色的也勾上，以后不确定会不会有）->然后重启。



### 2.2.2http协议格式：

### 首行

前景信息：

http是一个明文字符串传输协议；

http在传输层基于tcp协议实现；

http是一个简单的请求-响应协议；（客户端请求，服务端响应）

https协议格式：http数据结构、http协议实现。

首行：请求行、响应行（对于请求与响应的简单关键描述）

头部：对于请求或者响应或者正文的一些关键描述。

由一个个键值对组成key：val，每个键值对以\r\n结尾。

空行：\r\n，间隔头部与正文；\r\n\r\n表示头部结尾

正文：客户端提交给服务端，或者服务端响应给客户端的数据。



**首行-请求行：请求方法 URL（URI，网址） 协议版本\r\n。**

#### 2.2.2.1请求方法：（一共有9种，这里说常见的3种）

GET：从服务端获取实体资源，请求没有正文，但是也可以提交数据，但是提交的数据没有在正文中而是在URL中。

1.get提交数据不安全；（URL是网址，网址不加密，直接显示）	2.url长度有限制；

HEAD：功能与GET类似，但是不要正文实体。

POST：向服务端提交数据，请求有正文，数据放在正文中。

get和head的区别？

get和head在功能上没有区别，都是向服务器请求实际资源，只不过get要求有正文，head要求不要正文，这样服务器就不用返回正文数据了，获取头部信息的时

候便捷一点。

get和post的区别？

从功能上get主要是获取资源，post主要是提交数据，并且get没有正文，post有正文，post提交的数据是放在正文中的，get也能提交数据，是放在url中的，这种

方式不太安全，容易泄漏隐私，并且长度有限制（一般是4字节或者8字节）。



#### 2.2.2.2URL（网址）

URL（Uniform Resource Locator）是统一资源定位符的缩写，通常被称为网址。它是用于标识和定位互联网上资源（如网页、文件、图片等）的字符串。URL由多个部分组成，包括协议（如HTTP、HTTPS）、域名（[例如www.example.com](http://xn--www-uc0ep96b.example.com/)）、路径和查询参数等，用于指示所需资源的位置和获取方式。

通过在浏览器的地址栏中输入URL，您可以访问特定的网站、页面或其他网络资源。URL是互联网上资源定位的标准方式，使得用户可以方便地查找和访问所需的内容。



URL：网址，统一资源定位符，用于定位网络中某个主机上的某个资源。

组成：协议名称://用户名:密码@域名:端口/资源路径?查询字符串#标识符

域名：服务器别名，最终访问服务器需要经过域名解析得到服务器IP。

资源路径：这个路径是一个相对于当前目录的相对路径。

查询字符串：提交给服务器的数据，由一个个key=val形式键值对组成，键值对之间以&符号间隔。

标识符：用来查找网页中的某个字段，用来搜索网页。（和文件查找字段ctrl + f作用一样）

urlencode：编码，用户请求的资源路径，或者查询字符串中存在特殊字符，则有可能与url中的特殊字符冲突，将特殊字符每个字节转换为16进制数字字符，并前

缀%。

urldecode：解码，遇到%则认为紧随其后的两个字符进行了编码，将这两个字符转换为数字，第一个数字左移4位加上第二个数字。

![](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230929212139706.png)

域名信息文件：C:\Windows\System32\drivers\etc\hosts（可以在里面添加域名，需要管理员权限）

```
# Copyright (c) 1993-2009 Microsoft Corp.
#
# This is a sample HOSTS file used by Microsoft TCP/IP for Windows.
#
# This file contains the mappings of IP addresses to host names. Each
# entry should be kept on an individual line. The IP address should
# be placed in the first column followed by the corresponding host name.
# The IP address and the host name should be separated by at least one
# space.
#
# Additionally, comments (such as these) may be inserted on individual
# lines or following the machine name denoted by a '#' symbol.
#
# For example:
#
#      102.54.94.97     rhino.acme.com          # source server
#       38.25.63.10     x.acme.com              # x client host

# localhost name resolution is handled within DNS itself.
#	127.0.0.1       localhost
#	::1             localhost

//新添加的(修改之后就无法访问这个网站了)
127.0.0.1	taobao.com
```

还有，更改适配器选项：

有线修改以太网

无线修改wlan

右键修改属性点击internet协议版本4（TCP/IPv4）

![image-20230929214745727](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230929214745727.png)

自动获得DNS服务器地址地址，域名不光看本地文件配置的，本地文件没有配置会请求本地域名服务器的，本地域名服务器是路由器分配的，路由器分配的是上层路由器分配的，在往上就是移动电信联通运营商具体的距离我们最近的DNS服务器解析的。

修改为使用下面的DNS服务器地址，就无法使用浏览器上网了。（之前上过网的，修改了还可以上网，是因为有缓存）

ip地址上网更快，因为不用解析。

http协议默认使用80端口。

```shell
//linux下的域名：
//文件名：/etc/hosts
127.0.0.1	localhost
127.0.1.1	jwc-virtual-machine

# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
```

```shell
vim /etc/services 		#查看哪些端口被那些协议占了
```

#### 2.2.2.3协议版本

协议版本：0.9、1.0、1.1、2

0.9：最早期的版本，只支持GET方法，并且协议还没有当前的规范，只支持超文本数据传输。

1.0：规范了http协议格式，并且新增支持GET、HEAD、POST请求方法，支持各种多媒体资源传输，简单的缓存控制。

1.1：更多的是对1.0版本进行性能的优化，支持了更多请求方法以及特性。（支持长连接，更加完善的缓存控制，分快传输......）



长连接与短连接：

![image-20231002191242666](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20231002191242666.png)

如何控制长短连接：

通过http的头部字段中的Connection字段，用于控制长连接的打开关闭状态：keep-alive/close。（keep-alive表示长连接，close表示短连接）



2.0：因为http协议的庞大冗余，因此2.0不是新增特性，而是重新定义http协议。

1.使用二进制数据传输；

2.支持主动推送资源；

3.服务器进行长连接响应，不需要按序进行...



表达总结:

0.9只支持GET方法；

1.0规范了协议格式，支持了更多请求方法，支持了多媒体资源传输，但是1.0对性能没有更多改进，因此有了1.1对性能的优化；

1.1针对传输性能进行大量改进，比如支持了长连接，更加完善的缓存控制...但是依然存在缺陷，比如管线化传输的队头阻塞问题；

2.0因为1.1过于冗余庞大，因此不适宜新增而是重新定义，2.0中采用二进制数据传输，支持服务器推送依赖资源，长时间响应不需按序进行，解决了队头阻塞问

题。



**首行-相应行：协议版本 响应状态码 状态码描述\r\n**

#### 2.2.2.4响应状态码

响应状态码：直观向客户端反馈处理结果。

1xx：一些描述信息；	101表示协议协议切换状态码

2xx：表示本次请求正确处理；	200

3xx：重定向，表示本次请求的资源移动到了新的链接处，但是原链接依然可用。	301是永久重定向（移动），302是临时重定向（移动）

4xx：表示客户端错误；	404

5xx：表示服务器错误；	502表示代理服务器没有收到正确响应；	504表示超时；



#### 2.2.2.5状态码描述

状态码描述：就是针对状态的文字描述。



总结：

首行：

请求行：请求方法 URL 协议版本\r\n

响应行：协议版本 响应状态码 状态码描述\r\n



### 头部

#### 2.2.2.6头部

头部：关于请求后者响应，或者正文的一些描述字段。

组成：key:val\r\nkey:val\r\n

典型头部字段：
Connection：长短连接控制；	keep-alive/close		keep-alive表示长连接，close表示短链接

Referer：记录本次请求的来源链接；

Content-Type：用于表示正文的数据格式。

Content-Length：用于表示正文的长度。		http解决粘包问题的关键字段

Location：用于指定重定向的新链接地址，与3xx搭配使用。

cookie与session：涉及的头部字段请求头Cookie，响应头Set-Cookie。

http协议是一个无状态协议。

1.一个客户端登录之后，服务端验证登录，成功后，通过Set-Cookie字段设置cookie信息（用户信息，状态...）返回给客户端；

2.客户端收到响应后，将Set-Cookie字段的cookie信息保存起来，下次请求服务器的时候从cookie文件中读取出cookie信息，通过Cookie字段发送给服务器；

cookie是一个维护http通信状态的技术，但是存在安全隐患。

解决方案：session。

session是服务端针对每个客户端所建立的会话，当客户端登录成功后，创建会话，在会话中记录客户端用户信息以及状态...，通过Set-Cookie字段将session_id返

回给客户端。

session_id每次请求都会发生变化，并且用户的隐私信息一直保存在服务器防止泄露。



面试题：cookie与session有什么区别？

答：cookie是http协议维护状态的技术，因为http是一个无状态的协议，通信的时候如果无状态在连续通信的时候就会比较麻烦，因此通过cookie来持续传递客户

端状态信息，让服务端来识别客户的身份，但是cookie存在安全隐患，因为在一直传递隐私信息，就涉及到新的技术，叫做session，服务端针对每一个客户端在

服务器上创建一个session信息，记录客户端的状态信息，记录之后通过cookie将我们的session_id返回给客户端，客户端拿到session_id之后进行保存，等到下一

次发送请求的时候将session_id携带进来发送给服务器，服务端就可以通过session_id找到对应的客户端信息识别用户身份。

cookie是维护http通信状态的技术，将关键信息保存在客户端，每次请求服务器时，读取出来发送给服务端（存在安全隐患）。

session是解决cookie安全隐患的技术，将关键信息保存在服务器，将session_id发送给客户端，作为cookie保存起来，往后请求传输session_id即可，解决了

cookie泄密的风险。



#### 空行

#### 2.2.2.7空行：\r\n

是与头部最后一个字段的结尾\r\n组成连续的\r\n\r\n作为特殊标志作为http头部结尾的标志。



#### 正文

#### 2.2.2.8正文

http是一个应用层协议，只是应用程序如何沟通的一种数据格式约定，在传输层是基于tcp实现的。

http客户端实际上就是一个tcp客户端；http服务器实际上就是一个tcp服务器，只不过http客户端与服务端的通信使用的是http协议来约定数据格式而已。

简单的http服务器的搭建：

1.搭建tcp服务端；

2.获取新建连接；

3.使用新建连接，等待接收数据；（http协议的请求数据）

4.接收数据：先接收http头部，解析头部-Contect-Length确定正文长度；

5.接收指定长度的正文；

6.根据请求方法以及资源路径确定客户端的请求目的；

7.进行具体对应的业务处理；

8.组织http协议格式的响应数据，对客户端进行回复；

9.如果是短连接，则直接关闭套接字，如果是长连接，则继续等待接收数据。

```c++
//文件名：http_server.cpp
#include "tcpsocket.hpp"
#include <pthread.h>
#include <sstream>

void *thr_entry(void* arg)
{
    bool ret;
    TcpSocket* cli_sock = (TcpSocket*)arg;
    while(1)
    {

        std::string buf;
        cli_sock->Recv(&buf);
        std::cout << "request:[" << buf << "]\n";

        std::string body;
        body = "<html><body><h1>Hello Bit</h1></body></html>";
        std::stringstream ss;
        ss << "HTTP/1.1 302 OK\r\n";
        ss << "Connection：close\r\n";
        ss << "Content-Length：" << body.size() << "\r\n";
        ss << "Content-Type：application/octet-stream\r\n";
        ss << "Location: http://www.baidu.com\r\n";
        ss << "\r\n";
        ss << body;
        cli_sock->Send(ss.str());
        cli_sock->Close();
    }
    //关闭套接字
    cli_sock->Close();
    delete cli_sock;
    return NULL;
}

//服务端
int main(int argc, char* argv[])
{
    //通过程序运行参数指定服务端要绑定的地址
    //  ./tcp_rev 192.168.0.203(IP地址) 9000(端口号)
    if(argc != 3)
    {
        //参数包含文件名本身，如果不是3，就是传参错误
        printf("usage：./tep_rev 192.168.0.203 9000\n");
        return -1;
    }

    std::string srvip = argv[1];
    uint16_t srvport = std::stoi(argv[2]);  //stoi是将字符串转换为整数类型
    TcpSocket lst_lock;     //监听套接字
    //1.创建套接字
    CHECK_RET(lst_lock.Socket());
    //2.绑定地址信息
    CHECK_RET(lst_lock.Bind(srvip, srvport));
    //3.开始监听
    CHECK_RET(lst_lock.Listen());
    while(1)
    {
        //4.获取新建连接
        TcpSocket* cli_sock = new TcpSocket();
        std::string cli_ip;
        uint16_t cli_port;
        bool ret = lst_lock.Accept(cli_sock, &cli_ip, &cli_port);
        if(ret == false)
        {
            continue;
        }

        
        //创建线程专门负责与指定客户端的通信
        pthread_t tid;
        pthread_create(&tid, NULL, thr_entry, (void*)cli_sock);
        pthread_detach(tid);    //分离线程，之后就不用关心了
    }
    //6.关闭套接字
    lst_lock.Close();
    return 0;
}
```

```c++
//文件名:tcpsocket.hpp
#include <cstdio>
#include <iostream>
#include <string>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <unistd.h>

#define LISTEN_BACKLOG 5
#define CHECK_RET(q) if((q) == false){return -1;}

struct data_t 
{
    int num1;
    int num2;
    char op;    //运算符operator的简写
};

class TcpSocket
{
    private:
        int _sockfd;        //操作句柄

    public:
        TcpSocket()
            :_sockfd(-1)
        {
            
        }

        int GetFd()
        {
            return _sockfd;
        }

        void SetFd(int fd)
        {
            _sockfd = fd;
        }

        //创建套接字
        bool Socket()
        {
            //tcp提供的是字节流传输服务，需要使用流式套接字SOCK_STREAM
            _sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if(_sockfd < 0)
            {
                //创建失败
                perror("socket error");
                return false;
            }
            return true;
        }

        //绑定地址信息
        bool Bind(const std::string &ip, const uint16_t port)
        {
            struct sockaddr_in addr;
            addr.sin_family = AF_INET;
            addr.sin_port = htons(port);
            addr.sin_addr.s_addr = inet_addr(ip.c_str());       //返回字符串的首地址，和下面取字符串的首元素的地址一样
            //addr.sin_addr.s_addr = inet_addr(&ip[0]);
            socklen_t len = sizeof(sockaddr_in);
            int ret = bind(_sockfd, (sockaddr*)&addr, len);
            if(ret < 0)
            {
                perror("bind error");
                return false;
            }
            return true;
        }

        //切换到监听状态
        bool Listen(int backlog = LISTEN_BACKLOG)
        {
            //listen(描述符, 同一时间连接数);
            int ret = listen(_sockfd, backlog);
            if(ret < 0)
            {
                perror("listen error");
                return false;
            }
            return true;
        }

        //连接服务器
        bool Connect(const std::string &ip, const int port)
        {
            struct sockaddr_in addr;
            addr.sin_family = AF_INET;
            addr.sin_port = htons(port);
            addr.sin_addr.s_addr = inet_addr(ip.c_str());       //返回字符串的首地址，和下面取字符串的首元素的地址一样
            //addr.sin_addr.s_addr = inet_addr(&ip[0]);
            socklen_t len = sizeof(sockaddr_in);
            //connect(描述符, 服务端地址, 地址长度);
            int ret = connect(_sockfd, (sockaddr*)&addr, len);
            if(ret < 0)
            {
                perror("connect error");
                return false;
            }
            return true;
        }

        //服务端获取新连接
        bool Accept(TcpSocket* sock, std::string *ip = NULL, uint16_t* port = NULL)
        {
            //原来的套接字是监听套接字，新创建的套接字是通信套接字
            //int accept(监听套接字, 回去客户端地址, 长度);
            sockaddr_in addr;
            socklen_t len = sizeof(sockaddr_in);
            int newfd = accept(_sockfd, (sockaddr*)&addr, &len);
            if(newfd < 0)
            {
                perror("accept error");
                return false;
            }

            sock->_sockfd = newfd;
            if(ip != NULL)
            {
                *ip = inet_ntoa(addr.sin_addr);
            }

            if(port != NULL)
            {
                *port = ntohs(addr.sin_port);
            }
            return true;
        }

        //接收数据
        bool Recv(std::string *buf)
        {
            //int recv(描述符, 空间, 数据长度, 标志位);     标志位给0是默认阻塞接收
            //返回值：实际获取大小  返回值是0不是没有接收数据，是连接断开了     -1是出错了
            char tmp[4096] = {0};       
            int ret = recv(_sockfd, tmp, 4096, 0);
            if(ret < 0)
            {
                //出错
                perror("recv error");
                return false;
            }
            else if(ret == 0)
            {
                //连接断开
                perror("peer shutdown");
                return false;
            }
            buf->assign(tmp, ret);      //拷贝字符串，参数是字符串首地址和字符串长度。
            return true;
        }

        //发送数据
        bool Send(const std::string &data)
        {
            //int send(描述符, 数据, 长度, 标志位);         标志位为0表示阻塞发送
            int total = 0;      //记录发送了多少数据
            
            while(total < data.size())
            {
                //发送数据一般不是一次性发送的，一般是多次发送，从上一次
                int ret = send(_sockfd, data.c_str() + total,  data.size() - total, 0);
                //int ret = send(_sockfd, &data[0] + total, data.size() - total, 0);      //和上面作用一样
                if(ret < 0)
                {
                    perror("send error");
                    return false;
                }
                total += ret;
            }
            return true;
        }

        bool Close()
        {
            if(_sockfd != -1)
            {
                close(_sockfd);
            }
            return true;
        }
};
```

```c++
//文件名：tcp_cli.cpp
#include "tcpsocket.hpp"

//客户端
int main(int argc, char* argv[])
{
    //客户端可以不绑定地址信息，但是必须知道服务端的地址信息
    if(argc != 3)
    {
        printf("usage：./tcp_cli srv_ip srv_port\n");
        return -1;
    }

    std::string srv_ip = argv[1];
    uint16_t srv_port = std::stoi(argv[2]);

    TcpSocket cli_sock;
    //1.创建套接字
    CHECK_RET(cli_sock.Socket());
    //2.绑定地址信息（不推荐绑定）
    //3.向服务端发起连接
    CHECK_RET(cli_sock.Connect(srv_ip, srv_port));
    while(1)
    {
        //4.收发数据
        struct data_t tmp;
        tmp.num1 = 11;
        tmp.num2 = 22;
        tmp.op = '+';
        
        /*
         *第一种发送和接收数据方法：字符串发送
        std::string buf;
        buf.resize(sizeof(struct data_t));      //预留字符串空间为结构体大小
        memcpy(&buf[0], &tmp, sizeof(struct data_t));   //内存拷贝，不用字符串拷贝是因为遇到0为停止
        //客户端向服务端发送数据，客户端出问题直接退出，服务端接收出问题不能直接退出，还要接收下一个客户端
        CHECK_RET(cli_sock.Send(buf));
    
        //sned(sockfd, (void*)&tmp, sizeof(struct data_t), 0);       标识符发送，举个例子(0是标志位，表示阻塞发送)
        
        //接收数据
        //清空缓冲区
        buf.clear();
        CHECK_RET(cli_sock.Recv(&buf));
        */

        //第二种发送和接收数据的方法：标识符发送
        int fd = cli_sock.GetFd();
        send(fd, (void*)&tmp, sizeof(struct data_t), 0);
        
        //接收数据
        int result;
        recv(fd, &result, sizeof(int), 0);

        //打印接收的数据
        std::cout << result << std::endl;
    }
    //5.关闭套接字
    CHECK_RET(cli_sock.Close());
    return 0;
}
```

注意；http服务器编写完毕之后，

云服务器：设置安全组策略，开启对应端口。

虚拟机：关闭防火墙。

云服务器在访问的时候访问的是公网地址，监听的是内网地址。

虚拟机监听的哪个地址就访问哪个地址。

```shell
#关闭防火墙
sudo systemctl stop firewalld
```



# 3.防火墙操作

防火墙操作：

1. 确认 firewalld 服务是否已安装：

   ```shell
   sudo systemctl list-unit-files | grep firewalld
   ```

   如果没有输出结果或输出结果中没有 firewalld.service，则表示 firewalld 服务没有安装。

2. 如果 firewalld 服务未安装，请使用适合您的 Linux 发行版的包管理器进行安装。例如，在基于 Red Hat/CentOS 的发行版上，执行以下命令：

   ```shell
   sudo yum install firewalld
   ```

3. 安装完成后，启动 firewalld 服务：

   ```shell
   sudo systemctl start firewalld
   ```

4. 现在尝试停止 firewalld 服务：

   ```shell
   sudo systemctl stop firewalld
   ```



# 4.HTTPS协议

HTTPS协议：并不是一个新的协议，而是在HTTP协议基础上进行了一层加密。

http协议就是基于ssl进行加密实现加密传输。

http加密流程、ssl加密流程：

目的：实现数据的安全传输。

安全传输：需要考虑两个问题。

1.身份验证问题：防止伪装。

2.数据加密问题：防止监听。

身份验证实现：

CA认证：通信双方在通信前先到权威机构请求给自己颁发一个CA证书。

CA证书：权威机构信息、自己的信息、...

通信双方建立连接后，在通信之前先将证书发送给对方，收到对方的证书后，查看这个权威机构是否是自己信任的权威机构，如果是，则到权威机构进行这个公司的身份验证。验证通过后进行通信，不通过可以自行选择是否添加信任。

身份验证通过，但是通信依然有可能被监听，存在风险，因此需要加密传输。

加密传输实现：

对称加密：加密和解密使用相同的秘钥。

优点：加密和解密效率高。

缺点：秘钥一旦被劫持则加密形同虚设。

非对称加密：加密和解密使用不同的秘钥。

思路：通信中，每一端在通信前都可以生成一对秘钥（公钥和私钥），在通信前，将公钥发送给对方，对方使用收到的公钥进行加密数据然后传输，自己收到数据后，使用私钥进行解密。

实现算法：RSA加密算法，课后调研。

优点：安全度更高。

缺点：加密和解密效率低下。

实际采用的是混合加密：通信双方，先使用非对称加密保护对秘钥协商过程。对称密钥协商完毕后，使用对称秘钥加密传输。



https加密流程：（将ca认证与混合加密合在一起使用）

1.服务器先生成一堆秘钥（公钥和私钥）到权威机构使用公钥请求颁发一个证书（权威机构、本身机构、公钥信息、过期时间...）

2.通信双方建立连接后，服务器将证书发送给客户端。

3.客户端对证书进行解析，根据信息进行身份验证。

4.身份验证通过后，使用公钥加密（一个随机数 + 自己支持的对称加密算法列表）发送给服务器。

5.服务器收到数据使用私钥进行解密，并且给客户端回复一个随机数 + 自己支持的对称加密算法列表。

6.双方通过自己的随机数与对方发送过来的随机数配合对称加密算法表进行计算得到一个对称秘钥。

7.往后通信使用对称秘钥进行通信。



https协议总结：

https协议：本质上http协议的加密。

加密流程：

身份验证：CA认证，验证通信双方的身份合法。

原理：使用第三方权威机构进行身份验证。（CA证书）

加密传输：加密通信数据防止网络监听。

对称加密：加密和解密使用相同秘钥。

优点：加密和解密效率高。

缺点：秘钥容易被劫持。

非对称加密：加密使用公钥，解密使用私钥。

优点：更加安全，不担心秘钥被劫持。

缺点：加密和解密效率低。

混合加密：使用非对称加密方式保护对称秘钥的协商，通信使用对称加密。

ssl加密：将身份验证与加密传输合在一起。

CA证书：权威机构信息，当前机构信息，公钥，...。

1.通信双方各自生成一对秘钥，使用公钥信息到权威机构生成一个CA证书；

2.通信连接建立后，数据传输前，将证书先传输给对方；

3.双方收到对方的证书后，进行解析，得到机构信息以及公钥信息；

4.对机构信息进行验证；

5.身份验证通过后，使用公钥加密数据（随机数 + 对称加密算法列表），发送给对方；

6.双方收到对方使用公钥加密的数据后，使用私密进行解密；

7.给双方也发送一个随机数 + 对称加密算法列表；

8.通过双方的随机数与算法列表生成一个对称密钥；

9.使用这个协商的对称密钥加密通信。



应用层：负责应用程序之间沟通。

应用层协议目的是了解指定协议的实现便于我们以后使用。

传输层：负责应用程序之间的数据传输。（TPC/UDP）

了解协议的实现，体会协议的特性，理解对于上层程序编程的影响。



# 5.传输层协议UDP协议

## 5.1协议实现

```shell
#查看udp协议
vim /usr/include/netinet/udp.h 
```

![image-20231005071529392](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20231005071529392.png)

16位源端-对端端口：用于描述识别通信两端进程。

16位数据报长度：能够存储最大数字65535，UDP报文总大小最大不能超过64K。

16位校验和：采用二进制反码求和算法，检验接收方接收到的数据与发送方的数据是否一致。



## 5.2协议特性

无连接：通信时不需要建立连接，只要知道对方地址就可以直接发送数据。

不可靠：不保证数据安全、有序到达对端。

面向数据报：无连接的、不可靠的、无序的、有最大长度限制的传输方式。

1.UDP传输时，sendto发送的数据会被放到发送缓冲区中，而UDP协议并不会等待，而是直接对数据封装头部，进行发送。

2.UDP传输时，收到的数据会被放到接收缓冲区中，而UDP保证数据是整条交付，不会出现半条或多条交付。



## 5.3编程影响

1.不保证安全到达：需要在应用层到时候使用tcp所使用的一些机制实现。（udp没有这些机制，udp效率高，tcp效率低）

2.不保证有序到达：需要在应用层进行包序管理。

3.UDP报文有最大长度限制：报文最大长度小于64K，因此发送大块数据的时候，需要在应用层进行数据分包进行发送。

4.UDP（数据报传输）实现的是整条交付：因此接收方必须定义的缓冲区足够大，能够一次性取出一条数据。



# 6.传输层协议TCP协议

## 6.1协议实现

```shell
#查看tcp协议
vim /usr/include/netinet/tcp.h
```

![image-20231005081243390](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20231005081243390.png)

16位源端-对端端口：描述识别两端。

32位序号-确认序号：进行包序管理。

4位头部长度：以4字节为单位，表示tcp头部最大有60字节，最小有20字节。

6位保留：

6位标志位：

URG：紧急指针有效位。

ACK：确认应答标志位。

PSH：接收方应该尽快将这个报文段交给应用层。

RST：重新连接。

SYN：建立连接请求标志位。

FIN：断开连接标志请求位。

16位窗口大小：实现滑动窗口控制/流量控制。

16位校验和：校验接收的数据与发送的数据是否一致。

16位紧急指针：了解一下带外数据即可。



## 6.2协议特性

面向连接：连接管理 + 状态管理

三次握手建立连接：（开始只能是客户端给服务端发送请求）

1.客户端向服务端发送连接建立请求SYN = 1；（客户端给服务端发送连接建立请求之后会进入一个状态，叫做SYN_SENT状态，指的是请求已经发送了，在等待服

务端的确认回复。）

2.服务端处于lsn_socket监听状态，开始处于closed，调用listen之后进入LISTEN状态，才去处理客户端连接请求，收到客户端的请求之后，服务端新建一个套接

字，进行确认回复，服务端给客户端发送一条数据（ack = 1, syn = 1），一个是确认回复，一个是建立连接请求，新建的套接字会进入一个状态，叫做

SYN_RCVD，表示收到了请求，并且进行了确认回复，接下来等待客户端对它的请求进行回复。

3.客户端给服务端发送ack = 1，进行确认回复，回复之后客户端会进入一个状态，叫做ESTABLISHED，这个状态表示的是连接已确认已就绪的状态，进入这个状

态之后才能进行数据传输，如果一个套接字不是这个状态，是不能进行数据传输的，就算服务端发送的数据也是直接丢掉。

4.服务端新建套接字收到最后一次确认回复之后服务端会进入一个状态，叫做ESTABLISHED，表示连接已经就绪。



客户端和数据段数据进行传输/通信。



四次挥手断开连接：（两端任意一端都可能是首先发送请求的一方）（这里假设是客户端首先发送请求的）

1.调用close/shutdown(WR)之后变为FIN_WAIT1状态，表示断开连接请求已经发送，等待服务端给我进行确认回复。

2.服务端这边的新建连接如果收到了这个请求，原来客户端不想给我发送数据了，客户端会针对这个请求进行确认回复，回复ack = 1，确认回复之后会进入一个

CLOSE_WAIT状态，表示对方已经不给我发送数据了，我也已经进行确认了，服务端还是可以发送数据的，除非服务端调用close/shutdown(WR)，这样表示服务

端没有数据发送了，服务端给客户端发送fin包。

3.客户端收到ack = 1，表示服务单已经收到客户端发送的fin包了，客户端会进入FIN_WAIT2z状态，表示的是请求已经发送，并且收到了回复，接下来该等待对方

给我发送fin包。

4.客户端收到fin包之后，进行确认回复，表示服务端的断开连接请求也收到了，会进入一个状态，叫做TIME_WAIT状态，表示等待状态，这个等待状态会在一段时

间之后，进入一个CLOSED状态，进入CLOSED状态的套接字就会被释放掉。

5.服务端发送fin包之后会进入一个LAST_ACK状态，表示等待对方给我进行最后一次回复，客户端发送ack = 1，客户端进行最后一次回复之后服务端进入CLOSED

状态。



shutdown和close不一样，close直接关闭读写释放资源，shutdown只关闭操作不释放资源。调用close的时候会发送分fin包，调用shutdown的时候不一定会发

送fin包，只有关闭写操作的时候才会分包，fin包只是表示对方不想给我发送数据了，而无法表示对方无法接收数据了。



解释fin包：

FIN(ISH)为TCP报头的码位字段，该位置为1的含义为发送方[字节流](https://baike.baidu.com/item/字节流?fromModule=lemma_inlink)结束，用于关闭连接。

当两端交换带有FIN标志的TCP[报文段](https://baike.baidu.com/item/报文段?fromModule=lemma_inlink)并且每一端都确认另一端发送的FIN包时，TCP连接将会关闭。FIN位字面上的意思是连接一方再也没有更多新的数据发送。然

而，那些重传的数据会被传送，直到接收端确认所有的信息。



三次握手和四次挥手

![image-20231008091318952](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20231008091318952.png)



面试题：

1.为什么握手是3次，挥手是4次？

答：握手两次不安全，四次没必要。

tcp是一个全双工通信，两端都必须确认对方是否具有数据收发的能力。

fin包只能表示对方不再发送数据了，不代表对方不再接收数据，因此有可能被动关闭方还会继续发送数据，因此这种情况下就不能直接发送fin包，而是等待上层用户不再发送数据了，调用close或者shutdown才会发送fin包，因此被动关闭方的ack和fin并不是一起发送的。



2.tcp3次握手失败了，两端是如何处理的？

答：服务端回复ack + syn后，如果超时得不到ack回复，则会发送rst重置连接报文，然后释放新建套接字。



3.TIME_WAIT有什么用？

答：**TIME_WAIT是主动关闭方在断开连接过程中进行最后一次ack回复后进入的状态。**

如果主动关闭方回复最后一次ack后直接释放资源，就有可能在新的客户端中使用原来的这个地址信息，而如果上次ack丢失的情况下会重传fin，则新客户端收到

重传的fin对新连接造成影响，以及发送syn也会受到影响。

如被动关闭方没有收到最后一次回复，则会重传fin。

假设没有time_wait，主动关闭放方最后一次回复后直接释放资源，这时候如果客户端新启动了一个套接字使用的刚好是之前的地址信息，这个套接字就有可能收

到重传的这个fin。



4.TIME_WAIT是为了保护客户端还是服务端？

答：TIME_WAIT更多的是为了保护客户端，启动不会使用刚关闭的套接字地址信息，而受到上个套接字的通信遗留问题影响。



5.TIME_WAIT等待多少时间释放资源？

答：**TIME_WAIT等待2个msl时间之后，释放资源，等待2个msl是为了保证能够对重传的fin进行处理，以及保证本次通信的所有数据都消失在网络中不会对新的连接造成影响。**（1个msl在系统中默认是60秒，msl是可以配置的）



6.一台主机上出现了大量的time_wait是什么原因？如何解决？

答：time_wait是套接字主动关闭连接，最终所进入状态，因此一台主机出现大量time_wait意味着大量的主动关闭了套接字。

1.减少time_wait等待时间。

2.使用套接字选项：地址复用。

int setsockopt(int fd, int level, int optname, void* optval, int optlen);

level：SOL_SOCKET

optname：SO_REUSEADDR	地址重用



```shell
#查询和修改系统的内核参数设置
sudo sysctl -a

#查询指定的参数，比如msl（最长报文寿命）
jwc@jwc-virtual-machine:~/桌面/8.网络基础2$ sudo sysctl net.ipv4.tcp_fin_timeout
net.ipv4.tcp_fin_timeout = 60
```

"MSL"在网络通信中代表的是Maximum Segment Lifetime，也称为最长报文寿命。它是指在TCP协议中，一个数据包（也称为段）在网络中存在的最长时间，超过该时间后，如果还没有被确认或传输完成，将被丢弃。

TCP协议通过MSL来限制在网络中的数据包生命周期，以避免数据包永远滞留在网络中造成资源浪费。当一个TCP连接关闭时，会进入TIME_WAIT状态，保留一段时间（通常是2倍的MSL），以确保在此期间内的延迟数据包能够到达，同时防止早期关闭的连接的数据包与新建立的连接混淆。

默认情况下，MSL的值是30秒，但可以根据操作系统的配置进行调整。需要注意的是，修改MSL值可能会对网络性能和连接可靠性产生影响，因此在进行更改时需要谨慎权衡。



7.一台主机上出现了大量的CLOSE_WAIT是什么原因？如何解决？

答：close_wait是被动关闭方，在收到fin包进行ack回复之后所进入的状态，这个状态是等待上层用户层调用close/shutdown(wr)后发送fin包的一个状态。

如果主机上出现了大量的close_wait的链连接，那么意味着可能在代码中我们没有关闭套接字。



tcp连接保活机制：

产生原因：tcp通信的时候，tcp是面向连接的，出现一种情况，两个连接建立起来之后，进行了一两次的通信之后，可能过了很长时间，两端都没有再进

行通信过了，突然有数据要进行发送了，这时候对方可能在中间连接已经关闭/断开了，发送数据是毫无意义的，没有更早的发现这个连接已经断开，并且没有对

这个连接做出对应的处理，意味着在两端socket还占据着资源，这样就有了tcp的连接保活机制。

概念：通信两端在长时间没有数据通信的情况下，服务端会每隔一段时间向客户端发送一个保活探测数据包（要求对方进行回复），若连续多次没有收到回复，则

认为连接已经断开。

```shell
#每隔一段时间配置
sudo sysctl -a | grep keepalive
```

![image-20231009235101482](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20231009235101482.png)

通信两端如果连续7200秒没有数据通信，则每隔75秒向对方发送一个保活探测数据包，连续9次没有得到回复则认为连接断开，这是默认的场景，这三个信息是可

以通过套接字选项进行配置/设置的。

```shell
#配置函数
int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen);
```

```shell
#配置文件
vim /usr/include/linux/tcp.h
```

![image-20231010000153011](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20231010000153011.png)

连接断开对于程序的影响：recv返回0，send会触发SIGPIPE异常退出，这个异常默认是退出的，一般会设置为重新连接不会退出，比如qq，一般都会重置或者自

定义这个异常的处理方式，send返回-1的时候要判断什么样的错误原因来进行对应的处理方式，没有自定义这个异常触发这个异常是直接退出的。



可靠传输：

概念保证数据有序，安全到达对端。：

1.面向连接是可靠传输的基础；

但是连接建立成功之后，再发送数据，可能对端已近退了，有可能数据中间已经丢了，无法保证在传输过程中数据的丢失与否的情况，需要有一些其他的机制来

保证数据的可靠传输。

2.协议字段中的序号与确认序号，进行包序管理，实现有序传输。

3.确认应答机制：接收方针对收到的每一条数据进行确认回复。

4.超时重传机制：发送数据等待超时无回复后，认为数据丢失进行重传。

5.协议字段的校验和字段：校验数据一致性，不一致则丢弃，发送重传请求。

重要的是2、3、4步骤。

6.避免丢包：有两种情况：

​	6.1：发送方发送数据过快、过多，导致接收方接收缓冲区满溢导致丢包。

解决方案：滑动窗口机制进行流量控制。

1.主要依赖协议字段中的窗口大小字段实现。

实现原理：

tcp在三次握手阶段，也就是通信前会协商一个最大的数据包有多大（mss是，假设大小是1024字节）最大数据段大小。

接收方的缓冲区中4096字节的数据，把4096字节的数据封装成4个数据包进行发送，这就是最大数据段大小的限制。



每一个接收方发和送方都会有一个接收窗口，发送窗口。

发送窗口：

​		后沿：发送起始序号。

​		前沿：结束发送位置。（前沿减去后沿不能大于对方的窗口大小）

接收窗口：

​		后沿：起始接受序号。

​		前沿：结束接受序号。（前沿减去后沿不能大于缓冲区剩余空间大小）



滑动窗口有3个衍生协议：

停等协议：收到确认回复后才会发送下一条。（适用于网络状况极度不好的情况）

回退n步协议：从丢失的数据开始进行重新传输。（适用于网络状况一般的情况下）

选择重传协议：哪条丢了就重传哪条。（适用于网络状况比较好的情况）



补充知识：认识mss

"MSS"在TCP协议中代表Maximum Segment Size，也称为最大数据段大小。它指的是每个TCP数据包所能携带的最大有效负载（不包括TCP头部和IP头部），也就是TCP协议中所定义的最大数据长度。

在TCP协议中，每当发送方创建并发送一个数据包时，它都需要设置该数据包的MSS值，并将其与接收方的MSS值进行比较，以便将数据包分割成适当大小的片段。如果MSS的值太小，将导致每个数据包所承载的有效负载减少，因此发送数据所需的时间也会增加。如果MSS的值太大，则可能会导致数据包在路由器上发生分片，从而导致额外的网络延迟和资源消耗。

默认情况下，MSS的值通常为1460字节，但它可以根据网络的吞吐量、延迟等特性进行调整。



​	6.2：传输过程中，网络状态突然不好，导致大量丢包重传。

解决方案：拥塞机制。（对于发送方自己的控制，不是两方协商的）

拥塞机制是以慢启动快增长的形式进行传输。

这种慢启动块增长是为了检测丢包的，最高值为接收方的剩余缓冲区大小，丢包了就以最小传输速率进行传输，传输一般是波形的。

实现原理：发送方维护一个拥塞窗口，用于限制当前所能发送的数据大小，而这个拥塞窗口以指数层级增长，实现网络探测，防止传输过程中网络状态突然变差继

续大量发送导致的大量丢包。



mss限制的是一个数据tcp发送的数据包最大大小，拥塞窗口限制的是发送方一次发送的多少数据，滑动窗口和拥塞窗口是组合起来使用的。



7.性能的提升：避免无谓的一些性能损失。

7.1确认序号：是告诉发送方确认序号之前的所有数据都已经接收成功，避免因为中间的某个确认回复丢失而导致的重传。

7.2快速重传机制：接收方在接受数据时，先接受到了后发的数据，则认为前边的数据有可能丢失，则连续间隔发送三条前边数据的重传请求。（确认序号为丢失

的数据起始序号）

发送方收到连续三条重传请求，则对对应确认序号的数据进行重传。

主要目的是为了减少超时等待时间。

三条重传请求，是为了防止延迟到达的情况。

7.3延迟应答机制：接收方接收到数据后，延迟确认回复。

接收方接收数据后如果立即进行回复，大概率窗口大小都会变小，延迟应答是为了，在延迟时间，上层有可能将数据取出，尽量保证窗口大小，保证传输吞吐量。

7.4捎带应答机制：将确认回复的信息，放到即将要发送的数据报报头中，捎带一块传输给对方。

尽可能减少纯报头的确认回复。（一个报头至少20字节）



备注：确认序号 = 起始序号 + 长度。



面试题：

tcp如何实现可靠传输？

1.可靠传输：面向连接、包序管理、确认应答、超时重传、校验和。

2.避免丢包：滑动窗口、拥塞机制。

3.提高性能：延迟应答、捎带应答、延迟发送。

udp如何实现可靠传输：在应用层通过tcp实现可靠传输的机制来实现，udp有自己的校验和机制。



面向字节流：

基于连接，可靠的，有序的，双向的一种字节流（以字节为单位）传输方式。

tcp要发送的数据都会被放到发送缓冲区中，通信时tcp会从缓冲区中取出合适大小的数据（不大于mss大小），封装头部进行发送。

不限制上层的发送以及接收数据大小，数据会在缓冲区堆积。

好处：传输比较灵活。

坏处：会产生粘包问题，将多条数据当做一条进行处理，无法分辨数据边界。

本质原因：tcp并不维护数据边界。

解决方案：则需要程序员在应用层进行数据边界管理。（分区数据边界）

具体技术：特殊字符、数据定长（以最长的数据的长度为标准，其余进行补位）、应用层头部加上数据长度字段（TLV）



"TLV"是一种数据编码格式，用于在计算机系统中传输和存储结构化数据。它指的是由Tag、Length和Value三个字段组成的数据元素。

Tag表示数据元素的类型，通常使用一个唯一的标识符来识别不同的数据类型，比如说0x01表示字符串类型，0x02表示整型等等。

Length表示数据元素的长度，通常使用一个固定字节数来表示该数据元素的大小。

Value表示实际的数据值，可以是一个字符串、整数、浮点数或其他数据类型。

使用TLV格式可以将数据元素按照特定的格式进行编码，并且保留了数据元素的类型信息和长度信息，使得接收方能够正确地解码和处理数据。TLV格式被广泛应用于各种应用和网络协议中，例如SNMP、LDAP、USB等。



udp粘包问题如何解决？

答：udp不会产生粘包问题，因为udp本身计算取出固定长度，udp是整条交付。（管道是字节流交付，也会存在粘包问题）



## 6.3编程影响



# 8.总结

传输层：负责通信两端的数据传输（端口）（UDP/TCP）。

## 8.1UDP协议

UDP协议：用户数据报协议--无连接，不可靠，面向数据报。

协议格式：

16位源端端口：描述通信两端。

16位对端端口：描述通信两端。

16位数据报长度：决定了udp传输数据报大小小于64k。

16位校验和：二进制反码求和算法，校验接收的数据与发送的数据是否一致。

协议特性：

无连接：只要知道对方地址就可以进行通信，不需要建立连接。

不可靠：不保证数据有序，安全到达对端。

面向数据报：数据传输有最大长度限制的传输方式。

编程影响：

udp传输报文有最大长度大小限制：若要传输较大数据则需要在应用层进行分包。

udp不保证数据有序可靠传输（安全可靠到达对端）：应用层若进行了分包操作则需要进行包序管理。

udp传输是数据整条交付：接收方recvfrom所给与的buf必须足够大。（接收端定义的接收缓冲区必须足够大）

## 8.2TCP协议

TCP协议：传输控制协议-面向连接，可靠传输，面向字节流。

协议格式：（需要背下的）

16位源端-对端端口：描述通信两端信息。

32位序号-确认序号：实现tcp包序管理。

4位首部长度：以4字节位单位，tcp报头最大60字节，最小20字节。

6位保留：

6位标志位：URG、ACK、PSH、RST、SYN、FIN

16位窗口大小：实现滑动窗口机制--流量控制。

16位校验和：校验接收的数据与发送的数据的一致性。

16位紧急指针：带外数据。

0到40字节选项数据：mss。



协议特性：

面向连接：连接管理与状态管理。（通信前先建立连接确保双方都具有数据收发的能力。）

三次握手建立连接：

服务端：1.开始监听；（开始监听后进入LISTEN状态才可以处理客户端请求 ）

客户端：1.发送SYN连接请求；（发送之后进入SYN_SENT状态，表示请求已经发送，现在等待回复）

服务端：2.收到SYN则进行SYN+ACK回复；（将SYN和ACK都置为1）（回复之后进入SYN_RCVD状态，表示收到了请求并且进行了回复，等待对方客户端最后一次

的回复）

客户端：2.收到SYN+ACK之后回复ACK；（回复之后进入ESTABLISHED状态，表示进入一个就绪状态）

服务端：3.收到客户端回复的ACK；（收到客户端的最后一次回复之后会进入ESTABLISHED状态，表示进入就绪状态，就绪状态才能进行数据的传输）



面试题：

1.握手为什么是三次：两次不安全，四次没必要。

2.三次握手失败，两端如何处理：

客户端重新请求；服务端发送rst直接重置连接。

网络攻击：SYN泛洪攻击。		解决办法：设置防火墙，将一些频率较高的ip拉进黑名单。



四次挥手断开连接：

主动关闭方：理论上可以是客户端也可以是服务端，但是实际上是客户端，因为服务端在实际开发中是不会关闭的。

被动关闭方：可以是客户端也可以是服务端。

主动关闭方：1.发送FIN包；（发送之后会进入FIN_WAIT1状态，表示FIN包已经发送，在等待对方ACK进行确认回复）

被动关闭方：1.收到FIN包，回复ACK；（回复之后会进入CLOSE_WAIT状态）

被动关闭方：2.发送FIN包；（发送之后会进入LAST_ACK状态）

主动关闭方：2.收到ACK；（发送之后会进入FIN_WAIT2状态，表示ACK回复已经收到了，现在等待对方给自己发送FIN包）（和上面的被动关闭方发送FIN包的顺

序是不确定的）

主动关闭方：3.收到FIN包，回复ACK；（回复之后会进入TIME_WAIT状态，在等待一段时间后也会进入CLOSED状态）

被动关闭方：3.收到ACK（收到最后一个ACK之后会会进入CLOSED状态）



面试题：

1.time_wait的作用？

答：主动关闭方在进行最后一次ack后进入的状态。

1.处理有可能因为最后一次ack丢失而导致对方重传的FIN包。

2.让本次通信所有数据都消失在网络中，避免对新连接造成影响。



2.一个主机上出现大量的time_wait的原因，解决方案？

答：

原因：主动关闭连接才会进入的状态，主机上大量主动关闭了连接。

解决方案：

1.减小time_wait等待时间；

2.使用套接字选项地址复用；（地址复用是绑定没有被释放的ip地址，地址复用更多的用在服务端，客户端几乎用不到，因为服务端必须使用相同的地址信息，客

户端要避免使用相同的地址信息）



3.一个主机上出现大量的close_wait连接原因？

答：

原因：被动关闭方收到FIN包进行回复后进入的状态，等待上层对套接字进一步的关闭处理。

解决方案：程序中有可能是连接断开后，忘记关闭套接字了。（第一步检查代码，使用netstat命令查看）



面向连接：

tcp保活机制；在通信两端长时间没有数据通信的情况下确定对方是否具有数据通信的能力。

默认7200秒没有数据通信则每隔75秒向对方发送一个保活探测包，要求对方进行回复，若连续9次没有回复，则认为连接断开。

连接断开对于程序中的体现：recv返回0，send出发异常。



典型面试题：

1.三次握手与四次挥手的过程？

2.握手为什么是三次，挥手为什么是四次？

3.TIME_WAIT状态有什么用？

4.握手失败两端的处理方式？

5.主机上出现大量的CLOSE_WAIT的原因？

6.主机上出现大量的TIME_WAIT的原因？



可靠传输：通过各种机制实现数据有序，安全到达对端。

安全有序传输：面向连接、序号-确认序号、确认应答机制、超时重传机制、校验和

避免丢包：

滑动窗口机制：避免发送方发送数据过多过快所导致的丢包。

实现：基于窗口大小字段实现。（不大于接收缓冲区剩余空间大小）

接收数据方在每次回复确认时都会计算窗口大小发送给数据发送方，数据发送方通过窗口大小调整数据的发送速度。

实际实现：发送窗口（后沿 + 前沿） + 接收窗口（后沿 + 前沿）。

特殊协议：停等协议、回退n步协议、选择重传协议。



拥塞窗口机制：避免因为网络状态突发变差导致大量丢包的情况。

实现：发送方维护一个拥塞窗口，用于限制当前所能发送的最大数据大小，通过这个窗口大小实现慢启动，快增长的传输方式。

慢启动进行网络传输探测，快增长是指数级增长，快速提高每次传输大小。

一旦传输过程中出现丢包，就会重新开始拥塞窗口。



提高传输性能：

快速重传机制、延迟应答机制、捎带应答机制

确认序号：每一条数据的确认回复中都会有一个确认序号（接收到的数据的起始序号 + 数据长度），但是确认序号不能随便进行回复，因为每个确认序号都是为了

告诉发送方这个确认序号之前的所有数据都已经收到了。

避免出现因为确认回复丢失而导致的超时重传。



快速重传机制：接收方在接收数据的时候发现未接收到后边数据，则认为前边的数据有可能丢失了，这时候接收方会向发送方间隔连续发送三条重传请求。

发送方收到连续三条重传请求，则对指定数据进行重传。

快速重传机制主要是为了减少超时等待时间。



延迟应答机制：保证传输吞吐量。

延迟进行确认回复，有可能上次从缓冲区中将数据取出，则这时候尽可能保证窗口大小不会减小。



捎带应答机制：尽量减少纯tcp报头的确认回复。

如果进行确认回复的时候，刚好有即将要发送给对方的数据。

则将确认回复与数据合到一起进行发送。



典型面试题：

1.tcp与udp的区别？

2.tcp是如何实现可靠传输的？

3.udp如何实现可靠传输的？



面向字节流：可靠、有序、双向、基于连接的、传输没有大小限制，以字节为单位的传输方式，传输比较灵活。

优点（以面向数据报作为对比对象）：传输更加灵活。

缺陷：存在tcp粘包问题，多条数据黏在一起当做一条处理，多条数据被当做一条数据进行处理。

本质：tcp传输对于多条数据在传输层并不会对数据进行数据边界的管理。

解决方案：在上层进行边界管理，三种方法：

1.特殊字符；	2.数据定长；	3.在应用头部中定义数据长度字段。

典型面试题：

1.tcp粘包是怎么一回事？		三连问：tcp粘包是什么，是如何产生的，是如何解决的？

2.udp粘包怎么解决？		答：udp不存在粘包问题。
