# 1.本节目标

1.初始Linux操作系统。

2.初识shell命令 ,了解若干背景知识。

3.使用常用Linux命令。

4.了解Linux权限概念与思想,能深度理解“权限”。

5.初步了解Linux 目录结构含义。



# 2.Linux总体学习

Linux的学习：

1.初始阶段：Linux系统的基本操作（命令操作），以及编程工具的使用。（基础指令 + 常用工具）

2.系统编程：系统功能上的编程接口的使用（系统所提供的接口）。（进程概念 + 进程控制 + 基础IO + 进程间通信 + 进程信号 + 多线程）

3.网络编程：网络通信程序的编写。（网络基础1 + 套接字编程 + 网络基础2 + 网络基础3 + 高级IO）



# 3.环境准备以及注意事项

Linux是一个操作系统（日常所见的操作系统是Windows）。

初始阶段：

搭建环境：

1.1购买云服务器；

1.2在自己主机上安转一个虚拟机：在自己的Windows中虚拟一套硬件环境，安转Linux操作系统，可以认为是一个独立的主机，在主机上使用软件远程操作。



云服务器上的ip地址是不变的，虚拟机的ip地址一般不变，变了就登录虚拟机使用ifconfig命令查看ip地址，再打开Xshell进行连接，特殊情况自己也可以改变ip地

址。

虚拟机软件：VMware Workstation Pro。（后面所有的编程环境都是在Ubuntu64位上）

功能：在当前的系统中，虚拟机构建了一套假的硬件环境，来安装虚拟机（目标主机）（其他的操作系统）

终端软件：Xshell7。





## 3.1ip基础命令

在 Linux 系统中，你可以使用以下命令来查看 IP 地址：

1. ifconfig 命令：

   ```shell
   Copy Codeifconfig
   ```

   这个命令可以显示网络接口的详细信息，包括 IP 地址、子网掩码、广播地址等。找到你关注的网络接口，通常是 eth0 或 wlan0，查看其 inet 或 inet 地址字

   段即可得到 IP 地址。

2. ip 命令：

   ```
   Copy Codeip addr show
   ```

   这个命令也可以显示网络接口的详细信息，包括 IP 地址、子网掩码等。查找你关注的网络接口，通常是 eth0 或 wlan0，查看其 inet 或 inet 地址字段即可得

   到 IP 地址。

3. hostname 命令：

   ```
   Copy Codehostname -I
   ```

   这个命令可以快速地获取当前主机的 IP 地址。

4. nmcli 命令（Network Manager 工具）：

   ```
   Copy Codenmcli device show
   ```

   这个命令会列出所有网络设备的详细信息，包括 IP 地址。找到你关注的网络接口，查看其 IP4.ADDRESS 字段即可得到 IP 地址。

请注意，在一些较新的 Linux 发行版中，ifconfig 命令已经被弃用，推荐使用 ip 命令来代替。而 nmcli 命令则需要 Network Manager 服务的支持。



详解一些命令：

可以使用命令 `ip addr show` 或者 `ifconfig` 获取更详细的网络接口信息，并寻找非回环地址的 IPv4 地址.

![image-20230805032532555](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805032532555.png)

根据提供的信息，ens33 是你的以太网接口，而 lo 是本地回环接口。

如果你要使用 Xshell 进行远程连接，你需要找到属于外部网络的 IP 地址。

在这种情况下，ens33 接口是你可以使用的外部网络接口，并且它具有一个 IP 地址。请注意，出于安全原因，我建议不要在公共论坛上公开分享自己的 IP 地址。

你可以使用以下命令来找到 ens33 接口的 IPv4 地址：

```
Copy Codeifconfig ens33 | grep "inet " | awk '{print $2}'
```

上述命令将从 ens33 接口的输出中提取 IPv4 地址并显示出来。

![image-20230805032635814](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805032635814.png)

## 3.2配置ip地址

如果你在 Linux 系统上无法找到 IP 地址，可能是因为网络配置存在问题或者网络接口未正确配置。你可以尝试以下步骤来查找和配置 IP 地址：

1. 使用 `ifconfig` 命令检查网络接口配置：

   ```
   Copy Codeifconfig
   ```

   这将显示当前系统中所有可用的网络接口和它们的配置信息。你需要找到你想配置 IP 地址的网络接口，通常以 `eth0` 或 `ens33` 的形式命名。

2. 配置 IP 地址：

   ```
   Copy Codesudo ifconfig <interface_name> <ip_address> netmask <netmask>
   ```

   将 `<interface_name>` 替换为你要配置 IP 地址的网络接口名称，`<ip_address>` 替换为你想设置的 IP 地址，`<netmask>` 替换为子网掩码。

   例如，如果你要为 `ens33` 接口配置 IP 地址为 `192.168.0.10`，子网掩码为 `255.255.255.0`，则命令如下：

   ```
   Copy Codesudo ifconfig ens33 192.168.0.10 netmask 255.255.255.0
   ```

3. 验证 IP 地址是否已成功配置：

   ```
   Copy Codeifconfig <interface_name>
   ```

   进行此操作后，应该可以看到已配置的 IP 地址信息。

   

操作示例：以下是一个在 Linux 系统上配置 IP 地址的具体示例：

1. 首先，使用以下命令查看可用的网络接口以及它们的配置信息：

   ```
   Copy Codeifconfig
   ```

   找到你要配置 IP 地址的网络接口名称。在这个示例中，我们假设使用的是 `ens33` 接口。

2. 使用以下命令为 `ens33` 接口配置 IP 地址：

   ```
   Copy Codesudo ifconfig ens33 192.168.0.10 netmask 255.255.255.0
   ```

   这将把 IP 地址设置为 `192.168.0.10`，子网掩码设置为 `255.255.255.0`。确保使用适合你网络环境的有效 IP 地址和子网掩码。

3. 验证 IP 地址是否已成功配置。再次运行以下命令：

   ```
   Copy Codeifconfig ens33
   ```

   现在你应该能够看到 `ens33` 接口的 IP 地址已经被设置为你指定的值。

请确保在命令中输入正确的网络接口名称，并在配置 IP 地址时使用有效的 IP 地址和子网掩码。如果你希望将这些配置持久保存，你还需要根据你所使用的 Linux 

发行版进行相应的配置文件修改，以便在系统重新启动后保留配置。

## 3.3虚拟机（目标主机）联网问题

1.

![image-20230805033529568](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805033529568.png)

2. VMware Workstation Pro工具上安装虚拟机

    linux虚拟机如何联网：要使 Linux 虚拟机联网，你可以按照以下步骤进行设置：

   1. 检查虚拟机网络设置：在虚拟机管理器中，确保虚拟机的网络适配器已正确配置。通常，使用 "桥接模式" 或 "NAT 模式" 可以实现虚拟机联网。

   2. 检查网络连接状态：确保宿主机（物理机）连接到互联网，并且网络连接正常工作。

   3. 启用网络适配器：在虚拟机中，确保网络适配器已启用。对于大多数 Linux 发行版，可以通过 `ifconfig` 或 `ip` 命令来检查网络适配器的状态。

   4. 配置网络连接：进入虚拟机的操作系统，在网络配置文件中设置正确的 IP 地址、子网掩码和网关等参数。具体操作可能因发行版而异，例如在 

      Ubuntu/Debian 中，可以编辑 `/etc/network/interfaces` 文件；在 CentOS/RHEL 中，可以编辑 `/etc/sysconfig/network-scripts/ifcfg-`

      `<interface>` 文件。你也可以使用网络管理工具，如 `nmtui` 或 `nmcli`（NetworkManager 命令行工具），通过命令行界面设置网络连接。

   5. 重启网络服务：在一些 Linux 发行版上，修改网络配置后，需要重启网络服务才能使更改生效。使用 `systemctl restart network`（CentOS/RHEL）

      或 `service networking restart`（Ubuntu/Debian）重启网络服务。

   6. 测试连通性：在虚拟机中，尝试使用 `ping` 命令测试网络连通性。例如，可以尝试从虚拟机中的终端执行 `ping 8.8.8.8` 来 Ping Google 的 DNS 服务

      器。如果能够收到回复，则表示虚拟机已经成功联网了。

   请注意，具体的步骤可能因使用的虚拟化平台（如 VMware、VirtualBox）和 Linux 发行版而有所不同。上述步骤提供了一般性的指导，你需要根据你的实际

   情况进行相应的配置和调整。

```shell
ping 8.8.8.8			#命令执行之后ping不通，表示虚拟机没联网
```

当你遇到虚拟机无法联网的问题时，可以按照以下步骤来解决：

1. 检查虚拟机网络适配器设置：
   - 在虚拟机管理器中选择你的虚拟机。
   - 找到虚拟机设置或网络设置选项，确保选择了正确的网络适配器类型（桥接模式或NAT模式）。
   - 如果是桥接模式，请确保选择了正确的物理网卡。
   - 保存设置并启动虚拟机。
2. 检查物理机网络连接：
   - 确保宿主机（物理机）已连接到互联网，并且网络连接正常工作。
   - 打开浏览器，在宿主机上访问一些网站，确认网络连接正常。
3. 启用虚拟机网络适配器：
   - 在虚拟机中，打开终端或命令行界面。
   - 输入 `ifconfig` 或 `ip addr` 命令，确认网络适配器已启用。如果没有显示网络接口，说明网络适配器可能未正确配置或不存在。
   - 如果没有启用网络适配器，可以使用以下命令启用它：`sudo ifconfig <interface> up` 或 `sudo ip link set <interface> up`，其中 `<interface>` 是网络接口的名称。
4. 配置虚拟机网络连接：
   - 进入虚拟机的操作系统。
   - 打开终端或命令行界面，编辑网络配置文件。具体文件和路径可能因发行版而异。
   - 例如，在 Ubuntu/Debian 中，可以使用以下命令编辑配置文件：`sudo nano /etc/network/interfaces`。
   - 在文件中，设置正确的 IP 地址、子网掩码、网关等网络参数。保存并关闭文件。
5. 重启网络服务：
   - 使用以下命令重启网络服务：
     - 在 Ubuntu/Debian 上：`sudo systemctl restart networking` 或 `sudo service networking restart`
     - 在 CentOS/RHEL 上：`sudo systemctl restart network` 或 `sudo service network restart`
6. 测试连通性：
   - 在虚拟机中，执行 `ping` 命令测试网络连通性。
   - 例如，可以尝试从虚拟机的终端执行 `ping 8.8.8.8` 来 Ping Google 的 DNS 服务器。
   - 如果能够收到回复，则表示虚拟机已经成功联网。



如何在VMware中的linux虚拟机上连接网络：在 VMware 中的 Linux 虚拟机上连接网络的方法如下：

1. 打开 VMware 虚拟机软件，并运行你的 Linux 虚拟机。
2. 在虚拟机窗口的顶部菜单栏中，选择 "VM"（虚拟机）选项，然后选择 "Settings"（设置）。
3. 在虚拟机设置窗口中，选择 "Network Adapter"（网络适配器）选项卡。
4. 在网络适配器选项卡中，选择 "NAT" 或 "Bridged"（桥接）模式。
   - NAT 模式：虚拟机将使用主机操作系统的 IP 地址进行网络通信。这是最常见的选择，尤其适用于个人使用和宿主机网络无法直接访问虚拟机的情况。
   - 桥接模式：虚拟机可以获得一个独立的 IP 地址，并与主机所连接的物理网络相连。这使得虚拟机可以像实体计算机一样直接访问网络。
5. 保存设置并关闭虚拟机设置窗口。
6. 启动 Linux 虚拟机。

在 Linux 虚拟机中，网络连接应该已自动配置。你可以通过执行以下命令来验证网络连接：

```
Copy Codeifconfig
```

这将显示 Linux 虚拟机上的网络接口及其相应的 IP 地址信息。

如果你仍然无法连接到网络，请确保主机操作系统的网络连接正常，并检查虚拟机的网络适配器设置是否正确。

![image-20230805034426549](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805034426549.png)

重点：设置完上面的之后重启虚拟机。



## 3.4Xshell连接

Xshell 是一个 SSH 客户端程序，用于远程登录和管理服务器。在 Xshell 中连接的 IP 地址通常是目标服务器的 IP 地址，即你希望连接的远程服务器的 IP 地址。

要使用 Xshell 连接到远程服务器，需要提供以下信息：

1. IP 地址：远程服务器的 IP 地址，可以是 IPv4 或 IPv6 地址。
2. 端口号：远程服务器上 SSH 服务监听的端口，默认是 22。
3. 用户名和密码：登陆远程服务器的用户名和密码。

在 Xshell 的连接对话框中，你需要填写目标服务器的 IP 地址，以及其他连接所需的参数，然后点击连接按钮进行连接。

请注意，确保你有正确的权限和凭据来连接目标服务器，并在网络环境中能够访问到目标服务器的 IP 地址。如果你不知道要连接的服务器的 IP 地址，可以咨询服

务器管理员或网络管理员来获取正确的信息。

建立会话：

![image-20230805034653325](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805034653325.png)

建立会话界面的主机是：ifconfig命令执行结果中的ens33中的192.168.0.202。（有的不是ens33）

![image-20230805035729050](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805035729050.png)

![image-20230805034710121](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805034710121.png)

连接完成之后遇到SSH协议不允许的问题，解决办法如下：（要是允许虚拟机SSH是允许的话Xshell会弹出用户名登录的弹窗，没有就是SSH是关闭的或者没有安装

的）

在虚拟机上执行下面的命令

1. 确保 SSH 服务已经启动：在目标主机上，检查 SSH 服务是否已经安装并正常运行。你可以尝试执行以下命令来检查 SSH 服务状态：

   ```
   Copy Codesystemctl status ssh    # 对于使用 Systemd 管理服务的系统（如大部分现代 Linux 发行版）
   service ssh status      # 对于使用 SysV Init 管理服务的系统
   ```

   如果 SSH 服务未运行，请启动它：

   ```
   Copy Codesystemctl start ssh     # 对于使用 Systemd 管理服务的系统
   service ssh start       # 对于使用 SysV Init 管理服务的系统
   ```

2. 确认你的用户账户具有通过 SSH 登录的权限：请确保你的用户账户有权使用 SSH 进行登录。通常情况下，可以通过修改目标主机上的 `/etc/ssh/sshd_config` 文件来配置 SSH 允许登录的用户。例如，你可以添加或取消注释以下行来允许某个用户登录：

   ```
   Copy CodeAllowUsers your_username
   ```

   保存文件后，重新加载 SSH 配置以使更改生效：

   ```
   Copy Codesystemctl restart ssh    # 对于使用 Systemd 管理服务的系统
   service ssh restart      # 对于使用 SysV Init 管理服务的系统
   ```

   确保你使用的用户名是正确的，并且已经按照要求配置了 SSH 登录的权限。

SSH设置完之后进入Xshell建立会话弹出用户名登录界面就成功了



在Ubuntu上安转Linux的SSH服务：

1. 打开终端，并使用以下命令更新软件包列表并安装 OpenSSH 服务器：

```
shellCopy Codesudo apt update  # 更新软件包列表
sudo apt install openssh-server  # 安装 OpenSSH 服务器
```

1. 安装完成后，SSH 服务应该会自动启动。您可以使用以下命令来检查 SSH 服务的状态：

```
shellCopy Codesystemctl status ssh  # 检查 SSH 服务状态
```

如果 SSH 服务已经启动，您应该会看到类似下面的输出：

```
Copy Code● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enabled)
   Active: active (running) since Mon 2023-07-31 10:00:00 CST; 1h ago
     Docs: man:sshd(8)
           man:sshd_config(5)
 Main PID: 12345 (sshd)
    Tasks: 1 (limit: 4915)
   Memory: 6.0M
   CGroup: /system.slice/ssh.service
           └─12345 /usr/sbin/sshd -D
```

1. 如果 SSH 服务没有启动，请使用以下命令手动启动它：

```
shellCopy Codesudo systemctl start ssh  # 启动 SSH 服务
```

这样就可以安装和启动 SSH 服务了。您可以再次运行 `systemctl status ssh` 命令来验证 SSH 服务是否正常工作。



SSH 服务已经成功启动并正在运行。以下是对状态输出的解释：

```
Copy Code● ssh.service - OpenBSD Secure Shell server
     Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enabled)
     Active: active (running) since Sat 2023-08-05 01:07:00 CST; 4min 57s ago
       Docs: man:sshd(8)
             man:sshd_config(5)
   Main PID: 4951 (sshd)
      Tasks: 1 (limit: 2273)
     Memory: 1.2M
     CGroup: /system.slice/ssh.service
             └─4951 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups

8月 05 01:07:00 jwc-virtual-machine systemd[1]: Starting OpenBSD Secure Shell server...
8月 05 01:07:00 jwc-virtual-machine sshd[4951]: Server listening on 0.0.0.0 port 22.
8月 05 01:07:00 jwc-virtual-machine sshd[4951]: Server listening on :: port 22.
8月 05 01:07:00 jwc-virtual-machine systemd[1]: Started OpenBSD Secure Shell server.
```

- `Loaded`：表示 SSH 服务的配置文件已经加载。
- `Active`：表示 SSH 服务当前处于活动状态，正在运行。
- `Main PID`：表示 SSH 服务主进程的进程ID。
- `Tasks`：表示 SSH 服务的任务数。
- `Memory`：表示 SSH 服务当前使用的内存大小。
- `CGroup`：表示 SSH 服务所属的控制组。
- `Server listening on 0.0.0.0 port 22.`：表示 SSH 服务正在监听本机的22端口，以便进行连接。

根据输出，可以确认 SSH 服务已经成功启动，并且正在监听本机的22端口，可以使用 SSH 客户端进行连接。



解释ifconfig命令的执行结果：

ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.0.202  netmask 255.255.255.0  broadcast 192.168.0.255
        inet6 fe80::fd78:8b23:c141:2e14  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:df:2f:ef  txqueuelen 1000  (以太网)
        RX packets 593775  bytes 844048919 (844.0 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 176995  bytes 13918637 (13.9 MB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (本地环回)
        RX packets 586  bytes 63442 (63.4 KB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 586  bytes 63442 (63.4 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

解释：

根据提供的网络接口信息，可以看出系统当前有两个网络接口，分别是 `ens33` 和 `lo`。

- `ens33` 是以太网接口，具有以下特征：
  - 状态为 UP，表示接口已经启用。
  - 支持广播、多播，表示可以进行数据广播和多播。
  - 状态为 RUNNING，表示接口正在运行。
  - 支持 IPv4 和 IPv6 协议。
  - 分配的 IPv4 地址为 192.168.0.202，子网掩码为 255.255.255.0，广播地址为 192.168.0.255。
  - 分配的 IPv6 地址为 fe80::fd78:8b23:c141:2e14。
  - MAC 地址为 00:0c:29:df:2f:ef。
  - 其他统计信息包括接收和发送的数据包数量、错误数量等。
- `lo` 是本地环回接口，具有以下特征：
  - 状态为 UP，表示接口已经启用。
  - 支持环回，表示可以用于内部通信和测试。
  - 状态为 RUNNING，表示接口正在运行。
  - 分配的 IPv4 地址为 127.0.0.1，子网掩码为 255.0.0.0。
  - 分配的 IPv6 地址为 ::1。
  - 其他统计信息包括接收和发送的数据包数量、错误数量等。

这些信息描述了系统当前的网络接口配置和统计信息。 

# 4.Linux发展史

操作系统：是一个软件，说白了就是一个程序，管理计算机上的软硬件资源。（按照程序逻辑控制计算机硬件，在合适的时候进行合适的操作）

linux是一个类unix操作系统。

linux占据了大多数的服务器市场，因为linux免费、稳定。

windows占据了客户端PC市场，linux比较反人类，只适合程序员使用，不适合大众使用。

linux占据了企业级服务器市场的80%的份额，windows（医院和政府）、unix（银行）、其他。（医院、政府、银行都是不差钱的）

# 5.Linux基本操作（命令）

我们操作linux是通过命令操作。

登录成功之后，命令操作的界面，被称之为终端。

linux中使用界面能够完成的操作，用命令能够完成。

基础指令：命令名称 [操作选项] [操作对象]

## 5.1ls

ls：列出当前目录下的内容（查看文件夹里边有什么文件）

目录：就是我们常说的文件夹。

当前目录：当我们打开一个终端，默认就会处于一个目录中，这个目录就是当前登录用户的家目录，操作自己的文件。

linux是一个多用户操作系统，统一时间可以有很多用户同时在系统上操作。（一个用户在别人的家目录中什么都做不了）

```shell
ls -l	#查看目录中文件的详细信息
```

![image-20230805180102285](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805180102285.png)

linux下的文件类型：文件类型并不以文件后缀名区分，后缀名只是便于用户识别的一个标识而已。

linux下一切皆文件，文件夹也只是一个目标类型的文件而已。

![image-20230805182304197](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805182304197.png)

total（总用量）是文件的总大小。（只会统计当前目录下的文件的大小，不会统计文件内部文件的大小）

文件类型	文件的操作访问权限	链接数	文件所有者	文件用户组	文件大小	文件的最后一次修改时间	文件名称

```shell
ls -a	#查看隐藏文件（linux下名称以.符号作为起始的文件都是隐藏文件）	专业的解释是显示所有文件，包括名称以.开头的文件
```

![image-20230805182524781](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805182524781.png)

![image-20230805184304559](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805184304559.png)

```shell
ls -l			#查看根目录
```

![image-20230805185818887](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805185818887.png)

## 5.2man

使用man手册查看命令的信息。

```shell
man ls			#查看ls命令的信息，包括命令介绍和使用方法，man手册按q退出
```

![image-20230805183314935](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805183314935.png)

命令的基本使用方式	操作选项的功能	文件的后缀名

## 5.3pwd

显示当前所在目录的路径。

linux下的目录结构：linux中的目录结构是唯一的，是一种树形结构。

![image-20230805190343392](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805190343392.png)

linux下目录结构唯一，从根目录开始向下扩展，是一个树形结构。

磁盘分区可以有多个，将分区挂载在指定的目录上，意思就是给一个指定的目录单独分配一块存储空间。

路径的表示方式：

1.绝对路径：以根目录作为起始的路径，表示方式是唯一的；

2.相对路径：以当前目录作为起始的路径,随着当前所在目录的不同而不同。

每一个目录中都会有两个子目录。

.（表示当前目录自身）

..（表示的是当前目录的父目录）

## 5.4tree

tree工具是要安转的。

```shell
sudo apt update				  # 更新系统的软件包列表（centos中是yum） 
sudo apt list --upgradable	  # 查看可以升级的安装包
sudo apt install tree  		  # 安装 `tree` 软件包，用于显示目录结构
```

![image-20230805190431359](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805190431359.png)

## 5.5mkdir

创建目录。

```shell
mkdir ./jia 			#在当前目录下创建一个jia目录
mkdir test				#在当前目录下创建test目录
mkdir -p jia/wen/chao	#递归的创建目录，每一层目录存在就不创建，不存在就创建新目录（没有-p只创建单目录）（如果创建的目录已经存在不报错）
```

![image-20230805203227592](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805203227592.png)

## 5.6rmdir

删除空目录。（只能删除空目录）

```shell
rmdir ./jia/wen/chao		#删除jia目录下的wen目录下的chao目录
rmdir ./jia/wen -p			#递归的删除jia目录下的wen目录和jia目录
```

![image-20230805203540295](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805203540295.png)

![image-20230805203903233](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805203903233.png)

## 5.7rm 

删除文件或目录。（默认删除的是文件，默认删除不了目录）

```shell
rm end.txt				#删除end.txt文件
rm -r -i ./dest1.txt 	#递归的删除./dest1.txt（-r：递归的	-i：增加一个保护提示的信息（进入或者删除）（按y是，n否））
#-r：递归的删除掉目录中所有文件之后，然后再删除目录自身
#-f：忽略提示信息，直接操作（删除的目录不存在也不会报错）（相当于强制删除，不要随便使用，容易删库跑路）
rm -rf ./				#强制删除当前目录下的所有文件
rm -rf /				#强制删除根目录下的所有文件
```

![image-20230805210634179](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805210634179.png)

## 5.8cp

拷贝一个文件到指定位置。

```shell
#cp 拷贝的文件(的路径) 拷贝到的位置

#拷贝文件
cp /etc/passwd ./			#将/etc/passwd文件拷贝到当前目录中

#拷贝目录
cp ./wen ./jia -r			#递归的将./wen目录中的所有内容拷贝到./jia目录中（加上-r才能拷贝目录）
cp ./passwd ./桌面/改变名字	#如果不存在改变名字这个目录，将./passwd文件拷贝到./桌面目录中，将./passwd文件的名字改成改变名字（相当于拷贝文件再改变文件名字）
```

![image-20230805214913087](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805214913087.png)

![image-20230805215331253](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805215331253.png)

## 5.9mv

剪切：把一个文件或目录从原来的位置移动到指定的位置。

```shell
#mv 要移动的文件或者目录 移动的目录位置
mv ./passwd ./wen		#将./passwd文件移动到./wen目录中（将文件移动到目录中）
mv ./wen ./桌面		   #将./wen目录移动到./桌面目录中（将目录移动到目录中）
```

![image-20230805234142059](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805234142059.png)

![image-20230805234459548](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230805234459548.png)

## 5.10cd

进入指定的目录，改变当前的工作路径。

![image-20230806000132199](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806000132199.png)

```shell
cd -   #切换到上一次所在额工作目录
```



## 5.11touch

后边跟一个文件名称，刷新文件的时间属性（官方解释），如果文件不存在则创建这个文件（实际用途）。

```shell
touch begin		#刷新begin文件的时间属性（官方解释），在当前目录下创建begin文件（实际使用）
stat begin		#查看begin文件的属性
```

![image-20230806004608969](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806004608969.png)

![image-20230806004655429](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806004655429.png)

 最后一次访问时间	最后一次更改时间	最后一次状态改变时间

![image-20230806004958805](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806004958805.png)

```shell
touch -d "1999-09-08 11:22:33" begin		#修改begin文件的最后一次访问时间和最后一次更改时间
#-m	修改最后一次更改时间
#-a	修改最后一次访问时间
```

![image-20230806010334429](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806010334429.png)

## 5.12cat

打印文件内容。（常用于查看短小的文件内容，）

![image-20230806033614397](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806033614397.png)

## 5.13more

分页显示文件内容，进入后使用空格向下翻页，回车是向下一行一行移动，按q退出。

![image-20230806034008978](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806034008978.png)

## 5.14less

分页显示文件内容，进入后按f/b上下翻页，j/k按行滚动。

匹配查找字符串：向下查找：/string				向上查找：?string

按q退出。

## 5.15head

显示文件的前n行内容，默认是10行。

```shell
head -n 3 begin.cpp		#显示begin.cpp文件的前3行
```

![image-20230806034644883](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806034644883.png)

## 5.16tail

显示文件的后n行内容，默认是10行。

```shell
tail -n 5 begin.cpp		#显示begin.cpp文件的后5行内容
```

![image-20230806035009435](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806035009435.png)

```shell
head -n 10 begin.cpp | tail -n 1			#显示文件的第10行内容（显示文件的前10行的最后一行）
```

![image-20230806035739273](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806035739273.png)

特殊符号：|

管道符：连接两个命令，将前边命令的处理结果（输出结果），交给后边命令继续进行处理。

## 5.17打包压缩指令

文件压缩理解的简单一些的话，就是按照指定的一张表，将相同的数据以特殊数据进行替换，让内容变少，解压缩就是替换回来。

文件压缩存在多种不同算法，压缩比率也不同。

1.zip和unzip（压缩和解压缩不会删除原有的文件，不常用）

```shell
zip test.zip begin begin.cpp  #把begin和begin.cpp压缩到test.zip压缩包中（不存在指定的压缩包创建，存在直接压缩进压缩包）（只压缩，不删除原有的文件）
unzip test.zip			      #把test.zip中压缩的文件解压缩，压缩包中的文件不删除，依旧存在（之后压缩包还可以解压缩）。
```

![image-20230806042150827](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806042150827.png)

2.gzip和gunzip（压缩和解压缩会删除原有的文件，不常用）

![image-20230806045403510](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806045403510.png)

3.bzip2和bunzip2（压缩和解压缩会删除原有文件，不常用）

![image-20230806050537739](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806050537739.png)

4.tar（集成了gzip和bzip2，压缩和解压缩不会删除原有的文件，常用）

对多个文件或文件夹进行打包/解包，并且可以进行压缩/解压缩。

打包（-c）	解包（-x）

打包或解包时按照gzip格式压缩/解压缩（-z）

打包或解包时按照bzip2格式压缩/解压缩（-j）	

显示详细打包解包信息（-v）

指定包名（-f）

```shell
tar -czvf file.tar.gz file1 file2 dir1...		#打包
tar -cvf file.tar.gz 							#解包（解包不需要指定解压方式，自己识别压缩方式进行解压缩）
```

![image-20230806052107542](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806052107542.png)

linux下目录结构与磁盘分区的关系，目录结构唯一，是一个树形结构，最底层是一个根目录，可以将磁盘分区挂载在目录上给目录分配空间。

linux下的文件类型：linux中一切皆文件，并不以后缀名区分文件类型，而是以使用性质区分（目录类型，普通类型）。

linux下的隐藏文件：文件命名以符号.作为起始的文件名称（文件是否隐藏通过文件名称决定）。

## 5.18匹配查找指令

1.grep：在指定的文件中匹配包含指定字符串的行。

-n：显示匹配到的包含指定字符串的行在文件中的行号

-v：匹配不包含指定字符串的行

-i：忽略大小写进行匹配

-R：在指定的目录中对所有文件逐个进行字符串的匹配

```shell
grep -n 'void' test.c				#在test.c文件中查找包含字符串void的行，打印行，并且显示行号
grep -n -v 'void' test.c			#在test.c文件中查找不包含字符串void的行，打印行，并且显示行号
grep -n -i 'VOID'  test				#忽略大小写进行匹配
grep -n -i -R  'VOID'  ./			#在当前目录下查找所有文件中的void或者VOID（操作对象是一个目录，并非一个文件）
```

![image-20230806204851887](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806204851887.png)

![image-20230806204938485](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806204938485.png)

![image-20230806210742292](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806210742292.png)

![image-20230806210848282](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806210848282.png)

2.find：在指定的目录中查找符合指定规则的文件。

-name：通过文件名称查找文件

-size：按文件大小查找文件（-size +/- [cbwkMG]）

-type：按文件类型查找文件（-type +/- [fdlpscb]）

-amin/mmin/cmin/atime/mtime/ctime：按时间查找文件（min是分钟，time是天）（a表示最后一次访问时间，m表示最后一次修改时间，c表示最后一次状态

改变时间）

-user：按文件所有者查找文件

linux中一切皆文件：描述的是在linux中所有的东西都是当做文件来进行操作的。

```shell
find ./ -name 'test.c'		#查找文件名称是test.c的文件（路径必须在表达式前面）
find ./ -name '*test*'		#模糊匹配，匹配文件中间名包含test字符的文件
find ./ -size -1k			#查找文件大小小于1k的文件（k只能是小写，大写是不对的）
find ./ type d				#按类型查找文件，查找目录类型的文件
find ./ type f				#按类型查找文件，查找普通类型的文件
find ./ mmin -3				#查找3分钟以内修改过的文件（这个命令常用于删除过期文件）
```

![image-20230806212522616](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806212522616.png)

![image-20230806212640622](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806212640622.png)

![image-20230806213139779](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806213139779.png)

![image-20230806213558268](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230806213558268.png)

在Linux中，文件的类型可以通过文件的属性来确定。在常见的Linux文件系统中，主要有以下几种类型的文件：

1. 普通文件（Regular File）：普通文件是存储数据的标准文件类型。它可以包含文本、二进制数据或其他格式的数据。大多数文件都属于这个类型。
2. 目录（Directory）：目录是用来组织和存储文件的文件类型。它包含了其他文件和目录的引用，可以形成文件系统的层次结构。
3. 符号链接（Symbolic Link）：符号链接也称为软链接（Soft Link），它是指向另一个文件或目录的快捷方式。创建符号链接时，可以使得用户能够通过符号链接的路径访问到目标文件。
4. 设备文件（Device File）：设备文件是与计算机硬件设备进行交互的一种特殊类型文件。在Linux中，设备文件分为两种类型：
   - 块设备文件（Block Device File）：用来与块设备（如硬盘）进行交互。
   - 字符设备文件（Character Device File）：用来与字符设备（如串口）进行交互。
5. 套接字文件（Socket File）：套接字文件用于进程间的通信，它提供了一种特殊的文件类型来实现不同计算机上的进程之间的网络通信。
6. 管道文件（Named Pipe）：管道文件用于进程间的通信，它提供了一种特殊的文件类型来实现同一计算机上不同进程之间的通信。

除了上述常见的文件类型，还有一些特殊的文件类型，比如FIFO（First In, First Out）和字符块文件等。这些文件类型可能不太常见，但在特定的情况下会使用到。

通过使用 `ls -l` 命令可以查看文件的详细属性，其中文件类型在第一个字符表示。例如，普通文件以 `-` 开头，目录以 `d` 开头，符号链接以 `l` 开头等。

当列出文件详细属性时，每个文件类型都有一个对应的简写字母表示。以下是常见的文件类型及其对应的简写字母：

1. 普通文件（Regular File）：`-`（减号）（f）
2. 目录（Directory）：`d`（小写的字母D）
3. 符号链接（Symbolic Link）：`l`（小写的字母L）
4. 设备文件（Device File）：
   - 块设备文件（Block Device File）：`b`（小写的字母B）
   - 字符设备文件（Character Device File）：`c`（小写的字母C）
5. 套接字文件（Socket File）：`s`（小写的字母S）
6. 管道文件（Named Pipe）：`p`（小写的字母P）

下面是一个示例，展示文件列表的属性及其对应的简写字母表示：

```shell
-rw-r--r-- 1 user group 4096 Aug 1 10:25 file.txt
drwxr-xr-x 2 user group 4096 Aug 1 11:12 dir
lrwxrwxrwx 1 user group 7 Aug 1 09:48 link -> file.txt
brw-rw---- 1 user disk 0, 0 Aug 1 08:55 block_dev
crw-rw-rw- 1 user tty 0, 0 Aug 1 08:59 char_dev
srwxrwxrwx 1 user group 0 Aug 1 07:30 socket
prw-r--r-- 1 user group 0 Aug 1 07:40 pipe
```

## 5.19特殊的指令和操作

特殊的指令：

查看手册：man

查看网卡信息：ifconfig

关机：shoutdown -h now

重启：reboot

特殊的操作：

中断当前操作：ctrl + c

文件名自动补全：输入文件名的一部分，然后使用tab键自动补全。

可以设置xshell的工具选项的一些快捷键来提高效率。

## 5.20设置root密码

大多数的 Linux 发行版中，root 用户的默认密码是没有设置的。一般情况下，你需要通过其他途径来设置 root 用户的密码。

当你第一次安装 Linux 操作系统时，会创建一个管理员账户（通常是具有 sudo 权限的普通用户），并且该用户可以执行自己账户的密码管理以及其他配置任务。

使用该管理员账户，你可以通过以下步骤为 root 用户设置密码：

1. 以管理员身份登录到系统。
2. 打开终端或命令行界面。
3. 输入 `sudo passwd root` 命令。
4. 系统会提示你输入新的 root 密码，并要求再次确认密码。
5. 输入新密码并确认。

完成以上步骤后，你已经成功设置了 root 用户的密码。

请注意，root 用户拥有最高权限，因此设置强壮和安全的密码是非常重要的。确保密码足够复杂，包含字母、数字和特殊字符，并且不容易被猜测。

## 5.21>和>>

```shell
ls >> test.txt			#将ls的内容写入到test.txt文件中（追加重定向，写入到文件的后面）
ls > test.txt			#清空重定向、覆盖重定向
objdump -S child.o		#查看.o文件的汇编指令
```

sof

服务相关的指令

文本文件所有单词统计出现的词频

查看进程、线程、cpu、存储的指令

查看文件第三行到第五行的指令

去重指令

调用函数的底层到底干了是什么（函数调用协议、汇编指令）

grep

python命令行指令写入文件

日志中过滤包含error字段

查看进程id、杀死进程、查找文件的指令

汇编指令、test

top方面的问题、如何看系统现在的负载

汇编中跳转指令

字节码的指令

echo

cpu指令

查找当前8080端口被哪个进程占用找出来

查看内存的指令

查看字符串

修改权限

删除目录

查找目录

替换关键字

如何定位死锁

shell指令、source

sql指令是否通过索引的方式查找

grub指令

查看内存、io指令

gdb指令

替换关键字

进入内核态的指令

top指令能查看进程的哪些信息

什么是指令流水

vue自定义指令

gcc四个过程和每一步的指令

函数压栈过程，call指令的下一个指令的地址是什么时候压栈的

一个指令运行了很久，现在ctrl+c，会发生什么

如何让线程sleep，mutex是如何实现的，futex是啥、fopen调用的过程、系统调用编号、syscall指令，文件数inode、什么是目录

机器指令是完全由0/1组成的，那么机器怎么对这些0和1进行划分

函数调用涉及到的汇编指令









# 6.linux中根目录下的子目录功能

在Linux中，根目录（Root Directory）是整个文件系统的顶级目录，用符号 `/` 表示。根目录下包含了许多子目录，每个子目录都有不同的功能和用途。

以下是几个常见的根目录下的子目录及其功能：

1. `/bin`：存放可执行的二进制文件（命令），如ls、cp和mkdir等。
2. `/boot`：包含启动操作系统所需的文件，如内核映像文件和引导加载程序。
3. `/dev`：用于存放设备文件，这些设备文件用来与系统中的硬件设备进行交互。
4. `/etc`：存放系统的配置文件，如网络配置文件、用户账户配置文件和服务配置文件等。
5. `/home`：用户的主目录所在的位置，每个用户在该目录下有一个以用户名命名的子目录。
6. `/lib`：存放系统使用的共享库文件，这些库文件由系统和应用程序共享使用。
7. `/mnt`：临时挂载点，可以将其他设备（如光盘、移动硬盘）挂载到该目录下以访问其内容。
8. `/opt`：存放可选的软件包安装目录，一般是第三方软件。
9. `/proc`：虚拟文件系统，提供了进程信息和系统状态的访问接口。
10. `/root`：超级用户（root）的主目录。
11. `/sbin`：与系统管理有关的命令，只有超级用户（root）可以执行。
12. `/tmp`：用于存放临时文件，该目录下的文件在系统重新启动时会被清除。
13. `/usr`：包含用户程序和数据文件的次要层次结构，比如应用程序、库文件、文档等。
14. `/var`：存放经常变化的文件，如日志文件、缓存文件、临时文件等。

这些子目录具有特定的功能并且有助于组织和管理文件系统中的数据和配置。请注意，不同的Linux发行版可能会有一些细微的差异，因此某些子目录的名称和用

途可能会有所不同。

# 7.安装常见工具

## 7.1vim

```shell
sudo apt update			#更新软件包列表
sudo apt install vim	#安装vim
```

基本使用：

Vim 是一个功能强大的文本编辑器，它有很多命令和用法。以下是一些常用的 Vim 基本命令和用法：

1. 启动和退出：
   - 启动 Vim：在终端中输入 `vim` 命令。
   - 退出 Vim：
     - 输入 `:q` 退出（如果没有修改过文件，直接退出）。
     - 输入 `:q!` 强制退出，不保存修改。
     - 输入 `:wq` 保存修改并退出。
     - 输入 `:x` 保存修改并退出（只有在有修改时才保存）。
2. 光标移动：
   - 使用方向键：使用上、下、左、右箭头键来移动光标。
   - 快捷键：
     - `h`：左移一个字符。
     - `j`：下移一行。
     - `k`：上移一行。
     - `l`：右移一个字符。
     - `0`（零）：移动到行首。
     - `$`：移动到行尾。
     - `G`：移动到文件末尾。
     - `gg`：移动到文件开头。
3. 插入和编辑：
   - 进入插入模式：
     - 在普通模式下按下 `i` 进入插入模式，光标会进入可编辑状态。
     - 按下 `a` 进入插入模式，在当前光标之后开始编辑。
   - 退出插入模式：
     - 按下 `Esc` 键退出插入模式，返回到普通模式。
4. 保存和修改：
   - 保存文件：
     - 在普通模式下，按下 `:w` 进行保存。
   - 撤销和重做：
     - 在普通模式下，按下 `u` 撤销上一步操作。
     - 在普通模式下，按下 `Ctrl + r` 重做被撤销的操作。
5. 删除和复制：
   - 删除和剪切：
     - 在普通模式下，将光标移动到要删除的字符上，按下 `x` 删除当前字符。
     - 在普通模式下，按下 `dd` 删除整行。
   - 复制和粘贴：
     - 在普通模式下，将光标移动到要复制的内容上，按下 `yy` 复制整行。
     - 在普通模式下，将光标移动到要粘贴的位置上，按下 `p` 将复制的内容粘贴到当前位置之后。

这只是 Vim 的一小部分基本命令和用法，如果你想深入学习和掌握 Vim，可以了解更多高级的编辑技巧和功能。你可以在终端中输入 `vimtutor` 命令来启动 Vim 

的教程，它将介绍更多关于 Vim 的使用方法和技巧。

## 7.2gcc（c语言）

```shell
sudo apt update			#更新软件包列表
sudo apt install gcc	#安装gcc
gcc --version			#验证gcc是否安装成功，并查看其版本信息
```

## 7.3g++（c++语言）

```shell
sudo apt update			#更新软件包列表
sudo apt install g++	#安装g++
gcc --version			#验证gcc是否安装成功，并查看其版本信息
```

## 7.4mysql

```shell
sudo apt update									#更新软件包列表
sudo apt install mysql-server mysql-client		#安装mysql服务器和客户端
sudo service mysql status						#检查mysql服务的状态（如果 MySQL 正在运行，你将看到类似 "active (running)" 的输出。）
```

## 7.5lrzsz

lrzsz在 Linux 系统下用于文件传输的一组工具和协议。

"lrzsz" 是一种用于在串口或网络连接中进行文件传输的工具集合，它通常用于通过终端或串口连接上传或下载文件。

- `rz`命令用于接收文件，即从终端或串口接收文件传输并保存到本地设备中。
- `sz`命令用于发送文件，即将本地文件传输并发送到终端或串口连接的远程设备中。

这些工具经常被用于与嵌入式设备（如路由器、交换机等）进行文件传输和维护操作。

# 8.shell的认识

shell的中文意思：壳。

当我们打开一个终端，就可以输入指令，完成对应的功能。

终端：实际上是一个界面显示。

为什么终端中输入命令就能完成功能呢？		答案：借助了shell

shell：实际上是一个命令行的解释程序，是一个用户与系统内核沟通的桥梁。

系统内核：完成系统核心功能，对软硬件资源进行控制管理的系统集合。（用户不能直接操作系统内核）

用户不能直接访问内核，是出于安全考虑。

只能通过操作系统提供的特定接口来完成对内核的访问。

系统提供的系统调用接口，能够完成内核中一个个单独的功能。

但是系统调用接口也不太好用。（不是人人都是大佬程序员）

这时候，大佬们针对系统调用接口封装实现了一个个独立功能的程序（比如浏览目录内容的功能程序），普通用户想要浏览目录只需要执行这个程序就可以了。

基于这个思路，大佬们实现了一个命令行解释程序shell：捕捉键盘的输入，执行对应的程序。（输入ls字符，就执行ls程序）

根目录下有一个/bin目录，内部存放的就是系统中的命令功能程序。

当我们在终端中输入命令名称之后，shell捕捉到我们的输入，就知道我们想要执行哪个程序，然后在/bin目录中找到对应的程序，执行，完成功能。

一个终端被打开，默认就会执行一个程序，就是shell程序。

专有名称：我们所输入的命令被称之为shell命令。

shell其实就是一个程序，捕捉我们输入的命令名称，执行对应功能程序。

shell是解释器（捕捉命令名称，执行这个程序），终端输入的命令是程序。

shell只是系统中的一个应用，帮助用户操作系统。（shell捕捉命令名称，给操作系统执行这个程序） 

操作系统是完成系统核心管理功能的。（操作系统 = 内核 + 应用，shell只是其中的一个应用）

windwos中，cmd是个终端，内部运行了shell程序，但是windows最大shell就是UI界面。

## 8.1如何修改linux中的shell

要修改 Linux 中的 shell，可以按照以下步骤进行操作：

1. 查看当前使用的 shell：首先，你需要确定当前正在使用的 shell。可以通过 `echo $SHELL` 命令来查看当前的默认 shell。
2. 查看可用的 shell：Linux 系统上有多种不同的 shell 可供选择。你可以使用 `cat /etc/shells` 命令来查看系统中可用的 shell 列表。
3. 切换到新的 shell：选择你希望切换到的新 shell，并使用该 shell 的命令来切换。例如，如果你想切换到 Bash shell，则可以使用 `bash` 命令。
4. 永久修改默认 shell（可选）：如果你希望将新 shell 设置为默认的登录 shell，可以修改用户的配置文件。对于大多数 Linux 发行版，用户配置文件是 `~/.bashrc` 或 `~/.bash_profile`。可以使用文本编辑器打开该文件，并将默认 shell 的路径添加到文件中。例如，如果你想将默认 shell 设置为 Bash，将下面的内容添加到 `~/.bashrc` 或 `~/.bash_profile` 文件中：

```shell
export SHELL=/bin/bash
exec /bin/bash
```

保存并关闭文件后，注销并重新登录用户，新的默认 shell 将生效。

请记住，在修改 shell 之前，确保你了解所选择 shell 的用法和特性。不同的 shell 有不同的语法和功能。

## 8.2安卓底层是linux

Android 操作系统的底层是基于 Linux 内核。

Android 是一个基于开源的移动操作系统，它使用了 Linux 内核作为其底层基础。Linux 是一个广泛使用的开源操作系统内核，它提供了许多核心功能和服务，如进程管理、内存管理、设备驱动程序等。Android 利用 Linux 内核的稳定性、可靠性和安全性，并在其上建立了一个针对移动设备的应用框架和用户界面。

Android 并非只是一个纯粹的 Linux 发行版，它还包含了许多自己的组件和服务，如应用程序框架、Java 虚拟机（Dalvik 或者现在的 ART）、应用程序层接口等。这些组件和服务使得 Android 在移动设备上具备了更好的适应性和用户体验。

因此，我们可以说 Android 是基于 Linux 内核的操作系统，但它同时也包含了其他独特的组件和服务。

# 9.权限

权限就是权利的限制。

linux是一个多用户操作系统，可以多个用户同时操作，人多了就乱了，因此需要对每个用户进行权利的限制，不能为所欲为。

用户对系统的操作权限。

linux将用户分为两类：管理员用户（root） +   普通用户（在使用linux的时候尽量避免直接使用root用户）

切换用户：拥有指定用户所持有的权限。

su：切换用户。

示例：su username

sudo：这不是一个单独的指令，与其他的指令搭配使用，表示对当前用户的这次操作临时进行提权。

## 9.1临时提权操作的设置

在 Linux 中，可以使用 `sudo` 命令为用户赋予临时的 root 权限。通过 `sudo` 命令，普通用户可以在一定时间范围内以 root 用户的身份执行特定的命令。

要让用户具有临时的 root 权限，请按照以下步骤进行操作：

1. 以 root 或具有 sudo 权限的用户登录到系统。
2. 打开终端或命令行界面。
3. 使用以下命令编辑 `/etc/sudoers` 文件，该文件包含了 sudo 配置:

```
bashCopy Codesudo visudo
```

1. 在文件中找到 `root ALL=(ALL:ALL) ALL` 这一行，下方添加以下内容（假设你想为用户 `username` 分配临时 root 权限）：

```
bashCopy Codeusername ALL=(ALL:ALL) ALL
```

1. 保存并退出编辑器。

现在，用户 `username` 可以使用 `sudo` 命令来执行特权命令，临时获得 root 权限。

例如，如果用户需要执行一个需要 root 权限的命令，可以在命令前加上 `sudo`：

```
sudo <command>
```

当用户输入自己的密码后，系统将允许该用户在一段时间内以 root 权限执行该命令。

请注意，为了安全起见，只应将必要的用户添加到 `/etc/sudoers` 文件，并且使用者应清楚自己执行的每个特权命令的含义和影响。

## 9.2文件的访问权限

什么样的用户能够对文件进行什么样的操作限制。

对于访问用户的分类：文件所有者（u）、文件所属组（g）、其他用户（o）。

对于访问操作的分类：可读（可浏览）（r）、可写（在目录中创建删除文件）（w）、可执行（可进入）（x）。

linux中文件权限的表示方式：rwx	rwx	rwx（不具备权限则以-表示）

![image-20230807063706876](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230807063706876.png)

分为3组，分别为所有者、所属组、其他用户。

rwx rwx r-x（所有者可读可写可执行）

rw- r-- r-- 	（所属组可读不可写不可执行）

rw- r-- r-- 	（其他用户可读不可写不可执行）	

上面的为字符表示法，除了字符表示法还有八进制数字表示法。

111 111 111 -> 777

rwx rwx rwx

有一个文件权限位是654，请问所属组成员能够对文件进行什么操作？ 	101（r-x）

有个文件所有者可读可写不可执行，所属组只读，其他用户只读，如何表示？		rw-r--r--（644）

## 9.3文件权限相关指令

1.设置文件的默认创建权限：

查看权限掩码：umask（权限掩码 = 777 - 权限）

![image-20230807065732325](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230807065732325.png)

0002（第一个位是特殊位，不用管，后三位是权限的取反值）

0：是八进制中的7减去7（可读可写可执行）就是0。

0：是八进制中的7减去7（可读可写可执行）就是0。

2：是八进制中的7减去5（可读不可写可执行）就是2。

在shell中文件的默认创建权限就是掩码取反，或者是777 - umask

注意点：普通文件创建出来默认不会带有可执行权限。

更改权限掩码：umask 333（只会在当前的shell会话中起作用，不会永久更改系统默认的权限掩码，要想永久更改权限在配置文件中更改）（已经创建的文件不会

更改权限，只适用于新创建的文件）

2.修改已经创建文件的权限：

针对指定用户添加或删除权限：chmod [augo] +/- [rwx] bcd.txt（a是全部人）

直接使用八进制数字指定：chmod 777 bcd.txt

特殊权限：粘着位（目录文件针对其他用户的一个权限）

功能：每个人（其他用户）只能在目录中创建文件或者删除自己的文件，不能删除别人的文件。

chmod + t  目录 	（给目录设置粘着位，可以和其他权限位组合使用）

添加用户：useradd -m username（-m：创建这个用户的同时创建家目录）

设置密码：passwd username

删除用户：userdel -m username

修改文件所有者：chown username 文件或者目录（在linux中目录是文件）

修改文件所属组：chgrp username 文件（在linux中目录是文件）

如果一个文件，你无法进行修改，怎么办？

修改文件所有者成为你自己。（不推荐使用）

修改文件权限，让自己用户拥有可写权限。（需要注意用户自身属于哪类用户）

# 10.总结：

基础指令：

目录相关指令：ls -la，pwd，mkdir -p，rmdir -p，rm -rf，cp -r，mv，cd。

文件相关指令：touch -d，cat，more，less，head -n，tail -n。

打包相关指令：zip/unzip，gzip/gunzip，bzip2/bunzip2，tar -czvf / -xvf。

匹配查找指令：grep -nivR，find -name/-type/-size/amin/mmin/cmin/atime/mtime/ctime

其他相关指令：man，ifconfig，shutdown -h now，reboot。

权限相关指令：su，sudo，useradd -m，userdel，passwd，umask，chmod，chown，chgrp。

涉及到的概念：

1.隐藏文件：文件名称以.开头的文件。

2.linux下的目录结构与磁盘分区关系：目录结构唯一，是一个树形结构，最底层是根目录，可以将磁盘分区挂载在指定目录下。

文件所在位置的路径表示：	绝对路径：路径以根目录作为起始。	相对路径：路径以当前所在路径作为起始。

3.shell以及所执行的指令的基本认识。

4.系统的操作权限：

用户的分类：文件所有者（u）、文件所属组（g）、其他用户（o）。							所有用户（a）

操作的分类：可读（可浏览）、可写（可以创建或删除文件）、可执行（可进入）。 

权限的表示：rwxrwxr-x（775）

权限的掩码：系统中通过掩码控制文件的默认创建权限。（shell中的简单的计算方式：掩码取反，或者777 - 掩码值）

特殊权限：粘着位（针对目录对于其他用户的权限限制，只能创建删除自己的文件，不能删除别人的）



注意点：

1.切换用户之后，不能创建文件，因为不在自己的家目录中，没有权限，需要回到自己的家目录中才能创建文件。

2.cd ~	表示回到自己的家目录（~表示当前用户的主目录）

3.sudo是为用户操作提权的辅助指令，visudo这是一个编辑配置提权用户的命令。
