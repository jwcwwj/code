# 1.本节目标

了解线程概念，理解线程与进程区别与联系。
学会线程控制，线程创建，线程终止，线程等待。
了解线程分离与线程安全概念。
学会线程同步。
学会使用互斥量，条件变量，posix信号量，以及读写锁。
理解基于读写锁的读者写者问题 



线程概念

线程控制

线程安全

线程应用



# 2. 线程概念

有个零件加工工厂，工厂中有1个或多个工人。

工人是干活的，工厂是集体设备资源的载体。

进程就是工厂，线程就是工人。

进程是系统进行资源分配的基本单元，线程是系统进行调度运行的基本单元。



线程就是进程中的一条执行流程，linux下线程执行流程是通过pcb实现的。一个进程中可以有多个线程（pcb），并且这些pcb共享了进程中的大部分资源，相较

于传统pcb较为轻量化，因此linux下的线程也被称作为轻量级进程。



进程与线程的区别：

进程是系统进行资源分配的基本单元，线程是cpu或者操作系统进行运行调度的基本单元。



在最早学习进程的时候，认为进程就是pcb，是一个程序运行的动态描述，通过这个描述符操作系统实现程序运行调度以及管理。

但是在学习到线程的时候，才知道linux下的pcb实际上是一个线程，是进程中的一条执行流程，一个进程中可以有多个pcb，这些pcb共享进程中的大部分资源，

因此也被称作为轻量级进程。

进程是资源分配的基本单元，线程是cpu或者操作系统调度运行的基本单元。



# 3.线程间的独有与共享

独有：标识符、栈（每个线程都有自己独立的栈）、寄存器（这里不是cpu上的存储单元，是保存的上下文数据的存储单元，是pcc中的变量）、信号屏蔽字（信

号的阻塞集合，每一个线程的pcb中都会有两个集合，线程或进程公共的阻塞集合和自己独立的阻塞集合，公共的叫做阻塞信号）、errno（返回或者保存上一

回系统调用错误原因的编号），这些事最基本的，还有很多需要去了解。

 

信号对多线程的影响：信号在处理之前先注销，为了防止信号被重复处理，因为进程中可能会存在多执行流的，一个线程就是一个执行流，信号是通知进程发生的

事件，而不是单单的通知某个线程，事件只有一个，到底是谁去处理这个事件，一个线程去处理就可以了，先注销是为了防止其他或多个线程去处理。

信号在多线程的处理逻辑：进程里面的哪个线程（执行流）拿到时间片，刚好探测到有这个信号，就去处理这个信号。

如果不想让某个线程去处理这个信号，可以让这个线程单独的去阻塞这个信号。





共享：虚拟地址空间（共享当前的代码段和数据段，每一个线程都可以访问这段代码，相同的页表实现数据通信）、IO信息（文件描述符表信息，这个线程打开的

文件，返回的描述符给到另一个线程，另一个线程就可以操作这个文件，进程之间是数据独有的，多线程是共有的，多线程之间是会受到影响的）、信号处理方式

（信号是针对整个进程产生效果，如果进程中的线程对同一个信号的处理方式不一样，到底让哪一个线程处理才算标准就会出现歧义，一个进程中的线程处理方

式是完全一致的，都是相同的处理方式）、工作路径（一个程序运行起来后运行时所在的路径就是这个进程或者线程的工作路径，创建一个文件如果不制定路径，

那么就会默认这个进程的路径就是当前工作路径下，工作路径不同，意味着创建的文件的所在路径就不一样，工作路径对文件编写是有影响的） ，这些是最基础

的，还有很多需要之后了解。



## 3.1单独阻塞一个线程

```shell
man sigaction
```

```c
int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);
```

不会影响整个进程，只会影响当前这个线程



# 4.多进程与多线程进行多任务处理的优缺点

没有谁好谁坏，分析好坏是从优缺点进行分析的，好坏是根据使用场景决定的。

线程优点：

1.线程间通信更加灵活：包括进程间通信方式在内还可以使用全局变量或者函数传参来实现。（只要能拿到某个变量的地址，其他线程就可以直接访问）

2.线程的创建与销毁成本更低。

3.线程间的切换调度成本更低。



进程优点：

1.稳定，健壮性好。（一个线程崩溃会导致这个线程的进程中的所有线程都崩溃，进程间一个进程崩溃完全不影响其余的进程。）



进程与线程的使用场景：

程：主程序安全性要求高的场景，比如shell、网络服务器。

线程：其他的场景下都使用线程。



总结：多任务处理都可以使用多线程，只不过安全性高的情况下一般使用多进程。

多任务处理中，并不是进程或者线程越多越好。（执行流多了就可以同时进行，看起来越多越好，实际上不是的，实际上是CPU资源是有限的，一个CPU核心就有

一套独立的寄存器。）

多核CPU：一个CPU里面有几个核，就可以并行调度运行多少个程序。（执行流越多意味着pcb越多，pcb多了但是在你CPU资源不够的情况下反而增加了程序的

切换调度的使用，并不是越多越好。）

多任务处理中，并不是进程或者线程越多越好。执行流太多，反而会增加切换调度的成本。（创建太多进程，会在系统调度切换的时候浪费大量的时间。）



IO密集型程序：程序中大量进行IO操作。

CPU密集型程序：程序汇总大量进行数据运算操作。



# 5.线程控制（操作）

## 5.1线程创建

```shell
man pthread_create
```

```c
#include <pthread.h>
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
```

作用：创建一个新的线程。

种类：是库函数手册。（mna 3）（linux并没有向上提供用于创建线程的接口。有一种说法是linux操作系统没有线程）

线程是对系统调用接口进行封装实现了上层用户态的线程控制接口。（对线程的操作接口都是库函数）

线程只是一个说法，对于linux操作系统来说是没有的。

参数：

thread：用于获取线程id			

attr：用于线程属性设置，通常置NULL，不设置		

第三个参数：函数指针（回调函数），线程入口函数（这个函数就是线程要运行的函数，函数退出了就是线程退出了，pcb就销毁掉了） 		

arg：传递给线程的数据（就是传递给第三个参数的参数）（void*是强制转换，传递的参数必须要小于8个字节，一般不是结构体这种自定义类型）

返回值：成功返回0，失败返回非0值（不是系统调用接口，系统调用接口大多成功返回1，失败返回0）（错误的结果不是通过error number保存的，是直接返回

的，不是系统调用接口）

![image-20230904211434866](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230904211434866.png)

注意点：线程不分父子线程，因为线程这个概念不是操作系统内核的，是人为定义的。

一个程序进来的main函数叫做主线程，其他的线程叫做普通线程。

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>


//线程的入口函数
void* thr_entry(void* arg)
{
    printf("%s\n", (char*)arg);
    //串行的死循环只能执行到一个，但是并行的死循环是都可以执行到的
    while(1)
    {
        printf("i am normal thread -- %ld -- %d\n", pthread_self(), getpid());
        sleep(1);
    }
    
    return NULL;        //有没有都可以
}

int main()
{
    pthread_t tid;      //用于获取线程id
    int ret;
    char* ptr = "今天的天气好晴朗\n";
    
    //pthread_create(获取ID, 属性, 入口函数, 传入入口函数的参数);
    ret = pthread_create(&tid, NULL, thr_entry, (void*)ptr);        //第四个参数是强制转换的，必须要小于8个字节

    if(ret != 0)
    {
        //线程创建失败
        printf("pthread_create failed!\n");
        return -1;
    }

    //创建子进程
    pid_t pid = fork();

    while(1)
    {
        //线程不分父子线程，因为线程这个概念不是操作系统内核的，是人为定义的
        printf("i am mian thread -- %ld -- %d\n", pthread_self(), getpid());     //返回线程id
        sleep(1);
    }

    return 0;
}
```

```makefile
create:create.c
	gcc $^ -o $@ -lpthread	#线程是库函数，需要包函系统调用接口库函数的头文件选项
```

线程谁先运行是没有顺序的，取决于操作系统的调度顺序。

线程的操作是不安全的，线程的创建是分流的，常见的操作是先创建一个线程，再在线程内部创建一个进程去运行线程，这样是安全的。

```shell
ps -ef -L | head -n 1 && ps -ef -L | grep create		#查看轻量级进程（线程）
```

在一个终端中运行程序：
![image-20230905073313779](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230905073313779.png)

在另外一个终端中查看轻量级进程（线程）：
![image-20230905073354417](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230905073354417.png)

线程id是LWP。

在每个线程的pcb中都有一个pid和tgid。

pid是轻量级进程id LWP

tgid是线程组id，默认等于主线程的pid。

tid：这是一个地址，线程独有空间的地址。

![image-20230905075855954](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230905075855954.png)



## 5.2线程退出

退出：如何退出线程。

三种方式：

1.线程入口函数中return。（线程入口函数运行完毕，则线程会退出。）

备注：进程退出，所有线程都会退出。

在主线程中main函数中return退出的是进程。

2.

```shell
man pthread_exit
```

```c
void pthread_exit(void *retval);
```

在任意位置调用都可以退出线程。

参数：retval是要返回的值。没有什么要返回的置NULL。

备注：主线程退出不会导致进程退出，线程退出不会立即释放资源，会成为僵尸线程，需要线程等待操作，操作系统中没有僵尸线程这么一说，只是在状态位的体

现就是僵尸 。

进程退出会退出所有的线程。

所有线程退出，才会退出进程。

3.

```shell
man pthread_cancel
```

```c
int pthread_cancel(pthread_t thread);
```

取消一个线程，取消别人。

参数：thread是线程id。

作用：退出指定的线程，在当前线程可以退出别人的线程。（被动退出）

操作：可以在主线程中退出普通线程。



总结：

当线程函数执行到末尾或遇到 return 语句时，线程并不会立即终止，而是会等待其它线程或进程来处理退出请求。

当线程被终止时，其资源（如堆栈、文件描述符等）会被操作系统自动回收。然而，如果线程使用了动态分配的内存或其他资源，需要在退出前进行适当的清理和

释放，以避免资源泄露。

线程的退出是异步的，不会立即终止执行，而是等待适当的时机退出。



## 5.3线程等待

 等待一个指定的线程退出。获取退出线程的返回值，回收线程资源。

线程退出后，默认也不会自动释放资源，需要被等待。

```shell
man pthread_join
```

```c
int pthread_join(pthread_t thread, void **retval);
```

pthread_join是一个阻塞接口。

参数：tid：指定要等待的线程id		retval：用于获取退出线程返回值

返回值：成功返回0，失败返回非0，错误编号。

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

//线程的入口函数，传进来的参数是pthread_create函数的第四个参数
void* thr_entry(void* arg)
{
    //char*和char[]的区别:char*是一个常量字符串，保存在代码段，char[]是一个数组，保存在栈区，出函数之后会被释放。
    char* ptr = "hello bit\n";          //返回字符串
    //char ptr[] = "hello bit\n";       //字符串出函数之后已经释放，返回NULL
    sleep(3);
    return (void*)ptr;  //强制转换
}

int main()
{
    pthread_t tid;
    int ret = pthread_create(&tid, NULL, thr_entry, NULL);

    if(ret != 0)
    {
        printf("thread create error\n");
        return -1;
    }

    //线程等待，防止资源没有释放，默认是不会释放的。
    //pthread_join(线程tid, 获取线程退出返回值);
    //是一个阻塞函数，会一直等待，直到退出。
    void* retval = NULL;
    pthread_join(tid, &retval);
    
    //打印线程等待信息，是一个字符串。
    printf("retval:%s\n", (char*)retval);

    while(1)
    {
        printf("i am main thread\n");
        sleep(1);
    }

    return 0;
}
```

当线程等待其他线程或进程时，会进入睡眠状态，此时操作系统会将该线程从执行队列中移除。但是，线程所占用的资源并不会立即被释放，而是在等待期间继续占用这些资源。

具体来说，线程等待时会释放一些资源，如 CPU 资源，以便让其它线程或进程运行。但是，线程所占用的内存、打开的文件、网络连接等资源并不会被立即释放，而是在线程退出后由操作系统回收。

需要注意的是，如果线程对某些资源（如锁、信号量等）进行了加锁或占用，那么在等待期间这些资源也会被占用，直到它们被释放为止。

另外，如果使用了类似 Pthreads 的线程库，可以通过调用 `pthread_cond_timedwait()` 或 `pthread_cond_wait()` 函数的带有超时参数的版本，在等待期间定期检查是否应该停止等待。这样，即使没有收到通知，线程也可以在超时后自动退出等待状态，从而避免无限等待导致的程序挂起问题。

综上所述，虽然等待的线程会释放一些资源，但并不一定会立即释放所有占用的资源，因此在编写多线程程序时要注意资源管理和使用。



在默认情况下，当一个线程等待其他线程时，并不会立即释放它所占用的资源。相反，该线程会保持对资源的占用，直到等待条件满足并返回。

例如，在使用 `pthread_join()` 函数等待其他线程结束时，默认情况下，等待线程会一直占用其所分配的堆栈和其他系统资源，直到被等待的线程退出并返回。

这就意味着，如果等待线程占用了许多资源或者执行时间较长，它可能会导致资源浪费和性能问题。

如果想要在线程等待期间释放资源，可以通过使用线程同步机制（如条件变量或互斥锁）来实现。当等待条件未满足时，线程可以主动释放资源并进入休眠状态，直到条件满足后再重新获取资源并继续执行。

因此，在编写多线程程序时，请确保正确使用适当的线程同步机制以避免资源占用和性能问题。对于不需要立即释放资源的等待情况，使用合适的同步机制能够更好地控制线程的资源占用和唤醒时机。



总结：线程等待不会立即释放资源。



## 5.4线程分离

线程有个属性：分离属性。

分离属性默认是joinable状态，处于joinable的线程退出之后不会自动释放资源，需要被其他线程等待。

分离：将线程的分离属性，设置为detach状态。

处于detach状态的线程退出后，会自动释放资源，不需要被等待，也不能被等待，资源退出之后获取不到返回值。

应用场景：不关心线程的退出返回值，也不想等待一个线程退出。

```shell
man pthread_detach
```

```c
int pthread_detach(pthread_t thread);
```

参数：thread：线程ID

返回值：成功返回0，失败返回错误编号。

失败的情况（错误编号）：

EINVAL：线程的属性不是joinable状态。

ESRCH：线程ID不对，找不到线程（没有线程）。



使用情况：

1.在主线中使用，修改创建的线程的分离属性为detach；（常见）

2.在线程入口函数刚开始的地方使用。（分离自己，将自己的线程ID传入进去，这样做主线程就不管了，在主线程中只管创建就可以了）

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

//线程的入口函数，传进来的参数是pthread_create函数的第四个参数
void* thr_entry(void* arg)
{
    //在线程的入口函数中分离自己，这样做主线程中就不用管了，在主线程中只管创建就可以了
    pthread_detach(pthread_self());
    

    //char*和char[]的区别:char*是一个常量字符串，保存在代码段，char[]是一个数组，保存在栈区，出函数之后会被释放。
    char* ptr = "hello bit\n";          //返回字符串
    //char ptr[] = "hello bit\n";       //字符串出函数之后已经释放，返回NULL
    sleep(3);
    return (void*)ptr;  //强制转换
}

int main()
{
    pthread_t tid;
    int ret = pthread_create(&tid, NULL, thr_entry, NULL);

    if(ret != 0)
    {
        printf("thread create error\n");
        return -1;
    }

    //线程等待，防止资源没有释放，默认是不会释放的。
    //pthread_join(线程tid, 获取线程退出返回值);
    //是一个阻塞函数，会一直等待，直到退出。
    //void* retval = NULL;
    //pthread_join(tid, &retval);
    
    //打印线程等待信息，是一个字符串。
    //printf("retval:%s\n", (char*)retval);

    //将线程的分离属性设置为detach状态
    //没有显示效果，仅仅是防止资源泄漏的操作
    pthread_detach(tid);

    while(1)
    {
        printf("i am main thread\n");
        sleep(1);
    }

    return 0;
}
```

线程默认分离属性默认是joinable，默认是不释放资源的，需要设置为detach分离属性，这样做就会自动释放资源，就不用等待了，也不能进行等待的操作，释放

资源之后是没有返回值的。

## 5.5总结以及其余操作

在 C++ 中，可以使用不同的方法创建和管理线程。以下是一些常见的线程操作：

1. 创建线程：可以使用 POSIX 线程库（pthread）或 C++11 标准引入的 `std::thread` 类来创建线程。通过调用相关的函数或构造函数，并提供线程函数（或可调用对象）作为参数，即可创建新线程。
2. 启动线程：在创建线程后，可以通过调用 `pthread_create()` 函数（对应 POSIX 线程库）或 `std::thread` 对象的成员函数 `std::thread::start()`（对应 `std::thread` 类）来启动线程。线程创建后会立即开始执行线程函数。
3. 线程函数：线程函数是在线程中实际执行的代码块，可以是一个函数指针、函数对象、lambda 表达式等。线程函数定义了线程的主要任务。
4. 线程等待：在主线程中，可以使用 `pthread_join()` 函数（对应 POSIX 线程库）或 `std::thread` 对象的成员函数 `std::thread::join()`（对应 `std::thread` 类）来等待线程的完成。这样可以确保主线程在子线程完成后继续执行。
5. 线程分离：通过调用 `pthread_detach()` 函数（对应 POSIX 线程库）或 `std::thread` 对象的成员函数 `std::thread::detach()`（对应 `std::thread` 类），可以将线程设置为分离状态。这样的线程将在完成后自动释放资源，无需显式地调用线程等待函数。
6. 线程同步：当多个线程同时访问共享数据时，可能会引发竞态条件（race condition）。为了避免数据不一致或其他问题，可以使用互斥锁（mutex）、条件变量（condition variable）等线程同步机制。
7. 线程间通信：线程之间可以通过共享内存进行简单的通信。此外，还可以使用消息队列、管道、信号量等进程间通信（IPC）机制来实现线程间的数据交换和通信。

这些是常见的线程操作，但还有其他更高级的概念和技术，例如线程池、线程优先级、线程取消等。根据具体的需求和场景，可以选择适合的线程操作方法。



# 6.线程安全（线程间通信）

概念：描述的是线程中对临界资源的访问操作是安全的。

实现：同步与互斥。

互斥：通过对临界资源同一时间的唯一访问保证访问操作安全。

同步：通过条件判断使对临界资源访问或获取更加合理。

互斥的实现：互斥锁

互斥锁：本质就是一个只有0和1的计数器，用于标记临界资源的访问状态。

互斥锁的值不是直接表示可访问性，互斥锁的值为0表示未锁定状态，为非0值（通常是1）表示锁定状态。

当一个线程调用 `pthread_mutex_lock` 函数时，如果互斥锁当前是未锁定状态（值为 0），那么该线程将获得互斥锁，并将互斥锁的值设为非零（通常是 1）。

这样，在获得锁的线程执行期间，其他试图获得同一个互斥锁的线程将被阻塞，因为互斥锁的值非零，表示已经被锁定。

换句话说，互斥锁的值不是用来控制访问权限的，而是用来表示互斥锁的状态（锁定与否）。通过加锁和解锁操作来控制对共享资源的访问。

所以，在使用互斥锁时，线程需要遵循以下基本原则：

1. 线程在访问共享资源之前，调用 `pthread_mutex_lock` 函数获取互斥锁。
2. 如果互斥锁当前是未锁定状态（值为 0），线程获得互斥锁的控制权，并将互斥锁的值设置为非零，表示已锁定状态。
3. 调用 `pthread_mutex_unlock` 函数释放互斥锁控制权，并将互斥锁的值重置为 0，表示解锁状态。
4. 其他线程在试图获得同一个互斥锁时，如果发现互斥锁的值为非零，表示已被其他线程锁定，将会被阻塞直到互斥锁的值变为 0。

这样，通过互斥锁的加锁和解锁操作，可以有效地保护共享资源的访问，确保在同一时刻只有一个线程可以访问共享资源。

实现互斥原理，在访问临界资源之前加锁（判断是否可访问），不可访问则阻塞（也有不阻塞的）。访问资源完毕之后解锁（将资源状态置为可访问）

互斥锁是一个争抢访问。

互斥锁自身计数的操作是一个原子操作。

互斥锁是通过一次交换的原理实现互斥锁的原子操作，1是可访问，0是不可访问。



## 6.1互斥的实现

接口介绍：

### 6.1.1定义互斥锁变量：

设置一个pthread_mutex_t mutex，是栈上的空间，初始值是不确定的；



### 6.1.2初始化互斥锁变量：

方式1：

```c
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER
```

方式2：推荐

```c
int pthread_mutex_init(pthread_mutex_t* mutex, const pthread_mutexattr_t* attr);
```

作用：pthread_mutex_init函数用于初始化一个互斥锁对象。

参数：

mutex：指向互斥锁变量的指针，用于存储初始化后的互斥锁对象。

attr：一个可选的线程互斥锁属性对象的指针，通常可以将该参数设置为NULL，表示使用默认的属性。

返回值：成功返回0，失败返回一个非0的错误码。



### 6.1.3在访问临界资源前加锁：

```c
int pthread_mutex_lock(pthread_mutex_t* mutex);
```

作用：加互斥锁（用于获取一个互斥锁，以保护共享资源的访问。）

参数：mutex：执行互斥锁变量的指针。

当调用 `pthread_mutex_lock` 函数时，如果互斥锁当前可用，则线程将获得锁，并继续执行后续代码。如果互斥锁当前被其他线程持有，则调用该函数的线程将

被阻塞，直到互斥锁变为可用。

pthread_mutex_lock是一个阻塞操作，一直等待。

返回值：表示函数调用的结果或可能发生的错误情况。

`pthread_mutex_lock` 函数的返回值有以下几种可能：

- 如果函数成功获取到互斥锁（未被其他线程持有），则返回值为 0，表示成功获取锁。
- 如果互斥锁当前已由其他线程持有，则调用线程将被阻塞，直到获取到锁再返回，此时返回值仍然为 0。
- 如果出现错误（如无效的互斥锁指针），则返回值为对应的错误码，用以表示函数调用失败。

常见的错误码包括但不限于以下几种：

- `EINVAL`：表示传递给函数的互斥锁参数无效，即互斥锁指针无效。
- `EDEADLK`：表示线程已经持有了互斥锁，而尝试再次获取互斥锁，导致死锁情况。
- `EFAULT`：表示传递给函数的互斥锁指针指向无效的内存地址。

请注意，在使用 `pthread_mutex_lock` 函数时，需要对返回值进行适当的错误处理，以确保程序的正确性和稳定性。



```c
int pthread_mutex_trylock(pthread_mutex_t* mutex);
```

pthread_mutex_trylock是一个非阻塞操作，尝试获取互斥锁。

`pthread_mutex_trylock` 是 POSIX 线程库中的一个函数，用于尝试加锁一个互斥锁（mutex），但是如果互斥锁当前已被其他线程持有，则不会阻塞，而是立

即返回一个特定的值来表示加锁的结果。

当调用 `pthread_mutex_trylock` 函数时，它会尝试获取互斥锁。如果互斥锁当前空闲（未被其他线程持有），则该线程将获得锁，并返回零。如果互斥锁当前

被其他线程持有，则函数将立即返回一个非零值（通常是 `EBUSY`），表示加锁失败。

需要注意的是，与 `pthread_mutex_lock` 不同的是，`pthread_mutex_trylock` 不会阻塞调用线程，而是根据互斥锁的状态立即返回。因此，在使用 

`pthread_mutex_trylock` 时需要注意以下几点：

- 根据返回值判断是否成功加锁，返回值为 0 表示成功，非零值表示加锁失败。
- 加锁失败时，可以根据具体情况决定采取何种操作，例如等待一段时间后再次尝试加锁或者执行其他处理逻辑。
- 加锁失败并不会使调用线程阻塞，因此需要自己负责处理加锁失败的情况。



### 6.1.4在访问临界资源之后解锁：

互斥锁是不可重入锁，解锁之后自己之后访问的时候可以进去。

可重入锁和不可重入锁是两种不同类型的锁。

可重入锁（Reentrank Lock）：也称为递归锁，是一种支持同一个线程对同一个锁重复获取的锁。若一个线程已经获得了可重入锁，并且在持有该锁的情况下再次

请求获取该锁时，不会发生死锁，而是允许这个线程多次获取该锁，并在后续释放该锁的时候进行相应的次数减少。可重入锁通常使用计数器来记录加锁和解锁的

次数，只有当计数器为0时，其他线程才能获取该锁。

优点：

1.允许同一个线程多次获取同一个锁，避免了死锁情况。

2.内部状态的一致性处理更加方便，例如递归调用函数时可以安全使用锁，而不会导致死锁。

缺点：

1.由于需要维护计数器，可重入锁的实现通常比不可重入锁的实现更加复杂。



不可重入锁（Non-Reentrank Lock）：是一种简单的锁，它不允许同一个线程多次获取同一个锁。如果一个线程已经获得了不可重入锁，在没有释放锁之前，再

次尝试获取该锁将导致死锁。

优点：

1.实现简单，不需要维护计数器。

缺点：

1.不支持同一个线程多次获取一个锁，可能会导致死锁情况。

2.在某些场景下，例如递归调用函数时，使用不可重入锁就无法安全的获取锁。



选择使用可重入锁还是不可重入锁取决于具体的应用场景和需求。通常情况下，如果存在嵌套调用或者需要在同一个线程中对同一个锁进行多次获取的情况，可重

入锁是更好的选择。而对于简单的锁需求，不可重入锁可能更加适合。



解锁不分阻塞和非阻塞，只有1个操作。

```c
int pthread_mutex_unlock(pthread_mutex_t* mutex);
```

作用：用于释放互斥锁，允许其他线程获取该锁。该函数的调用必须在成功获取锁的情况下进行，以确保在不再需要锁时将其释放，避免出现死锁的情况。

参数：mutex：执行互斥锁变量的指针。

返回值：成功返回0表示成功释放互斥锁，失败返回非0值表示出现错误，也可能会出现错误代码。

函数可能会返回错误代码的情况：

1.如果当前线程不是互斥锁的持有者，尝试释放一个未加锁的互斥锁，函数将返回 `EPERM` 错误码。

2.如果传递给函数的参数 `mutex` 不是有效的互斥锁对象指针，函数可能返回 `EINVAL` 错误码。

注意点：

1.必须在成功获取锁的情况下调用 `pthread_mutex_unlock` 函数。当一个线程成功获取了锁后，应在不再需要锁时尽快释放它，以避免资源浪费和死锁的可能

性。

2.应保证互斥锁是当前线程持有的，并且在调用 `pthread_mutex_unlock` 函数之前已经成功获得该锁。如果当前线程未持有该锁或者试图释放未加锁的互斥锁，

行为是未定义的，可能导致不可预测的结果。

备注：在正确使用互斥锁的情况下，`pthread_mutex_unlock` 函数应该始终成功释放锁，所以通常不需要过多地关注其返回值。



### 6.1.5销毁互斥锁

```c
int pthread_mutex_destroy(pthread_mutex_t* mutex);
```

作用：用于销毁互斥锁对象，释放与之相关的资源，完成互斥锁使用后，应该调用该函数进行销毁。

参数：mutex：指向互斥锁对象的指针，指向要销毁的互斥锁。

返回值：成功返回0，失败返回非0值。（在正常情况下销毁互斥锁函数不会失败）

注意点：

1.调用 `pthread_mutex_destroy` 函数会销毁指定的互斥锁，并释放与之相关的资源。销毁一个正在被其他线程锁住的互斥锁是未定义行为，会导致不可

预测的结果，因此在调用该函数之前，应确保没有其他线程正在使用该互斥锁。

2.销毁互斥锁后，就不能再对其进行任何操作，包括加锁和解锁。在销毁互斥锁之前，必须确保所有线程已经停止使用互斥锁。

总结：销毁互斥锁是良好的编程习惯，它可以避免资源泄漏并确保程序的正确性。



备注：多个线程必须使用同一个锁才能实现互斥锁，各自使用各自的锁就没有意义了。

互斥锁本身就是一个临界资源，本身使用原子操作来实现安全性。

本身是安全的，来对临界资源的保护。



### 6.1.6实际使用（黄牛抢票）

线程使用不能使用perror打印错误信息，因为线程的接口都是库函数，操作系统中不存在线程这个概念，perror打印的是系统调用接口的错误，线程一般是通过返回值查看错误编号。

```c
//文件名：mutex.c
//黄牛抢票
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

int tickets = 100;

//黄牛抢票
void* scalpers(void* arg)
{
    //arg是锁
    //加锁和解锁之间的代码叫做临界区，加锁之后只做关于临界资源的操作。
    //在锁里面只做关于临界资源的操作，如果在里面保护了其他操作，降低了效率。
    pthread_mutex_t* mutex = (pthread_mutex_t*)arg;      //类型强转
    
    while(1)
    {
        //arg已经是地址了，不用取地址，mutex也是地址了，不用取地址
        pthread_mutex_lock(mutex);
        if(tickets > 0)
        {
            //有票
            usleep(1);      //睡眠1微秒
            printf("I got a ticket:%d\n", tickets);
            tickets--;
        }
        else
        {
            pthread_mutex_unlock(mutex);
            pthread_exit(NULL);     //参数是返回值，没什么要返回的置空，return也可以达到一样的效果
        }
        pthread_mutex_unlock(mutex);
    }

    return NULL;
}

int main()
{
    pthread_mutex_t mutex;      //定义互斥锁变量，加锁是为了防止数据异常，当前这个程序是为了避免抢到的票是无效的    
    //4个线程抢票
    pthread_t tid[4];
    
    int ret;
    pthread_mutex_init(&mutex, NULL);

    for(int i = 0; i < 4; i++)
    {
        ret = pthread_create(&tid[i], NULL, scalpers, (void*)&mutex);      //第三个参数是函数的地址，给第三个参数的函数传参
        if(ret != 0)
        {
            //线程创建失败
            printf("thread create error\n");
            return -1;
        }
    }

    for(int i = 0; i < 4; i++)
    {
        pthread_join(tid[i], NULL);
    }

    pthread_mutex_destroy(&mutex);

    return 0;
}
```



## 6.2.死锁

死锁概念：程序运行流程因为某种原因卡死无法继续推进。

死锁产生的原因：死锁产生的4个必要条件（情况）。

1.互斥条件：一个资源同一时间只有一个进程或者线程能够访问。

2.不可剥夺条件：我加的锁只有我能解，别人不能解。

3.请求与保持条件：加了A锁后请求B锁，B请求不到，A不释放。

4.环路等待条件：线程1加了A锁，请求B锁，线程2加了B锁请求A锁。

使用互斥锁的时候前两个没办法进行改变的，因为互斥锁本身就具有互斥特性和不可剥夺特性的锁，预防的是出现3和4的情况 。

预防死锁：破坏死锁产生的必要条件（情况3和4）。

1.一定保证加锁和解锁顺序一致。

2.请求不到第二个锁则释放已有的锁。（非阻塞加锁，加不了释放手上已有的锁，这是在加锁顺序一致的情况下进行的，然后在从头加锁，非阻塞加锁是循环操作

的）

避免死锁：银行家算法等（课后调研，实现银行家算法）

已有资源		线程已有资源		线程请求的新资源



### 6.2.1避免死锁的方法

避免死锁的算法主要包括以下几种方法：

1. 加锁顺序：约定所有线程获取锁的顺序，并且在编写代码时保证所有线程按照相同的顺序获取锁。这样可以避免部分死锁情况的发生，但需要谨慎设计锁的层次结构，以避免复杂的依赖关系。
2. 锁超时机制：为每个锁设置一个超时时间，在尝试获取锁时等待一段时间，如果超过设定的时间仍未获取到锁，就放弃当前操作，释放已获取的锁，并进行回退处理。这样可以避免长时间的等待导致的死锁，但可能会引入新的问题，如操作不完整或数据不一致等。
3. 死锁检测与恢复：通过定期检测系统中的死锁情况，并采取一定策略进行恢复。常见的方法包括资源分配图算法、银行家算法等。这种方法可以提高系统的自动恢复能力，但会引入一定的开销。
4. 使用读写锁：对于共享数据，使用读写锁进行读操作的并发控制，而不是使用互斥锁。这样可以提高并发性，减少互斥锁的持有时间，从而降低死锁风险。
5. 避免锁嵌套：在一个线程已经持有一个锁的情况下，尽量避免再次尝试获取其他锁。如果需要获取多个锁，尽量通过事务或其他方式将这些操作合并到一起，减少锁的层次结构。
6. 资源有序分配：按照某种顺序对资源进行分配和释放，确保每个线程按照相同的顺序请求资源，从而避免循环等待导致的死锁。

以上方法都可以在一定程度上避免死锁的发生，但没有一种方法可以完全消除死锁。因此，在编写多线程程序时应该合理设计锁的使用方式，并进行充分的测试与验证，以尽量减少死锁的概率。此外，良好的代码规范、正确的锁使用习惯以及合理的资源管理也是避免死锁的重要手段。



### 6.2.2银行家算法的原理

银行家算法是一种用于避免死锁的资源分配和调度算法，由艾登·W·迪科斯特拉（Edsger W. Dijkstra）于1965年提出。它基于资源的最大需求和可用资源的状态来判断系统是否处于安全状态，从而避免可能导致死锁的资源分配。

银行家算法的核心思想是模拟银行家对客户的贷款请求进行审核，确保系统不会因为分配资源而陷入死锁状态。

算法的基本原理如下：

1. 系统中的每个进程在开始执行之前，需要向操作系统申请其最大需要的资源数量，同时也需要指定已分配的资源数量。
2. 操作系统维护一个数据结构来跟踪每种资源的剩余数量，以及每个进程的最大需求和已分配数量。
3. 当某个进程发出资源请求时，系统首先检查请求的资源数量是否小于等于系统当前剩余的资源数量，如果是，则按照请求分配资源，并更新系统的资源状态。
4. 然后系统会判断分配资源后系统是否还处于安全状态。安全状态意味着系统能够为所有进程分配所需的资源，而不会发生死锁。
5. 如果系统处于安全状态，就继续执行进程的资源请求；如果系统处于不安全状态，则暂时拒绝进程的资源请求，直到系统重新进入安全状态。

通过以上步骤，银行家算法可以保证系统按照合理的方式分配和回收资源，避免了死锁的发生。它的核心思想是预先对资源的需求进行评估和控制，以确保系统资源的合理分配，从而保证系统的安全性和有效性。

需要注意的是，银行家算法要求进程必须在启动时就申请其最大资源需求，并且系统需要事先知道每个进程的最大需求量。这在实际中往往是较为困难的，因此银行家算法在实际中的应用有一定的限制。



### 6.2.3银行家算法的实现

```c
#include <stdio.h>
#include <stdbool.h>

#define MAX_PROCESS 10
#define MAX_RESOURCE 10

int allocation[MAX_PROCESS][MAX_RESOURCE];
int max_required[MAX_PROCESS][MAX_RESOURCE];
int available[MAX_RESOURCE];
bool finished[MAX_PROCESS];

void bankers_algorithm(int num_processes, int num_resources) {
    int need[MAX_PROCESS][MAX_RESOURCE];
    int work[MAX_RESOURCE];
    int i, j, k;

    // 初始化need矩阵和finished数组
    for (i = 0; i < num_processes; i++) {
        for (j = 0; j < num_resources; j++) {
            need[i][j] = max_required[i][j] - allocation[i][j];
        }
        finished[i] = false;
    }

    // 初始化work向量为可用资源
    for (i = 0; i < num_resources; i++) {
        work[i] = available[i];
    }

    int count = 0;
    bool safe_sequence[num_processes];
    while (count < num_processes) {
        bool found = false;

        for (i = 0; i < num_processes; i++) {
            if (finished[i]) {
                continue;
            }

            bool can_allocate = true;
            for (j = 0; j < num_resources; j++) {
                if (need[i][j] > work[j]) {
                    can_allocate = false;
                    break;
                }
            }

            if (can_allocate) {
                // 分配资源给进程i
                for (k = 0; k < num_resources; k++) {
                    work[k] += allocation[i][k];
                }
                safe_sequence[count++] = true;
                finished[i] = true;
                found = true;
            }
        }

        // 没有找到符合条件的进程，说明系统处于不安全状态，退出循环
        if (!found) {
            break;
        }
    }

    if (count == num_processes) {
        printf("系统处于安全状态，存在以下安全序列：\n");
        for (i = 0; i < num_processes - 1; i++) {
            printf("P%d -> ", safe_sequence[i]);
        }
        printf("P%d\n", safe_sequence[num_processes - 1]);
    } else {
        printf("系统处于不安全状态，无法分配资源。\n");
    }
}

int main() {
    int num_processes, num_resources;
    int i, j;

    printf("请输入进程数量：");
    scanf("%d", &num_processes);

    printf("请输入资源数量：");
    scanf("%d", &num_resources);

    printf("请输入每个进程已分配的资源数量：\n");
    for (i = 0; i < num_processes; i++) {
        for (j = 0; j < num_resources; j++) {
            scanf("%d", &allocation[i][j]);
        }
    }

    printf("请输入每个进程最大需要的资源数量：\n");
    for (i = 0; i < num_processes; i++) {
        for (j = 0; j < num_resources; j++) {
            scanf("%d", &max_required[i][j]);
        }
    }

    printf("请输入每种资源的可用数量：\n");
    for (i = 0; i < num_resources; i++) {
        scanf("%d", &available[i]);
    }

    bankers_algorithm(num_processes, num_resources);

    return 0;
}
```



## 6.3同步的实现

同步的实现：通过条件判断实现对资源获取的合理性。（条件变量）

条件变量：pcb等待队列 + 能够使线程阻塞以及唤醒线程阻塞的接口。

条件变量实现同步这里，有等待队列，但是只提供了阻塞以及唤醒线程的接口，至于什么时候阻塞，什么时候唤醒线程需要程序员自己判断。

条件变量使用中，对条件判断由程序员自己完成，而条件判断的依据是一个临界资源，访问时需要被保护，因此条件变量需要搭配互斥锁一起使用。



在多线程编程中，条件变量(condition variable)是一种用于线程同步的机制。它通常与互斥锁(mutex)结合使用，以实现线程之间的协调和同步。



接口介绍：

### 6.3.1定义条件变量

pthread_cond_t cond;



### 6.3.2初始化条件变量

方式1：

pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

方式2：

```c
int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);
```

作用：创建和初始化条件变量。

参数：

cond：指向pthread_cond_t类型的指针，用于存储创建的条件变量。

attr：指向pthread_condattr_t类型的指针，用于设置条件变量的属性，通常传入NULL表示使用默认属性。

返回值：成功返回0，失败返回错误码（非0）

- EAGAIN：资源不足，无法创建条件变量。
- ENOMEM：内存不足，无法分配内存给条件变量的数据结构。

但是在实际使用中，`pthread_cond_init`函数通常不会失败，因此检查其返回值以处理错误并不常见。一般情况下，可以假设`pthread_cond_init`函数成功执

行，并继续使用已初始化的条件变量。

注意点：在初始化条件变量之前，必须先创建并初始化互斥锁（pthread_mutex_t）。条件变量的使用通常需要与互斥锁配合来实现线程同步和互斥访问。



### 6.3.3使线程阻塞

```c
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
```

作用：是一个用于线程同步的条件变量函数，用于阻塞当前线程并等待条件变量的信号。

`pthread_mutex_lock`函数会阻塞当前线程，直到成功获得互斥锁`mutex`。如果互斥锁已经被其他线程锁定，调用线程将被阻塞，直到互斥锁被解锁。

参数：

cond：指向pthread_cond_t类型的指针，表示要等待的条件变量。

mutex：指向pthread_mutex_t类型的指针，表示与条件变量相关联的互斥锁。

返回值：成功返回0，失败返回非0，表示发生了错误。

错误码：

- EINVAL：指定的条件变量或互斥锁无效。
- EPERM：当前线程没有获得互斥锁，或者尝试在另一个线程的互斥锁上等待。

请注意，即使`pthread_cond_wait`函数执行成功，它也不会直接返回任何特定的值或结果。具体的条件变量或互斥锁的状态，以及其他线程对它们的操作，可能

会影响被阻塞线程的后续行为和执行结果。因此，在使用`pthread_cond_wait`函数之前，请确保你正确设置和处理相关的条件变量和互斥锁，以实现所需的线程

同步和通信逻辑。

工作原理：

1. 调用线程在调用`pthread_cond_wait`之前必须先获得`mutex`所代表的互斥锁。这可以通过调用`pthread_mutex_lock`函数来实现。
2. 一旦获得互斥锁，线程调用`pthread_cond_wait`函数，将自己置于等待状态，并释放互斥锁。
3. 当其他线程对与条件变量`cond`关联的互斥锁解锁后，并调用`pthread_cond_signal`或`pthread_cond_broadcast`函数发送信号时，被阻塞的线程将被唤醒。
4. 线程重新获得互斥锁并从`pthread_cond_wait`函数返回，继续执行后续代码。



`pthread_cond_timedwait`函数是一个带有超时时间的条件变量等待函数，用于阻塞当前线程并等待条件变量的信号，但会在达到指定超时时间后自动返回。

函数原型如下：

```c
int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
```

参数说明：

- `cond`：指向`pthread_cond_t`类型的指针，表示要等待的条件变量。
- `mutex`：指向`pthread_mutex_t`类型的指针，表示与条件变量相关联的互斥锁。
- `abstime`：指向`struct timespec`结构体的指针，表示等待的超时时间，即绝对时间。

工作原理：

1. 调用线程在调用`pthread_cond_timedwait`之前必须先获得`mutex`所代表的互斥锁。这可以通过调用`pthread_mutex_lock`函数来实现。
2. 一旦获得互斥锁，线程调用`pthread_cond_timedwait`函数，并指定等待的超时时间。
3. 如果在超时时间内收到相应的信号，则线程会被唤醒，重新获得互斥锁，并从`pthread_cond_timedwait`函数返回。
4. 如果等待超时（即超过了指定的绝对时间），则线程会自动从`pthread_cond_timedwait`函数返回，继续执行后续代码。

需要注意的是，`pthread_cond_timedwait`函数是一个阻塞调用，线程会在等待指定的超时时间内阻塞。如果在超时时间内没有收到信号，则线程会自动返回，继续执行后续代码。超时时间使用的是绝对时间，可以使用`clock_gettime`函数获取当前时间，并进行计算得到超时时间。

`pthread_cond_timedwait`函数通常与互斥锁一起使用，用于在多个线程之间实现条件变量的同步和通信，并且可以设置超时时间以控制等待的时长。这样可以更灵活地处理等待条件的情况，避免线程长时间等待导致程序无响应的情况发生。



补充：

在C语言中，有几种方法可以使线程处于阻塞状态。

1. `pthread_join`函数：

   ```c
   int pthread_join(pthread_t thread, void **retval);
   ```

   `pthread_join`函数会阻塞当前线程，直到指定的线程`thread`结束运行并返回。可以通过`retval`参数获取线程的返回值。

2. `pthread_cond_wait`函数：

   ```c
   int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
   ```

   `pthread_cond_wait`函数会阻塞当前线程，并释放相关的互斥锁`mutex`。它要求先获得`mutex`的锁，然后将当前线程置于等待状态，直到另一个线程通过调用`pthread_cond_signal`或`pthread_cond_broadcast`发送信号来唤醒当前线程。

3. `pthread_mutex_lock`函数：

   ```c
   int pthread_mutex_lock(pthread_mutex_t *mutex);
   ```

   `pthread_mutex_lock`函数会阻塞当前线程，直到成功获得互斥锁`mutex`。如果互斥锁已经被其他线程锁定，调用线程将被阻塞，直到互斥锁被解锁。

4. `sem_wait`函数（信号量）：

   ```c
   int sem_wait(sem_t *sem);
   ```

   `sem_wait`函数会阻塞当前线程，直到信号量`sem`的值大于0。当信号量值大于0时，线程将减少信号量的值并继续执行；否则，线程将被阻塞，直到有其他线程增加信号量的值。

这些函数都可以用于使线程进入阻塞状态，并在满足特定条件时解除阻塞。选择适当的方法取决于你的具体需求和设计。在使用这些函数时，请确保正确设置和使用相关的互斥锁或条件变量，以确保线程同步和避免竞态条件。



### 6.3.4唤醒阻塞的线程

方式1：

```c
int pthread_cond_signal(pthread_cond_t *cond);:
```

作用：用于唤醒一个等待在指定条件变量上的线程。它会选择一个等待的线程并发送信号，以使其从等待状态返回。

参数：

cond：指向pthread_cond_t类型的指针，表示要发送信号的条件变量。

返回值：成功返回0，失败返回非0值，是错误码。

常见的错误码：

1. `EINVAL`：无效的条件变量。可能是因为传递给函数的条件变量指针不是有效的条件变量对象。
2. `EPERM`：没有足够的权限。可能是当前线程没有足够的权限来操作条件变量。

工作原理：

1. 调用线程调用`pthread_cond_signal`函数，并传入要发送信号的条件变量。
2. `pthread_cond_signal`函数选择一个等待在该条件变量上的线程，并发送信号给它。
3. 接收到信号的线程将从等待状态返回，继续执行后续代码。

需要注意的是，`pthread_cond_signal`函数只唤醒一个等待的线程，并且选择的线程是不确定的。如果有多个线程等待在条件变量上，`pthread_cond_signal`函数只会唤醒其中一个线程。如果希望唤醒所有等待的线程，可以使用`pthread_cond_broadcast`函数。

使用`pthread_cond_signal`函数时，通常与互斥锁一起使用，以确保在发送信号之前，互斥锁已被获得，从而避免出现竞态条件。通常的做法是在修改条件变量之前，先获取互斥锁，在发送信号之后，再释放互斥锁。

`pthread_cond_signal`函数在多线程编程中非常有用，用于在线程之间实现条件变量的同步和通信。通过发送信号，可以通知等待线程某个特定的条件已经满足，从而唤醒等待的线程进行后续处理。



方式2：

```c
int pthread_cond_broadcast(pthread_cond_t *cond);
```

作用：用于广播信号给所有等待在指定条件变量上的线程，唤醒它们并使其从等待状态返回。

参数：cond：指向`pthread_cond_t`类型的指针，表示要广播信号的条件变量。

返回值：成功返回0，失败返回错误码，是非0值。

常见的错误码：

1. `EINVAL`：传递给函数的条件变量无效。可能是因为条件变量指针无效或已被释放。
2. `EPERM`：调用该函数的线程没有足够的权限。

工作原理：

1. 调用线程调用`pthread_cond_broadcast`函数，并传入要广播信号的条件变量。
2. `pthread_cond_broadcast`函数会将信号发送给所有等待在该条件变量上的线程，唤醒它们。
3. 接收到信号的线程将从等待状态返回，继续执行后续代码。

需要注意的是，`pthread_cond_broadcast`函数会唤醒所有等待的线程，而不是只唤醒其中一个线程。这样可以确保所有等待的线程都能收到信号并进行后续处理。

与`pthread_cond_signal`函数类似，`pthread_cond_broadcast`函数通常与互斥锁一起使用，以确保在广播信号之前，互斥锁已被获得，从而避免出现竞态条件。通常的做法是在修改条件变量之前，先获取互斥锁，在广播信号之后，再释放互斥锁。

`pthread_cond_broadcast`函数在多线程编程中非常有用，特别是在一次性唤醒多个等待线程的场景下。通过广播信号，可以同时通知所有等待的线程某个特定的条件已经满足，从而唤醒它们进行后续处理。



### 6.3.5销毁条件变量

```c
int pthread_cond_destroy(pthread_cond_t *cond);
```

作用：用于销毁条件变量。在不再需要使用条件变量时，可以通过调用该函数来释放与条件变量相关的资源。

参数：cond：指向`pthread_cond_t`类型的指针，表示要销毁的条件变量。

返回值：成功返回0，失败返回非0的错误码，表示发生了错误。

常见的错误码：

EINVAL：无效的条件变量。

EBUSY：条件变量正在被使用。 

错误码：如果函数调用成功，则条件变量成功销毁，并且不再可以使用。如果函数调用失败，则可能是由于条件变量未正确初始化、已经被销毁或者其他原因导致

的错误。

在调用`pthread_cond_destroy`之后，不应再对被销毁的条件变量进行任何操作，否则可能会导致不可预知的行为。

如果需要判断函数调用是否成功，可以根据返回值进行判断。一般情况下，检查返回值是否等于0即可，如果不等于0，则表示函数调用失败。此时，可以通过查阅

相关的错误码来获取更具体的错误信息，并进行相应的处理。

工作原理：

1. 调用线程调用`pthread_cond_destroy`函数，并传入要销毁的条件变量。
2. `pthread_cond_destroy`函数将会释放与条件变量相关的资源，包括内部状态和系统资源等。

需要注意的是，在调用`pthread_cond_destroy`之前，确保所有使用该条件变量的线程已经停止使用它。否则，在销毁条件变量后，其他线程仍然可能操作已经无效的条件变量，导致未定义的行为。

一般情况下，`pthread_cond_destroy`应该在不再需要使用条件变量时进行调用，以避免资源泄漏。通常的做法是，先对条件变量进行销毁，然后再销毁与其关联的互斥锁。

注意：在多线程编程中，使用条件变量时，需要保证正确的初始化、销毁以及与互斥锁的配合使用，以确保线程间同步和通信的正确性和可靠性。



### 6.3.6综合使用（顾客和厨师）

顾客：

1.加锁；

2.通过碗里有没有饭，判断是否能够吃饭，不能吃则阻塞；

解锁

休眠

被唤醒后加锁

3.吃饭；

4.唤醒厨师；

5.解锁。

厨师：

1.加锁；

2.判断碗里有没有饭，有饭则阻塞；

3.做饭；

4.唤醒顾客；

5.解锁。

注意事项：

1.条件变量使用过程中，条件的判断应该使用循环操作。

1.1四个顾客因为没有饭陷入阻塞；

1.2厨师做好饭，唤醒了四个顾客。

1.3四个顾客中，一个加锁成功吃饭，三个卡在加锁这里；

1.4加锁成功的顾客吃完饭唤醒厨师解锁；

1.5有可能抢到锁的不是厨师而是顾客；

1.6如果没有循环判断则会加锁成功后在没有饭时吃饭。

2.条件变量使用过程中，若有多种角色则需要使用多个条件变量，不同的角色，分开等待，分开唤醒，防止唤醒角色错误。

四个顾客，四个厨师，一个碗。

```c
//文件名：cond.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

//互斥锁
pthread_mutex_t mutex;

//2个条件变量，2哥等待队列，防止死锁
pthread_cond_t cond_customer;
pthread_cond_t cond_cooker;

int bowl = 1;   //1表示碗中有饭

void* cooker(void* arg)
{

    while(1)
    {
        //加锁
        pthread_mutex_lock(&mutex);
        while(bowl == 1)
        {
            //等待  阻塞等待
            pthread_cond_wait(&cond_cooker, &mutex);
        }
        //做饭
        printf("我做好了一碗饭\n");
        bowl++;
        //唤醒顾客
        pthread_cond_signal(&cond_customer);
        //解锁
        pthread_mutex_unlock(&mutex);
    }
    return NULL;
}

void* customer(void* arg)
{
    while(1)
    {
        //加锁
        pthread_mutex_lock(&mutex);
        while(bowl == 0)
        {
            //等待
            pthread_cond_wait(&cond_customer, &mutex);
        }
        //吃饭
        printf("真好吃\n");
        bowl--;
        //唤醒厨师
        pthread_cond_signal(&cond_cooker);
        //解锁
        pthread_mutex_unlock(&mutex);
    }
    return NULL;
}

int main()
{
    pthread_t ctid, dtid;       //ctid是厨师，dtid是顾客。
    int ret;

    //初始化互斥锁
    pthread_mutex_init(&mutex, NULL);
    //初始化条件变量
    pthread_cond_init(&cond_cooker, NULL);
    pthread_cond_init(&cond_customer, NULL);

    //厨师线程  4个厨师
    for(int i = 0; i < 4; i++)
    {
        ret = pthread_create(&ctid, NULL, cooker, NULL);
        if(ret != 0)
        {
            //线程创建失败
            printf("thread create error\n");
            return -1;
        }
    }

    //顾客线程  4个顾客
    for(int i = 0; i < 4; i++)
    {
        ret = pthread_create(&dtid, NULL, customer, NULL);
        if(ret != 0)
        {
            //线程创建失败
            printf("thread create error\n");
            return -1;
        }
    }   
    
    pthread_join(ctid, NULL);
    pthread_join(dtid, NULL);

    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond_cooker);
    pthread_cond_destroy(&cond_customer);

    return 0;
}   
```



### 6.3.7综合使用（生产者与消费者模型）

生产者与消费者模型：是一种非常典型的设计模式。

设计模式：大佬们针对典型的应用场景设计的解决方案。

应用场景：有大量数据产生以及进行处理的场景。

生产者：产生数据，入队。

消费者：数据处理，出队。

![image-20230910200801381](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230910200801381.png)、

优势：解耦合（生产和消费分开）、支持忙闲不均、支持并发。

实现：2种角色的线程 + 线程安全的队列（阻塞队列）

线程安全：

生产者与生产者：互斥。

消费者与消费者：互斥。

生产者与消费者：同步 + 互斥。

实现：实现一个线程安全的数据队列（缓冲区） + 两种角色的线程。

```cpp
//文件名：pro_con.cpp
#include <iostream>
#include <queue>
#include <pthread.h>

#define MAX_QUEUE 5

class BlockQueue
{
private:
    int _capacity;      //容量
    std::queue<int> _queue;		//队列
    pthread_mutex_t _mutex;		//锁
    pthread_cond_t _cond_pro;   //生产者条件变量（等待队列），入队
    pthread_cond_t _cond_cus;   //消费者条件变量（等待队列），出队
public:
    BlockQueue(int cap = MAX_QUEUE)
        :_capacity(cap)
    {
        pthread_mutex_init(&_mutex, NULL);
        pthread_cond_init(&_cond_pro, NULL);
        pthread_cond_init(&_cond_cus, NULL);
    }

    ~BlockQueue()
    {
        pthread_mutex_destroy(&_mutex);
        pthread_cond_destroy(&_cond_pro);
        pthread_cond_destroy(&_cond_cus);
    }

    bool Push(int data)
    {
        //加锁
        pthread_mutex_lock(&_mutex);
        while(_queue.size() == _capacity)
        {
            //线程等待  生产者阻塞
            pthread_cond_wait(&_cond_pro, &_mutex);
        }

        _queue.push(data);
        //唤醒线程
        pthread_cond_signal(&_cond_cus);
        //解锁
        pthread_mutex_unlock(&_mutex);
        return true;
    }

    bool Pop(int* data)
    {
        pthread_mutex_lock(&_mutex);
        while(_queue.empty())
        {
            pthread_cond_wait(&_cond_cus, &_mutex);
            //解释pthread_cond_wait
            //pthread_mutex_ublock()
            //pause()
            //上面的两步是原子操作，不能被打断
            //pthread_mutex_lock()
        }
        *data = _queue.front();
        _queue.pop();
        pthread_cond_signal(&_cond_pro);
        pthread_mutex_unlock(&_mutex);
        return true;
    }
};

void* productor(void* arg)
{
    //生产者入队
    BlockQueue* q = (BlockQueue*)arg;
    int i = 0;
    while(1)
    {
        q->Push(i);
        printf("%ld-push data:%d\n", pthread_self(), i++);
    }
    return NULL;
}

void* customer(void* arg)
{
    //消费者出队
    BlockQueue* q = (BlockQueue*)arg;
    while(1)
    {
        int data;
        q->Pop(&data);
        printf("%ld-get data:%d\n", pthread_self(), data);
    }
    return NULL;
}

int main()
{
    BlockQueue q;
    int count = 4, ret;
    pthread_t ptid[4], ctid[4];
    for(int i = 0; i < count; i++)
    {
        ret = pthread_create(&ptid[i], NULL, productor, &q);
        if(ret != 0)
        {
            printf("thread create error\n");
            return -1;
        }
    }
    
    for(int i = 0; i < count; i++)
    {
        ret = pthread_create(&ctid[i], NULL, customer, &q);
        if(ret != 0)
        {
            printf("thread create error\n");
            return -1;
        }
    }

    for(int i = 0; i < count; i++)
    {
        pthread_join(ptid[i], NULL);
        pthread_join(ctid[i], NULL);
    }
    return 0;
}
```



### 6.3.8使用实例

```c
#include <stdio.h>
#include <pthread.h>

pthread_mutex_t mutex;
pthread_cond_t cond;

int count = 0;    // 全局变量，表示初始化工作的进度

void* worker(void* arg) {
    printf("Worker: 正在进行初始化...\n");

    // 模拟初始化过程
    sleep(2);

    // 加锁
    pthread_mutex_lock(&mutex);

    count++;

    printf("Worker: 初始化完成，发送条件信号...\n");

    // 发送条件信号给等待线程
    pthread_cond_signal(&cond);

    // 解锁
    pthread_mutex_unlock(&mutex);

    pthread_exit(NULL);
}

int main() {
    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&cond, NULL);

    pthread_t tid;
    pthread_create(&tid, NULL, worker, NULL);

    printf("Main: 等待工作线程完成初始化...\n");

    // 加锁
    pthread_mutex_lock(&mutex);

    // 等待条件变量满足
    while (count == 0) {
        pthread_cond_wait(&cond, &mutex);
    }

    printf("Main: 工作线程已完成初始化，继续执行...\n");

    // 解锁
    pthread_mutex_unlock(&mutex);

    // 等待工作线程结束
    pthread_join(tid, NULL);

    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond);

    return 0;
}
```

```shell
#在shell终端中编译，-lpthread选项指示编译器链接pthread库
gcc xianchentongbugpt.c -o xianchentongbugpt -lpthread
```

执行结果：
![image-20230909012853288](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230909012853288.png)

在上述示例代码中，主线程创建了一个工作线程(worker)来进行初始化工作。主线程通过条件变量等待工作线程完成初始化。

1. 首先，在主线程中初始化了互斥锁(mutex)和条件变量(cond)。
2. 接着，主线程创建了工作线程，并等待工作线程完成初始化。
3. 在工作线程中，它进行了一些模拟的初始化操作，然后加锁，更新全局变量(count)的值，然后发送条件信号给等待线程。
4. 在主线程中，它加锁后进入循环等待条件变量被满足。如果条件变量不满足，则通过pthread_cond_wait()函数释放锁并等待条件信号。一旦收到条件信号，它重新获得锁，并继续执行。
5. 最后，主线程等待工作线程结束，并释放互斥锁和条件变量。



条件变量的使用必须与互斥锁配合使用。通过互斥锁保护共享数据，并在等待条件变量时自动释放锁，从而允许其他线程修改共享数据。当条件变量满足时，线程

会重新获取锁，并继续执行。

以上代码仅为示例，实际的多线程编程中，还需要进行错误处理和适当的线程安全设计。



## 6.4信号量

本质：计数器（资源计数） + pcb等待队列。

作用：实现进程或线程间的同步与互斥。

操作：

P操作：计数-1，计数<0则阻塞执行流，否则则返回。

V操作：计数+1，唤醒一个阻塞的执行流。

同步的实现：通过计数器对资源进行计数。

在获取资源之前，进行P操作；产生资源之后，进行V操作。

互斥的实现：初始化初值为1，表示资源只有1个。

在访问资源之前进行P操作；访问资源完毕之后进行V操作。

1表示可访问，0表示不可访问。

### 6.4.1定义信号量

sem_t sem;

### 6.4.2初始化信号量

是一个 POSIX 信号量的初始化函数，用于创建并初始化一个信号量对象。

```shell
man 3 sem_init
```

```c
#include <semaphore.h>
int sem_init(sem_t *sem, int pshared, unsigned int value);
```

作用：创建并初始化一个信号量对象，将其存储在 `sem` 指向的内存位置。信号量的初值由 `value` 参数指定。

参数：

sem：指向要初始化的信号量的指针。

pshared：指定信号量的共享方式。如果为 0，则表示信号量只能在当前进程中使用；如果为非零值（通常为 1），则表示信号量可以在多个进程之间共享。

0表示在同一个进程的线程间使用，非0表示在进程间使用。

value：指定信号量的初始值。

返回值：成功返回0，表示信号量初始化成功，失败返回-1，并设置合适的错误码，表示出现了错误。

需要注意的是，`sem_init` 函数主要用于在进程内部使用，如果要在多个进程之间共享信号量，应该使用 `sem_open` 函数来创建一个具名的信号量。



```c
sem_t *sem_open(const char *name, int oflag);
sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value);
```

`sem_open` 是一个 POSIX 信号量的创建函数，用于创建或打开一个具名的信号量对象。（具名信号量是有名字的信号量，sem_init是初始化匿名信号量的）

- `name`：指定要创建或打开的信号量对象的名称。对于具名信号量，名称应以斜杠 `/` 开头，并且在系统范围内是唯一的。
- oflag：指定打开或创建信号量的标识符。可以使用以下值进行逻辑或运算：
  - `O_CREAT`：如果信号量不存在，则创建它。
  - `O_EXCL`：与 `O_CREAT` 同时使用，确保只有当前调用成功地创建了信号量。
  - `O_RDWR`：以可读写方式打开信号量。
- `mode`：指定创建信号量时的权限。当需要创建信号量时（即 `oflag` 包含 `O_CREAT`），该参数会生效。
- `value`：指定信号量的初始值。

`sem_open` 函数返回一个指向 `sem_t` 类型的信号量对象的指针。如果创建或打开信号量失败，函数返回 `SEM_FAILED`。

需要注意的是，通过 `sem_open` 创建的信号量可以在多个进程之间共享。使用完信号量后，应使用 `sem_close` 关闭信号量并释放相关资源。

另外，还可以使用 `sem_unlink` 函数来删除具名信号量对象。



`sem_unlink` 函数用于删除具名信号量（named semaphore）。具名信号量是在文件系统中创建的，可以通过名称引用和访问。

```c
int sem_unlink(const char *name);
```

参数： `name` 是要删除的具名信号量的名称。

返回值：成功删除返回0，删除失败返回-1。

调用 `sem_unlink` 函数后，具名信号量将被从文件系统中删除，不再可用。请注意，删除具名信号量并不会自动释放进程中已打开的该信号量的资源，因此在删除信号量之前，确保所有打开的信号量都已关闭。

通常情况下，只有在不再需要使用某个具名信号量时才应调用 `sem_unlink` 函数。这样可以确保不会出现资源泄漏，并且可以在需要时重新创建同名的具名信号

量。



### 6.4.3P操作

```c
int sem_wait(sem_t *sem);
int sem_trywait(sem_t *sem);
int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
```

sem_wait函数作用：是一个信号量操作函数，用于减少（获取）信号量的值。（是阻塞函数）

函数说明：

- `sem_wait` 用于减少（获取）由参数 `sem` 指向的信号量的值。
- 如果信号量的值大于 0，则将信号量的值减少 1，并立即返回。
- 如果信号量的值为 0，则线程会阻塞等待，直到信号量的值大于 0。
- 通过调用 `sem_post` 函数可以增加信号量的值，以唤醒等待的线程。

参数：sem：指向要初始化的信号量的指针。

返回值：成功减少信号量的值返回0，出现错误返回-1.



sem_trywait函数作用：是一个信号量操作函数，用于尝试减少（获取）信号量的值。（是非阻塞函数）

函数说明：

- `sem_trywait` 用于尝试减少（获取）由参数 `sem` 指向的信号量的值。
- 如果信号量的值大于 0，则将信号量的值减少 1，并立即返回。
- 如果信号量的值为 0，则 `sem_trywait` 不会阻线程，而是立即返回，并返回一个非零的错误码 `EAGAIN`（资源暂时不可用）。

参数：sem：指向要初始化的信号量的指针。

返回值：成功减少信号量的值返回0，信号量的值为0返回非0的错误码EAGAIN，如果出现其他错误返回-1。



sem_timedwait函数作用：是一个信号量操作函数，用于设置超时时间来尝试减少（获取）信号量的值。（是阻塞函数）

函数说明：

- `sem_timedwait` 用于设置超时时间，在指定时间内尝试减少（获取）由参数 `sem` 指向的信号量的值。
- 如果信号量的值大于 0，则将信号量的值减少 1，并立即返回。
- 如果信号量的值为 0，则线程会阻塞等待，直到以下情况之一发生：
  - 信号量的值大于 0。
  - 超过指定的超时时间。
- `abs_timeout` 参数是一个指向 `timespec` 结构的指针，用于指定超时时间。

参数：

sem：指向要初始化的信号量的指针。

abs_timeout：是一个指向timespec结构体的指针，用于指定超时时间。

返回值：成功减少信号量的值返回0，在超时时间内未能减少信号量的值返回-1

#### 6.4.3.1sem_timedwait的实际使用

```c
#include <semaphore.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <time.h>

int main() {
    sem_t semaphore;
    // 初始化信号量
    sem_init(&semaphore, 0, 1);

    // 设置超时时间为 5 秒
    struct timespec timeout;
    clock_gettime(CLOCK_REALTIME, &timeout);	//clock_gettime用于获取当前系统时间，将系统当前时间存储进结构体对象timeout中，是timespec结构体
    timeout.tv_sec += 5;						//在系统当前时间的基础上加上5秒钟时间，tv_sec表示秒数，tv_nsec表示纳秒数
    //请注意，clock_gettime() 函数的第一个参数 CLOCK_REALTIME 表示使用系统实时时钟来获取时间，而不是单纯的 CPU 时钟。这是因为实时时钟提供了更准确的时间信息，且适用于大多数常见的应用场景。

    // 尝试减少信号量的值，设置超时时间
    int result = sem_timedwait(&semaphore, &timeout);
    if (result == 0) {
        printf("sem_timedwait succeeded\n");
    } else if (result == -1 && errno == ETIMEDOUT) {
        printf("sem_timedwait failed: Timeout\n");
    } else {
        perror("sem_timedwait failed");
    }

    // 销毁信号量
    sem_destroy(&semaphore);

    return 0;
}
```

要在Linux中编译这段代码，你可以使用GCC编译器来进行编译。请按照以下步骤进行操作：

1. 创建一个名为`semaphore_example.c`的文本文件，并将你提供的代码复制粘贴到该文件中。

2. 打开终端，进入到包含`semaphore_example.c`文件的目录。

3. 在终端中运行以下命令来编译代码：

   ```shell
   gcc -o semaphore_example semaphore_example.c -lpthread
   ```

   这个命令将会使用GCC编译器编译`semaphore_example.c`文件，并将生成的可执行文件命名为`semaphore_example`。`-lpthread`选项用于链接线程库，因为信号量需要使用线程库。

4. 如果编译成功，你将在当前目录下生成一个名为`semaphore_example`的可执行文件。

5. 在终端中运行以下命令来执行可执行文件：

   ```shell
   ./semaphore_example
   ```

   这将会运行你的程序，并在终端中显示输出结果。

请注意，为了成功编译和运行该程序，你的系统必须安装有GCC编译器和线程库。如果编译或运行过程中出现任何错误，请确保你的系统满足这些要求，并检查代码中是否存在任何拼写错误或其他语法错误。

执行结果：

![image-20230911053027767](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230911053027767.png)

解释最后面是-lpthread，而不是-semaphore：

`pthread` 库并不直接包含 `semaphore` 库。在 POSIX 线程标准中，并没有显式定义 `semaphore` 相关的函数和数据结构。

然而，一些操作系统的线程库实现包含了 `semaphore` 的实现，而且通常是作为 `pthread` 库的一部分提供。因此，在某些系统上，可以通过链接 `pthread` 库来使用与 `semaphore` 相关的函数和数据结构。

在使用 `pthread` 库时，很多操作系统会同时提供 `semaphore` 相关的函数和数据结构，以便于使用信号量来进行线程同步和互斥操作。这样，在编译时需要链接 `pthread` 库以确保使用这些信号量相关的功能时，能够正确地链接到系统提供的 `semaphore` 实现。

因此，在使用 `semaphore` 的代码中，通常要链接 `pthread` 库来确保可以使用 `semaphore` 功能，即需要使用 `-lpthread` 参数来告知编译器链接 `pthread` 库。这样，编译器才能将正确的 `semaphore` 实现链接到最终的可执行文件中。

总而言之，尽管 `semaphore` 功能不是 `pthread` 标准的一部分，但在某些系统上可以通过链接 `pthread` 库来使用与 `semaphore` 相关的函数和数据结构。

实际上，标准的 C 库或 POSIX 标准库并没有直接提供 `libsemaphore` 库。

`libsemaphore` 并不是标准库中的一部分，而是一个自定义的库。如果您使用的是自行开发的 `libsemaphore` 库，那么您需要将它编译生成为静态库或动态库，并将其指定给编译器进行链接。

假设您已经将 `libsemaphore` 编译为静态库或动态库文件 `libsemaphore.a` 或 `libsemaphore.so`，您可以使用以下方式进行编译和链接：

```shell
gcc -o semaphore_example semaphore_example.c -L/path/to/lib -lsemaphore
```

其中，`-L/path/to/lib` 是用于指定 `libsemaphore` 库所在的路径。`-lsemaphore` 是用于告诉编译器链接名为 `libsemaphore` 的库。

请将 `/path/to/lib` 替换为实际的 `libsemaphore` 库所在的路径，并确保库文件名正确。这样，编译器就可以正确地链接 `libsemaphore` 库，以便在可执行文件中使用 `libsemaphore` 提供的功能。

注意：这里假设您已经正确安装并配置了 `libsemaphore` 库，并且该库的 API 与您的示例代码中的函数和数据结构相匹配。否则，在编译和链接过程中可能会出现错误。



备注：

`pthread` 是 POSIX 标准定义的线程库，用于在 Unix-like 操作系统中进行多线程编程。使用 `pthread` 有以下几个优点：

1. 跨平台性：`pthread` 是 POSIX 标准的一部分，因此可以在各种符合 POSIX 标准的操作系统上使用，例如 Linux、Unix 和 macOS 等。这使得使用 `pthread` 编写的代码具有良好的可移植性。
2. 轻量级：`pthread` 线程是用户级线程，相对于操作系统级线程（kernel-level thread）来说，创建和切换的开销更小。这意味着你可以创建更多的线程，以更细粒度地并发执行任务，提高程序的并发性能。
3. 灵活性：`pthread` 提供了许多线程管理的函数，例如创建线程、终止线程、线程同步和互斥等。这使得你可以根据需要灵活地控制和管理线程的行为，并实现复杂的线程间通信和同步机制。
4. 可扩展性：多线程编程可以充分利用多核处理器的并行计算能力，提高程序的运行效率。通过使用 `pthread` 创建多个线程，可以将计算密集型或阻塞型任务分布到不同的线程上，从而有效地利用多核处理器的资源。
5. 并发性能：多线程编程可以提高程序的并发性能，特别是在需要处理大量并发操作或需要实现实时响应的应用场景下。使用 `pthread` 可以充分发挥计算机的硬件资源，提高整体系统的并发处理能力。

总而言之，使用 `pthread` 可以简化和提高多线程编程的效率，并充分利用计算机的硬件资源，使程序具备更好的并发性能和可扩展性。



#### 6.4.3.2学习clock_gettime函数（用于获取系统时间的函数）（系统调用函数）

`clock_gettime` 是一个用于获取系统时间的函数。它可以提供不同的时间来源和不同的精度，以满足不同的需求。下面是关于 `clock_gettime` 函数的一些基本信息：

函数原型：

```c
#include <time.h>
int clock_gettime(clockid_t clk_id, struct timespec *tp);
```

函数说明：

- `clock_gettime` 用于获取指定时间源（`clk_id`）的当前时间，并将结果存储在 `timespec` 结构体中。

- `clk_id` 参数指定了要使用的时间源，常见的值包括 `CLOCK_REALTIME`、`CLOCK_MONOTONIC` 等。

  ```c
  //timespec结构体定义如下：
  struct timespec {
      time_t tv_sec;  // 秒数
      long tv_nsec;   // 纳秒数
  };
  ```

返回值：

- 如果成功获取系统时间，则返回 0。
- 如果出现错误，则返回 -1，并设置 `errno` 变量来指示具体的错误类型。

下面是一个使用 `clock_gettime` 获取系统时间的简单示例：

```c
#include <stdio.h>
#include <time.h>

int main() {
    struct timespec current_time;
    
    // 获取系统当前时间，使用 CLOCK_REALTIME 时间源
    int result = clock_gettime(CLOCK_REALTIME, &current_time);
    if (result == 0) {
        printf("Current time: %ld seconds, %ld nanoseconds\n", current_time.tv_sec, current_time.tv_nsec);
    } else {
        perror("clock_gettime failed");
    }
    
    return 0;
}
```

```shell
gcc ceshi2.c -o ceshi2 -lpthread
```

运行结果：

![image-20230911055101032](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230911055101032.png)

请注意，上述示例仅供参考，实际使用时需要根据具体情况进行适当修改。同时，需要了解不同的时间源和其对应的特性，以选择合适的时间源来满足需求。

备注：

`clk_id` 参数是用于指定 `clock_gettime()` 函数中的时钟类型的参数。`clock_gettime()` 函数用于获取指定时钟的当前时间。

`clk_id` 参数的取值可以是以下值之一：

- `CLOCK_REALTIME`：表示系统实时时间时钟，即系统的墙上时钟时间。这个时钟的值可以通过设置系统时间来调整。
- `CLOCK_MONOTONIC`：表示系统运行时间时钟，即系统启动后经过的时间。这个时钟不受系统时间调整的影响，适合用于测量时间间隔和计算程序执行时间等场景。
- `CLOCK_PROCESS_CPUTIME_ID`：表示进程 CPU 时间时钟，即记录当前进程执行的 CPU 时间。
- `CLOCK_THREAD_CPUTIME_ID`：表示线程 CPU 时间时钟，即记录当前线程执行的 CPU 时间。

不同的 `clk_id` 代表不同的时钟类型，因此返回的时间值也会有所区别。在使用 `clock_gettime()` 函数时，需要根据具体的需求选择合适的 `clk_id` 来获取对应时钟的时间值。

需要注意的是，`clock_gettime()` 函数在 `<time.h>` 头文件中定义，并且在编译时需要链接 `-lrt` 参数以引入 POSIX 实时库。

上面代码使用-lrt代替-lpthread也是可以的。

gcc编译和执行结果：

![image-20230911055209424](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230911055209424.png)



### 6.4.4V操作

```c
int sem_post(sem_t *sem);
```

作用：是一个信号量操作函数，用于增加（释放）信号量的值。

说明：

- `sem_post` 用于增加（释放）由参数 `sem` 指向的信号量的值。
- 每次调用 `sem_post`，信号量的值都会增加 1。
- 如果有其他进程或线程正在等待这个信号量，它们中的一个（非确定性）将被唤醒，以便可以继续执行。

参数：sem：指向要初始化的信号量的指针。

返回值：成功返回0，失败返回-1。

注意事项：

- 在使用 `sem_post` 函数之前，必须先创建并初始化一个信号量对象，通常使用 `sem_init` 函数进行初始化。
- 当使用完信号量后，应该使用 `sem_destroy` 函数销毁信号量对象，以释放相关的资源。



### 6.4.5销毁信号量

```c
int sem_destroy(sem_t *sem);
```

作用：是一个信号量操作函数，用于销毁（释放）信号量对象所占用的资源。

说明：

- `sem_destroy` 用于销毁由参数 `sem` 指向的信号量对象。
- 销毁信号量对象将释放与该对象相关的资源，并使该对象无效。
- 在调用 `sem_destroy` 之后，不再能够使用已销毁的信号量对象。

参数：参数：sem：指向要初始化的信号量的指针。

返回值：成功销毁信号量对象返回0，失败返回-1。



### 6.4.6信号量综合使用（实现生产者与消费者模型）

环形队列：

![image-20230911005738431](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230911005738431.png)

read表示读，write表示写，read == write表示环形队列是空的，write + 1 == read表示环形队列满了，read和write等于数组的长度就从0开始（就是取余）。

使用信号量实现一个生产者与消费者模型：

```c
class RingQueue
{
    std::vector<int> _arry;
    int _capacity;
    int _step_read;
    int _step_write;
    sem_t_sem_lock;		//用信号量实现互斥
    sem_t_sem_idle;		//当前队列中空闲节点数量
    sme_t_sem_data;		//当前队列中数据节点（非空闲节点）数量
}
```

生产者线程的流程：

1.判断能否入队数据，sem_wait(&_sem_idle);

2.加锁，_arry[write] = data;	write = (write + 1) % capacity;

3.数据节点数量 + 1，解锁，唤醒消费者sem_post(&_sem_data);

消费者线程的流程：

1.判断能否出队数据，sem_wait(&_sem_data);

2.加锁，*data = _arry[read];	read = (read + 1) % capacity;

3.空闲节点 + 1，解锁，唤醒生产者sem_post(&_sem_idle);

```cpp
//文件名：cus_pro.cpp
#include <iostream>
#include <vector>
#include <pthread.h>
#include <semaphore.h>

#define MAX_QUEUE 5

class RingQueue
{
public:
    RingQueue(int cap = MAX_QUEUE)
        :_capacity(cap)
        ,_step_read(0)
        ,_step_write(0)
        ,_arry(cap)
    {
        //sem_init(信号量, 共享标志, 初值);
        sem_init(&_sem_lock, 0, 1);
        sem_init(&_sem_idle, 0, cap);
        sem_init(&_sem_data, 0, 0);
    }

    ~RingQueue()
    {
        sem_destroy(&_sem_lock);
        sem_destroy(&_sem_idle);
        sem_destroy(&_sem_data);
    }

    bool Push(int data)
    {
        sem_wait(&_sem_idle);       //空闲空间数量-1，<0阻塞
        sem_wait(&_sem_lock);        //加锁
        _arry[_step_write] = data;
        _step_write = (_step_write + 1) % _capacity;
        sem_post(&_sem_lock);       //解锁
        sem_post(&_sem_data);       //数据空间数量+1，唤醒消费者
        return true;
    }

    bool Pop(int* data)
    {
        sem_wait(&_sem_data);       //通过数据节点的空间个数来判断能否出队数据
        sem_wait(&_sem_lock);       //可以出队数据的话进行加锁
        *data = _arry[_step_read];
        _step_read = (_step_read + 1) % _capacity;
        sem_post(&_sem_lock);       //解锁
        sem_post(&_sem_idle);       //空闲空间数量+1，唤醒生产者
        return true;
    }

private:
    int _capacity;      //容量
    int _step_read;     //读位置
    int _step_write;    //写位置
    std::vector<int> _arry;
    sem_t _sem_lock;    //锁计数器      进程间是共享内存，线程间全局计数器（锁两种状态：1和非1）
    sem_t _sem_idle;    //空闲空间资源的计数
    sem_t _sem_data;    //数据空间资源的计数
};

void* productor(void* arg)
{
    //生产者入队
    RingQueue* q = (RingQueue*)arg;
    int i = 0;
    while(1)
    {
        q->Push(i);
        printf("%ld-push data:%d\n", pthread_self(), i++);
    }
    return NULL;
}

void* customer(void* arg)
{
    //消费者出队
    RingQueue* q = (RingQueue*)arg;
    while(1)
    {
        int data;
        q->Pop(&data);
        printf("%ld-get data:%d\n", pthread_self(), data);
    }
    return NULL;
}

int main()
{
    RingQueue q;
    int count = 4, ret;
    pthread_t ptid[4], ctid[4];
    for(int i = 0; i < count; i++)
    {
        ret = pthread_create(&ptid[i], NULL, productor, &q);
        if(ret != 0)
        {
            printf("thread create error\n");
            return -1;
        }
    }
    
    for(int i = 0; i < count; i++)
    {
        ret = pthread_create(&ctid[i], NULL, customer, &q);
        if(ret != 0)
        {
            printf("thread create error\n");
            return -1;
        }
    }

    for(int i = 0; i < count; i++)
    {
        pthread_join(ptid[i], NULL);
        pthread_join(ctid[i], NULL);
    }
    return 0;
}
```

### 6.4.7在实现生产者与消费者模型中，条件变量与信号量的区别

1.条件变量的资源获取条件判断需要程序员自己进行，信号量通过自身计数完成。

2.条件变量需要搭配互斥锁一起使用，信号量不用。（信号量是自身的计数不用判断，但是资源的访问依然需要加锁保护。）

## 6.5读者写者模型和读写锁

应用场景：读共享，写互斥的场景。

读共享：大家可以一起读。（不修改只是访问）

写互斥：不能同时写，并且写的时候也不能读。

读写锁：

加读锁：只要当前没人加写锁，都可以加读锁。

加写锁：在既没有人读，也没有人写的时候才能加写锁。

读写锁的加读/写锁是通过自旋锁实现的。



## 6.6自旋锁

自旋锁：占据cpu资源不释放的锁，对访问条件是否满足进行循环判断。（互斥锁会有时间片切换，只是别人不能访问加锁的区间）

自旋锁只适用于临界资源访问操作时间较短的操作。

自旋锁是一只拿着时间片循环判断能否访问的一种锁，加不了锁就循环判断能不能加锁。（自旋锁更加的实时，条件一旦满足了就可以立即访问）

互斥锁是如果加不了锁就阻塞，挂起等待，变为可中断休眠状态。（互斥锁就算条件满足了，可以加锁了，还要被调度、被唤醒的时候才可以加锁）

自旋锁适用于实时的情况，不适用于中间操作耗时很长的情况。



## 6.7锁的种类

锁的种类：乐观锁、悲观锁、可重入锁、不可重入锁。

乐观锁：我比较乐观的认为访问临界资源期间别人不一定回来访问这个锁。（比如CAS锁）（了解CAS锁）

悲观锁：在我访问这个临界资源之前，我无论如何都要先加锁，因为我总是悲观的认为在我访问期间别人来抢我的操作。

互斥锁就是悲观锁中的一种，也是不可重入锁。 



# 7.线程应用

## 7.1线程池的实现

线程池：一堆线程等着处理任务，非常典型的生产者与消费者模型应用。

一堆线程（有最大数量上限） + 线程安全的任务队列。

其他线程将任务跑如线程安全的任务队列中，线程池中的线程从任务队列中获取任务进行处理。

应用场景：针对大量的请求进行处理的场景（比如网络服务器...）

常规情况若要处理大量请求，使用单执行流效率较低，因此采用多执行流提高处理效率。

常规思路：有一个请求，则创建一个线程（时间T1），去处理请求（时间T2），处理完毕后线程销毁（时间T3）。

缺点：效率低。（花费大量时间在创建和销毁线程上，小部分时间在处理请求上，则意味着cpu资源大部分都消耗在线程的创建与销毁上而不是处理任务。）

线程池优势：

1.线程池中的线程创建之后不销毁，而是循环取出任务进行处理（把任务放在线程池中，线程池中的线程取出任务执行），避免了频繁进行线程的创建

与销毁带来的时间成本。

2.线程池中的线程有最大数量限制，并且任务缓冲区/任务队列也有最大的数量限制，一切都是处在可控范围之内的，避免了峰值压力的风险。

线程池实现：

线程池的作用就是针对大量任务进行处理。

任务类型多种多样，但是线程入口函数是固定的，如何实现工作线程？

针对不同的任务进行不同的处理？

1.线程入口函数中，分辨任务类型，调用不同的处理接口。（给出任务，分辨任务类型调用处理接口）

2.其他线程在通过任务队列传入任务的同时，也把这个任务的处理方法传进来，线程池中的线程只需要使用处理方法处理任务即可，不需要关注什么样的任务如何

处理。（给出任务和处理方法，按照给出的方法处理给出的任务）

实现线程池 + 任务节点。

```cpp
typedef void (*handler_t)(int data);	//定义函数指针的类型

//任务类
class ThreadTask
{
    int _data;	//要处理的数据
    handler_t _handler;		//处理数据的方法
public:
    void Run()
    {
        return _handler(_data);
    }
}
//线程池中的线程获取到任务节点只需要调用Run
```

```cpp
//线程池类
class Threadpool
{
	int _thr_num;		//线程的数量
    BlockQueue _queue;	//线程安全的任务队列

	void* thr_entry(void* arg)
    {
        ThreadTask data;
        _queue.pop(&data);
        data.Run();
    }

public:
	//线程池中的线程都是消费者
    Init();	
    TaskPush(ThreadTask &task);	//任务入队
}
```



```cpp
//文件名：threadpool.cpp
#include <iostream>
#include <queue>
#include <pthread.h>
#include <unistd.h>

#define MAX_QUEUE   10  //队列节点的最大数量
#define MAX_THREAD  5   //线程的最大数量

typedef void (*handler_t)(int data);

//任务节点类：处理的数据 + 处理的方法
class ThreadTask
{
private:
    int _data;      //要处理的数据
    handler_t _handler;     //回调函数，任务的处理方法
    
public:
    ThreadTask()
    {

    }

    ThreadTask(int data, handler_t handler)
        :_data(data)
        ,_handler(handler)
    {

    }

    //设置任务
    void SetTask(int data, handler_t handler)
    {
        _data = data;
        _handler = handler;
    }

    void Run()
    {
        return _handler(_data);
    }
};

class BlockQueue
{
private:
    int _capacity;      //容量
    std::queue<ThreadTask> _queue;
    pthread_mutex_t _mutex;
    pthread_cond_t _cond_pro;   //生产者
    pthread_cond_t _cond_cus;   //消费者
public:
    BlockQueue(int cap = MAX_QUEUE)
        :_capacity(cap)
    {
        pthread_mutex_init(&_mutex, NULL);
        pthread_cond_init(&_cond_pro, NULL);
        pthread_cond_init(&_cond_cus, NULL);
    }

    ~BlockQueue()
    {
        pthread_mutex_destroy(&_mutex);
        pthread_cond_destroy(&_cond_pro);
        pthread_cond_destroy(&_cond_cus);
    }

    bool Push(ThreadTask &data)
    {
        //加锁
        pthread_mutex_lock(&_mutex);
        while(_queue.size() == _capacity)
        {
            //线程等待  生产者阻塞
            pthread_cond_wait(&_cond_pro, &_mutex);
        }

        _queue.push(data);
        //唤醒线程
        pthread_cond_signal(&_cond_cus);
        //解锁
        pthread_mutex_unlock(&_mutex);
        return true;
    }

    bool Pop(ThreadTask* data)
    {
        pthread_mutex_lock(&_mutex);
        while(_queue.empty())
        {
            pthread_cond_wait(&_cond_cus, &_mutex);
            //解释pthread_cond_wait
            //pthread_mutex_ublock()
            //pause()
            //上面的两步是原子操作，不能被打断
            //pthread_mutex_lock()
        }
        *data = _queue.front();
        _queue.pop();
        pthread_cond_signal(&_cond_pro);
        pthread_mutex_unlock(&_mutex);
        return true;
    }
};

//线程池类
class ThreadPool
{
public:
    ThreadPool(int tnum = MAX_THREAD, int qnum = MAX_QUEUE)
        :_thread_num(tnum)
        ,_queue(qnum)
    {
        
    }

    bool Init()
    {
        int ret;
        pthread_t tid;
        for(int i = 0; i < _thread_num; i++)
        {
            ret = pthread_create(&tid, NULL, thr_entry, (void*)this);
        }

        if(ret != 0)
        {
            std::cout << "thread create error\n";
            return false;
        }
        return true;
    }

    bool Push(ThreadTask &task)
    {
        _queue.Push(task);
        return true;
    }

private:
    int _thread_num;
    BlockQueue _queue;      //安全队列

    //静态成员函数没有this指针，共享这个线程入口函数
    static void* thr_entry(void* arg)
    {
        ThreadPool* p = (ThreadPool*)arg;
        while(1)
        {
            ThreadTask task;
            p->_queue.Pop(&task);
            task.Run();
        }
        return NULL;
    }
};

void test(int data)
{
    printf("i am thr:%ld-get data:%d, will sleep:%d s\n", pthread_self(), data, data % 5);
    sleep(data % 5);
}

int main()
{
    ThreadPool pool;
    pool.Init();


    for(int i = 0; i < 10; ++i)
    {
        ThreadTask task(i, test);
        pool.Push(task);
    }
    
    //不让线程池退出
    while(1)
        sleep(1);
    return 0;
}
```

运行结果：

![image-20230913031632176](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230913031632176.png)



## 7.2线程安全的单例模式

单例模式：非常典型的一种设计模式。

应用场景：一个类只能实例化一个对象，一份资源只能被加载一次，并且向外提供一个统一的接口访问。（比如：任务管理器，一个操作系统只有一个任务管理

器）

实现：

恶汉方式：资源在程序程序初始化阶段就完成加载，以空间换时间。（在高性能程序中是典型的用法）

1.静态修饰资源：保证资源只有1份，并且在程序初始化阶段完成初始化加载。

2.构造函数私有化：实现一个类只能实例化一个对象。

注意：恶汉方式不涉及线程安全问题，但依然需要考虑一个问题，当我们在初始化资源的时候，这个资源涉及到其他资源的访问，意味着在程序初始化阶段，初始化资源的时候依赖的资源没有被初始化就出问题，定义的时候主义问题。

```cpp
template <class T>
class Singleton
{
private:
    static T _data;
    Singleton(){}

public:
	T* GetInstance()
    {
        return &_data;
    }
};
```



懒汉方式：资源在使用的时候再去加载，延迟加载，第一次使用慢，第一次启动慢。（重点）

1.定义对象指针；

2.static修饰；

3.volatile修饰；

4.加锁保护，线程安全；

5.二次检测，提高效率；

6.构造函数私有化。

```cpp
template <class T>
class Singleton
{
private:
    volation static T* _data;
    static std::mutex _mutex;
    Singleton(){}
    
public:
    volation static T* GetInstance()
    {
        //二次检测	double cleck
        if(_data == NULL)
        {
        	_mutex.lock();
        	if(_data == NULL)
        	{
            	_data = new T();
        	}
        	_mutex.unlock();
        }
        return _data;
    }
}
```



## 7.3关于智能指针与STL容器线程安全讨论

STL中的容器都是非线程安全的。

智能指针：都是线程安全的或者说不涉及线程安全问题。（局部使用的或者是原子操作的，是不涉及线程安全问题）



# 9.总结

概念：

线程是什么？ 

线程概念：执行流、轻量级进程、cpu调度的基本单元、共享进程的大部分资源。

以前学习线程的时候，进程就是pcb，在linux中是一个task_struct结构体，它是操作系统对程序运行的动态描述，通过这个描述操作系统实现对程序运行的调度以

及管理。

在学习线程这里，线程就是cpu调度的基本单元，是进程中的一条执行流，在linux中实现线程的时候是通过进程pcb实现的，并且一个进程中可以有多个线程

（pcb），这些pcb共用进程中的大部分资源，相较于传统的pcb较为轻量化，因此进程也被称作为轻量级进程。



进程和线程的区别：

有了线程，进程成为了一个比较宽泛的概念。

进程是系统进行资源分配的基本单元。

线程是系统进行运行调度的基本单元。



线程间的独有与共享：

独有与共享，对于程序运行的影响。

独有：标识符、栈、寄存器、信号屏蔽字、errno等

共享：虚拟地址内存、文件描述信息表、信号处理方式、工作路径等



多执行流进行多任务处理，多进程与多线程。

多进程与多线程进行多任务处理的优缺点：

多线程优点：

1.线程间通信更加灵活；

2.线程的创建与销毁成本更低；

3.线程间的切换调度成本更低；

多进程优点：

1.健壮性、稳定性高；（应用于主程序安全性要求高的场景，比如shell和服务器，其余的用多线程）

 多任务处理中，并不是执行流越多越好，因为pcb资源是固定的，因此执行流多了反而会增加切换调度成本。



线程控制：创建、退出、等待、分离

线程控制的接口操作都是库函数的操作。

1.线程创建：

```c
int pthread_create(pthread_t* tid, pthread_attr* attr,  void* (*thread_routine)(void*), void* arg);
```

tid：用于获取线程id，线程独有空间的首地址，是用户态线程的操作句柄。

attr：线程的属性，一般不用设置，都是置空的。

第三个参数：是函数指针，线程的入口函数，函数运行完了线程也就退出了。

arg：是传给第三个参数的参数。（注意点：要小于8字节）

返回值：成功返回0，失败返回非0值。（库函数，系统调用函数一般是成功返回1，失败返回0）



tid是线程的操作句柄，实际上是线程在虚拟地址空间中自己所相对独有的一块空间的首地址。

pthread_t pthread_self(void);	返回调用线程的线程id

命令操作：ps -L选项，查看轻量级进程信息。



2.线程退出：

三种退出方式：

2.1线程入口函数中return；（但是主线程main函数中return退出的是进程，进程退出了，进程下的所有线程都会退出。）

2.2void pthread_exit(void*retval);	在任意位置退出调用线程

2.3int pthread_cancel(pthread_t tid);	取消一个运行中的线程（在任意一个进程中都可以通过tid退出）	tid是线程id

 

3.线程等待：

等待线程退出，获取返回值释放资源。

处于joinable状态的线程退出后不会自动释放资源。

int pthread_join(pthread_t thread, void **retval);



4.线程分离：

设置线程的分离属性为detach状态，退出后自动释放资源。

int pthread_detach(pthread_t thread);



线程安全：

概念：多线程对临界资源的访问操作是安全的。

实现：同步与互斥。

互斥：通过对临界资源同一时间的唯一访问保证访问安全。

同步：通过条件判断让线程对临界资源访问更加合理。

互斥的实现：互斥锁。

互斥锁：本质就是一个0和1的计数器，标记临界资源的两种访问状态。

访问资源之前加锁：通过计数器判断是否可访问，不可访问则阻塞。

访问资源完毕解锁：通过计数器将资源标记为可访问，唤醒阻塞。

互斥锁本身也是临界资源，凡是互斥锁自身通过原子操作保证自身安全。

操作流程：

1.定义互斥锁；						pthread_mutex_t

2.初始化互斥锁；					pthread_mutex_init();

3.访问临界资源之前加锁；	 pthread_mutex_lock/trylock();

4.访问临界资源完后解锁；	 pthread_mutex_unlock();

5.销毁互斥锁释放资源；		 pthread_mutex_destroy();



死锁：程序流程无法继续推进卡死的情况。

产生：4个必要条件。

1.互斥条件。

2.不可剥夺条件。

3.请求与保持条件。

4.环路等待条件。

预防：破坏死锁产生的必要条件。

1.保证加解锁顺序一致；

2.若请求不到新的锁，则把已有的释放。

算法：银行家算法。



同步的实现：通过条件判断让线程对资源获取更加合理，条件变量。

条件变量：pcb等待队列 + 使线程阻塞以及唤醒线程的接口。

当前线程对临界资源访问不合理的，则调用阻塞接口阻塞线程。

若其他线程促使当前线程对资源获取合理，则调用唤醒接口。

但是需要注意的是：条件变量本身并不确定资源什么时候获取合理，因此资源是否获取合理需要程序员自行判断。

操作流程：

1.定义条件变量；										pthread_cond_t

2.初始化条件变量；									 pthread_cond_init();

3.若资源获取不合理则调用阻塞接口；	  pthread_cond_wait();		pthread_cond_timedwait();

4.若促使资源获取合理则唤醒阻塞；		  pthread_cond_signal();	 pthread_cond_broadcast();

5.销毁条件变量。										 pthread_cond_destroy();

注意：条件变量需要搭配互斥锁一起使用。

因此资源是其他线程促使条件满足，其中的条件是否满足也是临界资源的判断。因此需要加锁保护。



生产者与消费者模型：典型设计模式。

设计模式：大佬们针对典型的应用场景设计的解决方案。

应用场景：大量的数据的产生以及处理的场景。

![image-20230912210942966](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230912210942966.png)

优点：解耦合、支持忙闲不均、支持并发

实现：两种角色的线程 + 线程安全的任务队列。

线程安全的任务队列：阻塞队列-BlockQueue。



信号量：

本质：计数器。

作用：用于实现进程或线程间的同步与互斥。

操作：

P操作：计数-1，若计数<0阻塞执行流。

V操作：计数+1，唤醒一个阻塞的执行流。

同步的实现：通过计数器对资源进行计数。

线程获取资源之前进行P操作，其他线程产生资源之后进行V操作。

互斥的实现：计数器初始化为1.

线程访问资源之前进行P操作，访问资源完毕之后进行V操作。

接口认识：

定义信号量：sem_t.

初始化信号量：sem_init(sem_t*, int pshared, int val);

P操作：sem_wait(sem_t*);		sem_trywait();		sme_timedwait();

V操作：sem_post(sem_t*);

销毁信号量：sem_destroy(sem_t*);

信号量与条件变量实现同步的不同之处：

1.条件变量需要程序员自己进行条件判断，信号量通过自身计数判断。

2.条件变量需要搭配互斥锁一起使用，信号量不需要。

锁：互斥锁，信号量，条件变量。

读者写者模型：读共享写互斥的场景。

读写锁	自旋锁

乐观锁（CAS锁）、悲观锁、可重入锁、不可重入锁。

线程池：一个线程安全的任务队列 + 提前创建好最大数量上线的工作线程。

针对大量的数据请求进行处理的场景。

管理线程将任务数据进行入队，抛入线程池，线程池中的工作线程不断的从任务队列中获取任务数据进行处理。

好处：

1.避免大量线程频繁创建与销毁带来的时间成本。

2.任务节点以及线程有上限，避免资源耗尽的风险。

核心线程将需要处理的数据，以及当前数据的处理组织成为一个任务，抛入线程池，线程池中的工作线程只需要取出一个任务节点，通过节点中的方法处理节点中

的数据。

ThreadTask{要处理的数据;	数据的处理方法;};

ThreadPool{创建线程;	创建线程安全的任务队列;};

```cpp
//任务类
typedef void (*handler_t)(int data);
class ThreadTask
{
private:
	int _data;
    handler_t _handler;

public:
	ThreadTask(int data, handler_t handler);
    void Run(){_hnadler(_data);}
}
```

```cpp
//线程池类
class ThreadPool
{
    int _max_thread;
    int _max_queue;
    BlockQueue _queue;

public:
    ThreadPool(int que,int thr);
    bool Init();
};
```



线程池：线程的池子。

在大量任务需要处理的场景中，使用线程池。

1.避免大量线程的频繁创建与销毁带来的时间成本。

2.避免了资源耗尽，系统崩溃的风险。

组成：1.大量但是有上限的线程；	2.线程安全的任务队列；

STL容器的线程安全问题：非线程安全。

智能指针的线程安全问题：不需要我们过多考虑线程安全问题。

线程安全的单例模式：典型的设计模式。

应用/场景：一个类只能实例化一个对象/一个资源在内存中只能有一份。

主要目的就是为了避免产生数据混淆。

实现：资源只有1份，提供一个接口访问。

1.恶汉方式：对象在程序初始化阶段完成实例化。

资源静态化：static；	以空间换时间。

2.懒汉方式：对象在使用的时候再进行实例化。

延迟加载，初始化速度快，占用资源少。

1.资源定义静态指针，用的时候再进行实例化申请。

2.实例化申请过程需要加锁保护。

3.二次检测，减少锁冲突概率。

4.volatile关键字修饰防止编译器过度优化。

```cpp
template <class T>
class Singletion
{
private:
	volatile static T* data;
	static std::mutex mutex;
    
public:
    static T* Getinstance()
    {
        //二次检测
        {
        	mutex.lock();
        	if(data == NULL)
        	{
            	data = new T();
        	}
        	mutex.unlock();
        }
        return data;
    }
}
```





多线程：

线程概念：1.线程是什么？	2.线程的独有与共享；	3.多任务多执行流处理；

线程控制：概念、创建、退出、等待、分离；

线程安全：

概念，线程安全是什么？	实现；	同步与互斥的概念

互斥的实现-互斥锁：互斥锁实现互斥的原理+死锁（概念+产生+预防+避免）

同步的实现-条件变量：提供pcb等待队列+使线程阻塞以及唤醒线程的接口。

互斥锁的原理	使用流程

死锁，产生的必要条件、预防与避免

pthread_cond_t

pthread_cond_init

pthread_cond_wait		pthread_cond_timedwait

pthread_cond_signal	pthread_cond_broadcast

pthread_cond_destroy

注意：

1.条件变量的使用需要搭配互斥锁一起进行；

2.pthread_cond_wait包含了解锁（原子操作）、休眠（原子操作），被唤醒后加锁三步操作；

3.对于获取资源是否满足的条件判断应该使用循环进行；

4.多种角色的线程应该使用多个条件变量，分开等待，分开唤醒。

信号量的基本使用、流程与原理；

生产者与消费者模型：应用场景、优点、实现；

线程的应用：线程池的基本实现与使用、线程安全的单例模式。

**手撕代码：1.生产者与消费者模型；2.线程安全的单例模式。**




# 10.面试题

线程间通信

什么是线程同步

如何做到线程同步

手撕代码，两个线程交叉打印数据

多线程开发

进程与线程的通信方式

进程和线程的区别

Socket阻塞和非阻塞

解释滑动窗口

线程的调度

多线程编程

了解c++11标准的多线程，简单描述下互斥量之类。

多进程和多线程

多线程问题，引申到一个具体的问题，问如何解决

线程上下文包括什么

线程的栈是如何创建的，如果一个进程有100个线程，那么这个进程占多大的物理空间

智能指针如何线程安全

为什么用线程池，如何用

项目中的进程间通信中间件

多线程如何实现互斥，和其他的进程间通信相比有什么优势等

线程同步的方式

给出具体场景，判断使用的是多线程还是多进程

go是多线程还是多进程

多线程编译需要注意什么

多线程的死锁是什么情况，如何解决

线程池中的线程异常或者死循环了，该如何解决

进程和线程有什么区别，线程有哪些独立的资源

线程的状态有哪些

有没有写过线程池，如何实现一个高性能线程池，你能想到哪些方面

进程线程协程懂吗

如何产生一个进程，子进程和父进程的内存空间

