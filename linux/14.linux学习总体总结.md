# 1.基础指令

## 1.1linux下你都用过哪些指令？

答：

目录：ls、pwd、mkdir、rm、cp、mv、cd

文件：touch、cat、more、less、head、tail

压缩：zip/unzip、gzip/gunzip、bzip2/bunzip2、tar

查找：grep、find

权限：权限的表示（rwxrwxrwx、0777）、umask、chmod、chown、chgrp、su、sudo

环境变量：nev、set、echo、export、unset

进程：ps、kill

进程间通信：ipcs、ipcrm

系统资源：top、df、free

网络：netstat、ifconfig

其他：man、重定向、管道

重要的：目录、文件、压缩、查找、进程、网络。



## 1.2应该了解的知识

隐藏文件

目录结构

绝对路径与相对路径

权限的认识



# 2.常用工具

## 2.1yum

yum list

yum search

yum install

yum remove



## 2.2vim

常见问题：vim常见操作有哪些？

总结：

模式切换：

普通到插入：iao

其他到普通：ESC

底行操作：:w、:q、:wq、:q!

普通操作：

光标移动：hjkl、wb、ctrl+f/b、gg/G

文本操作：nyy、ndd、p、x、dw

其它操作：u、ctrl+r、ctrl+s（暂时中断/不显示与sh服务的通信）、ctrl+q（解决ctrl+s的操作）



## 2.3gcc/g++

编译过程：预处理、编译、汇编、链接。



### 2.3.1链接

功能：

分裂：

动态链接：

静态链接：



## 2.4gdb

常见问题：

1.你都用过哪些调试指令？

2.如何打断点？

3.使用gdb对程序进行调试的过程。



变态面试题：

1.gdb的原理？

2.gdb打断点的原理？



总结：

调试前提：gcc -g生成debug程序。

调试指令：

开始：run、start

逐步：step、next、until、continue、list

断点：break、info break、delete、watch

内存：print、backtrace



## 2.5make/Makefile

makefile编写规则：

目标对象：依赖对象1

​	命令

依赖对象1：依赖对象2

​	命令

.PHONY:clean

伪对象：无论如何都要生成的对象。

预定义变量：$@、$^、$<



make的解释执行规则：找到第一个目标对象进行生成，为了生成会优先找到依赖对象 的生成规则，先生成依赖对象。



## 2.6git

git的常见操作有哪些？

总结：git clone、git add、git commit、git push。

再看的话去看下分支管理。



# 2.系统编程阶段

## 2.1进程概念

### 2.1.1冯诺依曼体系结构（了解）

所有的设备都是围绕内存工作的。



### 2.1.2操作系统定位（了解）

管理：先描述再组织。

系统调用接口：内核向上提供的用于方位内核特定功能的接口。

库函数：针对特定场景的功能对系统调用接口封装。



### 2.1.3进程概念

重点问题：进程和线程的区别？

进程概念：进程就是一个运行中的程序，在操作系统角度进行是一个进程控制块pcb，在linux下是一个task_struct结构体，这是操作系统对程序动态运行的描述。

通过这个描述操作系统可以实现对程序运行的调度以及管理。



通过哪些描述进行调度以及管理的？

描述：

内存指针：通过内存指针操作系统在调度程序运行的时候能够找到程序在内存中的位置。

上下文数据、程序计数器：保存了程序在运行、切换调度过程中cpu上正在运行的数据以及即将要执行的指令，以便于切换回来的时候能够知道从哪里继续运行。

标识符：能够唯一标识每一个进程，在操作系统中能够找到它。

进程状态：当前进程是否能够给操作系统进行调度，如何调度更好。

IO信息：

信号：



### 2.1.4进程状态

linux下的进程状态：运行、可中断休眠、不可中断休眠、死亡、停止、僵尸。



僵尸进程面试的时候问的很多，因为僵尸进程会影响到代码的质量。

僵尸进程概念：已经退出了，但是资源没有被完全释放的进程。

僵尸进程产生的原因：子进程先于父进程退出，子进程成为僵尸进程，保存退出返回值。

僵尸进程的危害：资源泄漏。

僵尸进程如何避免：进程等待。

进程等待的概念：等待子进程退出，获取返回值，释放资源。



孤儿进程的概念：父进程退出后，子进程成为孤儿进程。

孤儿进程特性：运行在后台，父进程成为1号进程。



守护进程概念：特殊的孤儿进程，脱离与终端和登录会话的关系，不受外界影响运行在后台的进程。

了解一下守护进程如何实现，可以不会实现，但要知道如何实现，防止面试问到。



### 2.1.5环境变量（了解）

概念：保存程序运行环境参数的变量。

特性：父子进程之间的传递特性。

作用：

1.便于程序运行环境的配置。

2.用于进程间的通信。

操作：

1.命令操作：export。

2.代码操作：

​	2.1getenv();

​	2.2main函数第三个参数。

​	2.3extern char** environ;



### 2.1.6程序地址空间

典型问题：

1.虚拟地址空间是什么？

2.虚拟地址空间的布局？

3.虚拟地址如何找到物理地址？（分页式）



程序地址空间概念本质：

程序地址空间就是操作系统为进程描述的一个虚拟的地址空间，在linux下是通过mum_struct描述符。因为操作系统通过虚拟地址空间，可以让每个进程都拥有一

个完整的、连续的内存地址空间使用，并且虚拟地址通过页表映射之后，可以实现数据在物理内存上的离散式存储，提高了内存利用率，并且可以通过页表进行内

存安全访问控制。



内存管理方式：

1.分段式：

2.分页式：

将内存空间分页管理，分割成为一个个的小内存页，经过页表映射可以找到物理地址。

虚拟地址组成：页号 + 页内偏移。

页表：页号、物理块地址、缺页中断位、权限位...

3.段页式：



缺页中断：

内存置换：（尤其是最久未使用算法/LRU）



## 2.2进程控制

### 2.2.1创建

第一种创建方式：

pid_t fork();

父子进程代码共享，数据独有。

子进程创建流程。	写时拷贝及数



第二种创建方式：（实际使用的时候一般不会使用，面试的时候可能会问）

pid_t vfork();

创建子进程，并阻塞父进程。

父子进程公用同一个虚拟地址空间。



### 2.2.2退出

退出方式：

1.main函数中return。

2.库函数使用exit，退出前刷新缓冲区。

3.系统调用使用_exit，退出时直接释放资源，并不会刷新缓冲区。



退出场景：

1.正常退出。

2.异常退出。



### 2.2.3等待

概念：父进程等待子进程退出，获取退出子进程返回值，释放资源，避免产生僵尸进程。

操作：

int wait(int* status);

int waitpid(int pid,int* status,int options);

返回值：

1.子进程的退出返回值	低16位的高8位存储退出返回值	使用宏WEXITSTATUS(status)

2.子进程的异常退出返回值	低7位	信号值为0则表示正常退出	使用宏WIFEXITED(status)



### 2.2.4替换

概念：替换一个进程正在调度运行的程序。

加载一个新的程序到内存中，更新当前进程的页表以及虚拟地址空间指向新的程序在内存中的位置。

操作：

int execl(char* path, char* arg, ... , NULL);

int execlp(char* file, char* arg, ... , NULL);

int execle(char* path, char* arg, ... , NULL, char* env[]);

int execv(char* path, char* argv[]);

int execvp(char* file, char* argv[]);

int execve(char* path, char* argv[], char* env[]);



minishell:

1.捕捉键盘输入。

2.解析输入信息。（命令名称，运行参数）

3.创建子进程。

4.在子进程中进行程序替换，替换失败则退出。

5.父进程等待子进程退出。



## 2.3基础IO

### 2.3.1回顾标准库IO接口

fopen、fwrite、fread、fseek、fclose



### 2.3.2学习系统调用IO接口

open、write、read、lseek、close



### 2.3.3文件描述符

本质：内核中进程打开的文件描述信息数组下标。



重定向的原理：通过改变文件描述符这个下标对应位置的文件描述信息，进而改变所操作的文件，改变数据的流向。

int dup2(int oldfd,int newfd);



文件描述符与文件流指针：

文件流指针是一个结构体指针：FILE*，其中包含一个成员变量就是文件描述符。

文件流指针中不仅包含文件描述符，并且包含了我们所说的缓冲区。

在minishell中加入重定向的实现。



### 2.3.4文件系统

文件系统包含要素：超级块、inode_bitmap、data_bitmap、inode表、data块。



软链接与硬链接：

通过创建一个软链接或硬链接文件来访问源文件。

区别：

1.软链接文件是独立的文件，有自己独立的inode。

2.硬链接与源文件没有区别，只是文件的一个目录项，与源文件共用同一个inode。



### 2.3.5动态库与静态库的生成与使用

生成：

1.将各个原码生成机器指令：gcc -fPIC -c testlib.c -o testlib.o

2.将所有机器指令打包生成库：

动态库：gcc --shared testlib.o ... -o libtestlib.so

静态库：ar -cr libtestlib.a testlib.o ...



使用：

链接时使用：

1.库文件必须放置在指定路径下	/usr/lib64

2.设置环境变量	LIBRARY_PATH

3.使用gcc -L选项指定库文件所在目录

4.gcc main.c -o main -L./lib -ltestlib



运行时使用：

1.库文件必须放置在指定路径下	/usr/lib64

2.设置环境变量	LD_LIBRARY_PATH



## 2.4进程间通信

操作系统为进程之间通信所提供的几种通信方式。

因为每个进程都有自己的虚拟地址空间，访问的都是自己的虚拟地址，保持独立性，因此无法与其他进程进行直接通信。



### 2.4.1管道

本质：内核中的一块缓冲区。

分类：

1.匿名管道：只能用于具有亲缘关系的进程间通信。

2.命名管道：用于同一主机上任意进程间通信。

操作：

int  pipe(int pipefd[2]);

int mkfifo(char* path,int mode);

特性：

1.半双工通信。

2.提供字节流服务：

所有写段被关闭，read不再阻塞，读完数据后返回0。

所有读端被关闭，则write会触发异常。

3.自带同步与互斥：

互斥：管道写入操作大小不超过PIPE_BUF大小则保证操作原子性。

同步：管道数据满了，则write阻塞，管道没有数据则read阻塞。

4.生命周期随进程。



### 2.4.2共享内存

本质：

1.一块共享的物理内存。

2.在物理内存上开辟一块空间，让多个进程都能够映射到自己的虚拟地址空间进行访问，实现数据共享。

操作：shmget、shmat、shmdt、shmctl。

特性：

1.最快的进程间通信方式。

2.生命周期随内核。

注意：

1.通过信号量实现安全访问。

2.对共享内存的操作需要注意安全问题。



### 2.4.3消息队列

本质：

1.内核中的一个优先级队列。

2.多个进程访问同一个队列，通过节点的添加与获取实现通信。

特性：

1.自带同步与互斥。

2.生命周期随内核。



### 2.4.4信号量

本质：

1.内核中的一个计数器。

2.多个进程通过访问同一个信号量的计数器，实现多进程对临界资源访问的同步与互斥。

特性：生命周期随内核。

互斥：通过计数保持最多一个表示资源最多只有一份，则同一时间只有一个进程能够访问。

同步：通过计数判断当前是否有有资源可被访问，没有则阻塞，实现资源访问获取的合理性。



### 2.4.5套接字（网络讲）



## 2.5进程信号

概念：

信号跟信号量不是同一个点，不要把这两个混为一谈。

信号是一种中断，这里所说的是软件中断，打断进程当前操作，通知进程发生了某个事件，去处理事件。



### 2.5.1产生

1硬件：ctlr+c/z/l

2软件：kill、raise、abort、alarm



### 2.5.2注册

在进程pcb中标记信号的到来+位图+链表。

信号分为可靠信号和不可靠信号。

可靠信号：修改位图添加节点。

不可靠信号：没有注册则注册，已经注册则什么都不做。



### 2.5.3注销

在处理之前消除痕迹，删除节点，修改位图。

可靠信号：删除节点之后，没有相同节点则位图置0。

不可靠信号：删除节点位图置0。



### 2.5.4处理

回调信号的处理函数。

signal函数修改信号的处理方式，有SIG_DFL叫做默认处理方式和SIG_IGN叫做忽略处理方式。

处理方式有三种，分别是默认、忽略、自定义。



### 2.5.5阻塞

暂时阻止信号被处理，但是信号依然会注册。

在pcb中有个阻塞位图，阻塞指定信号就是修改对应位置为1。

信号阻塞使用sigprocmask，也可以用这个函数解除阻塞

不是所有的信号都能被阻塞的，特殊信号不能被阻塞，也不能被忽略，也不能被自定义，有两个，分别是SIGKILL/SIGSTOP。



kill命令的原理：给进程发送一个终止信号来终止进程。



### 2.5.6函数的可重入与不可重入

重入：在多执行流中进入同一个函数同时执行。

可重入：重入之后不会出问题。

不可重入：重入之后有可能会造成数据二义或逻辑混乱。

基准：函数内部是否对全局函数进行了不受保护的非原子操作。



### 2.5.7volatile关键字

修饰变量，保持变量内存可见性，每次访问都从内存重新获取最新数据。

防止编译器过度优化。



数据类型关键字的作用：对内存进行解释，有多大的空间，内存格式是什么。



### 2.5.8信号的一些简单应用

SIGCHLD

SIGPIPE



## 2.6多线程

### 2.6.1线程概念

概念：线程是进程中的一条执行流，在linux下线程是通过task_struct结构体（pcb）实现的，并且同一个进程中可以有多个线程，它们共用进程中的大部分资源，

因此也被称作轻量级进程。

与进程的讨论：

进程是系统中资源分配的基本单元，线程是系统中调度运行的基本单元。



多线程的优缺点：（与多进程相比）

优点：

1.多线程之间通信更加灵活。

2.线程的创建与销毁成本更低。

3.线程间的切换调度成本更低。

缺点：

1.线程的健壮性不如多进程。



线程间的独有与共享：

独有：标识符、栈、寄存器、errno、信号屏蔽字、...

共享：虚拟地址空间、IO信息、信号处理方式、...



### 2.6.2线程控制

1.创建：pthread_create。

2.退出：

方式1：入口函数return。

方式2：pthread_exit。

方式3：pthread_cancel。

3.等待：pthread_join。

线程有一个分离属性，默认是joinable，这个状态的线程退出后需要被等待，不会自动释放资源。

4.分离：pthread_detach。

将线程的分离属性设置为detach属性，这个属性的线程退出后自动释放资源，不需要被等待。

何时使用分离：不关心返回值。



### 2.6.3线程安全

概念：主要描述的是在线程中对临界资源的操作是安全的。



实现：

1.互斥：

通过同一时间的唯一访问实现互斥操作。保证操作安全性。

互斥锁的原理：互斥锁本身就是一个原子操作的0/1计数器，对临界资源访问之前-1加锁，访问完毕之后+1解锁，为0则阻塞实现互斥访问。

互斥锁的操作：

互斥锁类型：pthread_mutex_t

互斥锁的初始化：pthread_mutex_init

加锁：pthread_mutex_lock

解锁：pthread_mutex_unlock

销毁互斥锁：pthread_mutex_destory



死锁：

死锁的概念：程序因为资源争抢而导致流程无法继续推进被称之为死锁。

死锁的产生：对锁资源的争抢不当。（加锁顺序不一致，除了这个还有很多。）

死锁产生的四个必要条件：1.互斥条件；	2.不可剥夺条件；	3.请求与保持条件；	4.环路等待条件。

死锁的预防：破坏必要条件的产生

1.加锁顺序保持一致；

2.采用非阻塞加锁。

死锁的避免：银行家算法。



2.同步：

通过条件判断，实现线程对资源获取的有序性合理性。



条件变量：

本质：

1.提供了pcb等待队列 + 阻塞和唤醒线程的接口。

2.用户基于资源条件判断实现在合适的时候阻塞线程，合适的时候唤醒线程，实现资源获取的有序合理性。

操作：

类型：pthread_cond_t

初始化：pthread_cond_init

等待：pthread_cond_wait

唤醒：pthread_cond_signal

销毁：pthread_cond_destroy



信号量：

本质：

1.内核中的一个计数器。

2.多个进程通过访问同一个信号量的计数器，实现多进程对临界资源访问的同步与互斥。

特性：生命周期随内核。

互斥：通过计数保持最多一个表示资源最多只有一份，则同一时间只有一个进程能够访问。

同步：通过计数判断当前是否有有资源可被访问，没有则阻塞，实现资源访问获取的合理性。

操作：

类型：sem_t

初始化：sme_init

等待（p操作）：sem_wait

v操作：sem_post

销毁：sem_destroy



### 2.5.4基本应用

1.生产者与消费者模型（面试中linux下最容易手撕代码的，但相比较还是算法手撕的概率比较大。）

生产者与消费者模型是典型的设计模式。

针对大量数据产生以及处理的场景。

将产生与处理分离开通过线程安全的队列实现数据交互。

优点：

1.代码模块，解耦合。

2.支持并发操作。

3.支持忙闲不均。

实现：

1.对应角色的线程的创建。

2.线程安全的队列实现。



2.线程池：

概念：一个或多个线程 + 线程安全的任务队列。

外界将需要处理的任务加入线程池的任务队列。线程池中的线程充当一个工人从任务队列中取出任务进行处理。

场景：针对大量请求进行并发处理的场景。

创建有最大数量限制的线程的池子，其中的线程不断的循环对大量请求进行处理，提高处理效率。

优点：

1.节省了线程的创建与销毁的时间成本。

2.避免了峰值压力下资源耗尽的风险。（线程池中线程以及任务节点的数量上限避免了资源耗尽风险。）

实现：线程安全的任务队列 + 最大数量限制的处理线程。



3.线程安全的单例模式：（面试写代码的概率挺高）

单例模式是典型的设计模式。

一个类只能有一个实例化的对象，资源在内存中只能被加载一份。

实现：有两种方式

第一种方式：饿汉

资源提前初始化，用的时候通过统一接口直接访问。

实现：使用静态资源static，提供统一访问接口，构造函数私有化。

思想：

1.以空间换时间的思想。

2.初始化阶段将资源全部初始化完毕，使用的时候直接使用。

懒汉：

思想：

1.资源在使用的时候再进行初始化加载，通过统一接口进行访问。

2.延迟加载，节省空间（占用资源少），初始化速度快，一次加载后也可以直接访问，

3.存在线程安全的问题。

实现：

1.使用指针定义资源。

2.使用static静态修饰。（静态资源类外初始化）

3.指针使用volatile修饰。（防止编译器过度优化）

4.加锁保护保证线程安全。

5.二次检测，减少锁冲突提高效率。

6.提供统一的接口进行访问（包含初始化过程）。

7.构造函数私有化。

懒汉缺陷：存在线程安全的问题。



4.读者与写者模型

读共享，写互斥的场景。

优势：在大量读取，少量修改的场景中，避免互斥串行化所导致的性能下降。

实现：读写锁、自旋锁。（读写锁就是通过自旋锁实现的）

在读写锁默认是读者优先。可以设置为写者优先。



锁的种类：互斥锁、自旋锁、读写锁、乐观锁（CAS锁的实现）、悲观锁、可重入锁、不可重入锁。



# 3网络

## 3.1网络通信要素

### 3.1.1IP地址

概念：uint32_t类型的整数。

作用：在网络中唯一标识一台主机。

网络中的每条数据都包含源端-对端IP地址。



### 3.1.2端口

概念：uint16_t类型的数据。

作用：在一台主机上标识一个socket。

网络中的每条数据都会包含源端-对端端口。



### 3.1.3协议

概念：网络通信中的数据格式约定。

协议分层：有两种。

第一种：OSI七层模型。

第二种：TCP/IP五层模型（学习使用的）

应用层：负责应用程序之间的数据沟通。	HTTP

传输层：负责进程（套接字）之间的数据传输。	UDP/TCP

网络层：负责地址管理与路由选择。	IP	路由器

链路层：负责相邻设备之间的数据传输。	ETH	交换机

物理层：负责物理光电信号的传输。	ETH	集线器（将信号放大，信号传输的更远，有一定的转发能力）



### 3.1.4网络字节序

字节序：

概念：cpu对内存中数据进行存取的顺序。

分类：

大端：低地址存高位。

小端：低地址存低位。

影响：存储单元大于一个字节的数据类型都会涉及字节序问题。



网络字节序：

概念：网络通信中，通信两端有可能会因为主机字节序不同而导致数据二义。

网络通信的字节序标准：大端字节序。

网络传输中，存储单元大于一个字节的基础类型数据都需要进行字节序转换，转换为网络字节序后进行传输。



## 3.2套接字编程

### 3.2.1udp通信程序的编写

流程：

客户端：

1.创建套接字；

2.发送数据；

3.接收数据；

4.关闭套接字。

服务端：

1.创建套接字；

2.绑定地址信息；

3.接收数据；

4.回复数据；

5.关闭套接字。

接口：

socket/bind/recvfrom/sendto/close

htons/htonl/ntohs/ntohl/inet_addr/inet_ntoa

struct sockaddr/struct sockaddr_in



### 3.2.2tcp通信程序的编写

流程：

客户端：

1.创建套接字；

2.向服务端发起连接；

3.收发数据；

4.关闭套接字。

服务端：

1.创建套接字；

2.绑定地址信息；

3.开始监听；

4.获取新建连接；

5.收发数据；

6.关闭套接字。

接口：（额外涉及到的）

connect/listen/accept/recv/send

listen第二个参数。



## 3.3协议解析

### 3.3.1应用层

自定制协议：通过结构体组织数据格式。

数据组织：分为序列化和反序列化。

序列化：按照指定数据格式组织数据。

反序列化：按照指定数据格式解析数据。



#### 3.3.1.1HTTP

HTTP协议格式：首行、头部、空行（在专业里没有空行这一说的）、正文



首行：

分为请求首行和响应首行。

请求首行：元素有三个，分别是请求方法、URL、协议版本。

请求方法概念：请求方法决定了请求目的。

请求方法有很多，常用的有5种，分别是GET、HEAD、POST、PUT、DELETE.

GET：目的：用于获取实体资源。		特点：没有正文，也可以提交少量数据，而数据在URL中。

HEAD：目的：与GET类似。	特点：请求没有正文，响应中相较于GET来说也是不要正文。（相较于GET来说区别就是响应中不要正文。）

POST：目的：向服务器提交表单数据。	特点：请求中具有正文，正文就是要提交的数据。

PUT：目的：修改资源。	

DELETE：目的：删除资源。



URL：

概念：同一资源定位符。

组成：http://user:pass@ip:port/path?key=val&key=val#ch

重要点：域名与IP、url编码与解码。



协议版本：

0.9：不完善、只有GET方法，只能传输HTML资源。

1.0：规范协议版本，支持更多的请求方法与资源传输格式。

1.1：规范1.0进行性能上的提升：长连接、缓存控制。

2.0：对协议的重新定义。



响应首行：

协议版本：

响应状态码：

1xx：协议切换协商以及一些描述信息。

2xx：请求成功处理。	200

3xx：重定向。资源移动到了新的位置，但是保证原链接依然有效。	301/302

4xx：客户端请求错误。	404

5xx：服务端处理错误。	502/504 

状态码描述：





头部：

概念：针对请求与响应的一些重要描述字段。

格式：key:val\r\nkey:val\r\n

分类：有四个，分别是请求、响应、通用、正文

请求：Referer

响应：Location

通用：Connection

正文：Content-Length、Content-Type





空行：\r\n，作为头部的结尾，间隔头部与正文。





正文：





#### 3.3.1.2DNS

域名：服务器别名。由容易记忆的字符串组成，需要经过域名解析得到服务器IP地址后，才能请求服务器。

域名划分：顶级（使用性质，地域），二级，三级...

域名服务器：根、顶级、二级...

域名解析流程：

1.浏览器缓存；

2.本地host文件；

3.本地域名服务器；

4.根域名服务器；

5.顶级域名服务器。

...



### 3.3.2传输层

#### 3.3.2.1UDP

协议格式：16位源端端口、16位对端端口、16位数据报长度、16位校验和。

协议特性：

1.无连接：通信不需要建立连接，只要知道对方地址就可以发送数据。

2.不可靠：传输不保证数据安全可靠有序的到达对端，丢了就没了 。

3.面向数据报：有最大长度限制整条传输交付的一种传输方式。



编程影响：

1.数据过大则需要在应用层进行分包操作。

2.若分包操作则需要进行包序管理。

3.接收方接收缓冲区必须足够大能够一次获取一整条数据。



#### 3.3.2.2TCP

协议格式：

16位源端端口

16位对端端口

32位序号

32位确认序号

4位报头长度

6位标志位

16位窗口大小

16位校验和

16位紧急指针



协议特性：

1.面向连接：分为连接管理和状态管理和保活机制。

连接管理有三次握手和四次挥手。

三次握手：客户端发送SYN请求；	服务端收到请求后回复SYN+ACK；	客户端收到SYN+ACK，回复ACK。

四次挥手：主动关闭方发送FIN请求；	被动关闭方收到FIN请求后，回复ACK；	被动关闭方发送FIN请求；	主动关闭方收到FIN请求后，回复ACK。

状态管理有三次握手和四次挥手。

三次握手：

客户端：SYN_SENT->ESTABLISHED

服务端：LISTEN:SYN_RCVD->ESTABLISHED

四次挥手：

主动关闭方：FIN_WAIT1->FIN_WAIT2->TIME_WAIT->2MSL->CLOSED

被动关闭方：CLOSE_WAIT->LAST_ACK->CLOSED

保活机制：默认通信双方7200s没有数据通信，则每个75s服务端向客户端发送保活探测数据包，要求进行回复。若连续9次没有得到回复。则认为连接断开。

2.可靠传输：分为可靠传输、避免丢包、和提供性能。

可靠传输：确认应答、超时重传、序号-确认序号、校验和。

避免丢包：分为滑动窗口机制、拥塞窗口机制。

滑动窗口机制：依赖窗口大小字段实现流量控制，防止发送方发送数据过多，导致缓冲区溢出产生丢包。

拥塞窗口机制：以慢启动块增长的形式进行数据传输，避免因为网络状态变差所导致的丢包。

提高性能：分为延迟应答机制、捎带应答机制、快速重传协议、延迟发送机制。

3.面向字节流：

概念：有序的、安全的、基于连接的以字节为最小传输单元大小的传输方式。

特点：传输比较灵活。

缺陷：会存在粘包问题。

本质：tcp并不对缓冲区中的数据进行边界管理。

解决：特殊字符间隔，数据定长，应用头部中定义数据长度。



编程影响：

1.连接断开后，recv返回0，send会触发异常。

2.应用层需要进行数据的边界管理，解决粘包问题。



### 3.3.3网络层

#### 3.3.3.1IP

协议格式：

4位协议版本

4位头部长度

8位服务类型

16位数据报长度

16位分片标识

3位标志

13位分片偏移

8位TTL

8位上层协议

16位校验和

32位源端IP地址

32位对端IP地址



#### 3.3.3.2地址管理

地址管理包括IP地址组成和网段的划分和特殊IP地址和公网与私网。



IP地址组成：包括主机号和网络号

主机号：在网络中标识主机。

网络号：标识一个网络。



网段的划分：分为早起和当前

早起：有A、B、C、D、E

A：组建大型网络	0到127

B：组建中型网络	128.0到191.255

C：组建小型网络	192.0.0到223.255.255

D/E：

当前：采用子网掩码进行网络划分。	更加精细，对IP地址利用率更加充分。

子网掩码：由连续二进制1组成的一个无符号4字节整数。

子网掩码作用：

1.判断一个IP地址所属网络。	IP地址与子网掩码相与可以得到网络号。

2.决定网络中主机号个数。	子网掩码取反得到网络中最大主机号。



特殊IP地址：

0.0.0.0

255.255.255.255

127.0.0.1

主机号全为0

主机号全为1



公网与私网：

公网、外网	互联网

私网、内网	私自组建的内部通信的局域网络。

组建私网的好处：

1.私网中的主机对外通信时将使用同一个对外的公网地址，节省了大量的公网地址的使用。

2.组建私网需要使用NAT/NAPT技术。

组建私网的网络：

1.大型：10.

2.中型：172.16.到172.31

3.小型：192.168



#### 3.3.3.3路由选择

路由器根据路由表中的信息，可以查看到相邻的各个网络信息，然后根据流进路由器的数据的目标地址，逐个与路由表中信息进行对比，判断数据属于哪个网络进

而实现路劲选择。



### 3.3.4链路层

#### 3.3.4.1ETH



#### 3.3.4.2ARP



# 4.IO模型



# 5.多路转接

作用：针对大量描述符进行IO就绪事件监控，让程序能够针对就绪的描述符进行对应事件监控。

避免对没有就绪的描述符进行操作。（提高效率、避免不必要的阻塞。）

## 5.1select

### 5.1.1操作流程

1.定义事件描述符集合，初始化集合，添加需要监控的描述符到集合中。

2.将集合拷贝到内核中进行监控，返回前将集合中没有就绪的描述符移除。（返回一个只包含就绪描述符的集合。）

3.判断哪个描述符还在集合中，通过这种方式确定哪个描述符就绪了哪个事件，进而进行对应操作。



### 5.1.2操作接口

select/FD_ZERO/FD_SET/FD_ISSET/FD_CLR



### 5.1.3优缺点分析

优点：跨平台移植性良好。

缺点：

1.能够监控的描述符数量有最大上限。

2.每次监控都需要向集合中重新添加描述符，拷贝到内核。

3.监控原理采用了轮询遍历，性能会随着描述符的增多而下降。

4.无法直接获取就绪描述符进行操作。



## 5.2poll

### 5.2.1操作流程

1.定义事件结构体数组，在数组的节点中设置需要监控的描述符以及对应事件。

2.将事件结构体数组拷贝到内核进行监控，监控超时或有描述符就绪则监控返回，返回前在对应的描述符事件节点中记录实际就绪的事件。

3.监控返回后，遍历事件结构体数组，通过阶段成员判断哪个描述符就绪了哪个事件，进而进行操作。



### 5.2.2操作接口

poll



### 5.2.3优缺点分析

优点：

1.相较于select流程较为简单；

2.监控的描述符数量没有上限限制；

缺点：

1.每次监控都需要将数组拷贝到内核；

2.监控原理是轮询遍历，性能会随着描述符增多而下降；

3.无法直接获取就绪的描述符以及事件，需要遍历判断；

4.跨平台移植性较差。



## 5.3epoll

### 5.3.1操作流程

1.在内核中创建epoll句柄结构。

2.将需要监控的描述符组织事件结构，添加到内核句柄。

3.开始监控，传入一个事件数组，监控返回前将就绪的事件信息添加到传入的数组中。

4.对数组中就绪的描述符进行对应事件操作即可。



### 5.3.2操作接口

epoll_create/epoll_ctl/epoll_wait



### 5.3.3优缺点分析

优点：

1.监控的描述符数量没有上限。

2.不需要每次向内核拷贝需要监控的信息。

3.监控原理是异步阻塞操作，性能不会随着描述符增多而下降。

4.监控调用返回的都是就绪的事件信息，没有空遍历。

缺点：跨平台移植性差。



epoll比较适用于大量描述符的监控，而在单个描述符的监控或者超时控制上select和poll则更加合适。



多路转接模型适用场景：适用于有大量描述符需要监控但是同一时间只有少量活跃的场景，或者描述符读写超时控制的场景。



