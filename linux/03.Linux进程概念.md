# 1.本节目标

1.认识冯诺依曼系统

2.操作系统概念与定位

3.深入理解进程概念，了解PCB

4.学习进程状态，学会创建进程，掌握僵尸进程和孤儿进程，及其形成原因和危害

5.了解进程调度，Linux进程优先级，理解进程竞争性与独立性，理解并行与并发

6.理解环境变量，熟悉常见环境变量及相关指令, getenv/setenv函数

7.理解C内存空间分配规律，了解进程内存映像和应用程序区别, 认识地址空间。

8.选学Linux2.6 kernel，O(1)调度算法架构  



linux系统编程阶段：使用linux系统提供的接口 完成指定功能的编写。（进程概念、进程控制、基础IO、进程间通信、进程信号、多线程）

系统编程阶段：有6个单元，会讲到很多的知识点，以及代码相关的接口，学习过程中，以及整体学习完，很多同学都会有个感受，知识串不起来。

系统编程阶段的知识点都是一个个单独的知识点，本身就不是让大家串在一起的，学习这些知识点，是为了让我们能够知道在实现项目中某个功能的时候，能够通过哪个知识点实现，因此只需要把每个知识点单独理解透彻了就可以了。

进程概念：冯诺依曼体系结构、操作系统、进程概念、进程状态、环境变量、程序地址空间。



# 2.冯诺依曼体系（了解）

冯诺依曼体系结构：现代计算机的硬件体系结构（规定了现代计算机应该具有哪些硬件单元）

硬件单元：输入设别（键盘）、输出设别（显示器）、存储器（内存条）、运算器 + 控制器（中央处理器cpu）

所有设备都是围绕存储器工作的。

内存：内存条。		外存：硬盘

![image-20230810082720113](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230810082720113.png)

黑色：数据的流向。			红色：信号的流向。

硬件结构决定了软件行为：一个简单的helloworld程序。

printf：进行数据结构。

程序运行，会被加载到内存中。

qq聊天：键盘采集输入，放到内存中，cpu进行处理，网卡发送数据。

因此qq这个程序的编写，scanf获取键盘输入数据，printf。



# 3.操作系统

操作系统：linux（linux内核 + 红帽子 / centos / ubuntu特定的应用）。

操作系统组成 = 内核 + 应用。（一般说inux是内核）

内核是操作系统的核心，应用是为了让操作系统更加好用。

定位：计算机上搞管理的软件，管理计算机上的软硬件资源。

管理：

​	学校管理体系中：校长管理学生（小黑同学，在学校中喜欢打架，校长要开除小黑），实际上是通过学籍来管理学生的，学籍就是学生的描述。

​	学校中有很多学籍，为了高效管理，则把每个描述良好的组织起来。

操作系统通过硬件驱动管理键盘、鼠标、硬件。（硬件驱动就是相当于学校管理体系中的老师）

用户

shell命令	库函数

系统调用接口

操作系统 内核

硬件驱动

键盘 鼠标 硬件

系统调用接口：操作系统提供的用户访问系统内核的接口。

库函数与系统调用接口的关系：库函数实际上就是对系统调用接口进行的一层封装后的接口。



# 4.进程概念

进程概念：理解进程是什么。

进程：运行中的程序。

![image-20230810223747405](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230810223747405.png)

在linux中pcb是task_struct结构体。

task_struck结构体中的一些描述信息：

内存指针：是一个指针（地址），当前pcb所调度管理的这个程序在内存中的位置，通过内存指针能够找到这个程序在内存中的位置。

上下文数据：程序进行调度切换的时候，保存的数据。

程序计数器：程序进行调度切换的时候，程序即将要进行的下一步指令，程序调度切换回来程序就可以从下一步指令开始继续往下执行了。

进程ID（pid）：进程的标识符，每一个进程都有唯一的id，以便于操作系统的查找。

IO信息（输入输出信息）：

进程优先级：哪个进程应该被优先调度执行。

进程状态：

记账信息：流水账。



并发：一种轮询处理的方式。

并行：同时运行。

单核肯定是并发的，多核可以进行有限的并行。



## 4.1进程是啥

在计算机科学中，进程（Process）是指计算机中正在运行的程序的实例。一个进程代表了一个程序的执行过程，包括程序代码、数据以及相关的资源和环境。

每个进程都有自己的地址空间，包括代码段、数据段、堆栈等。它们相互独立，彼此之间不能直接访问对方的内部数据。操作系统通过分配内存、管理进程的执行和调度等功能来支持多个进程同时运行。

进程具有以下特点：

1. 独立性：每个进程是独立运行的，它们有各自独立的内存空间和资源。
2. 并发性：多个进程可以同时存在于计算机系统中，并且可以并发执行，共享处理器时间。
3. 隔离性：每个进程运行在自己的地址空间中，彼此之间相互隔离，一个进程的错误不会影响其他进程。
4. 通信机制：进程可以通过进程间通信（IPC）的机制进行数据交换和协作，如管道、信号、共享内存、消息队列等。

操作系统通过进程管理器来管理和控制进程的创建、终止、调度和资源分配等操作。每个进程都有一个唯一的进程标识符（PID），用于在操作系统中标识和管理进程。

总之，进程是计算机中正在运行的程序的实例，它们是操作系统进行资源分配和调度的基本单位，实现了多任务并发执行和资源隔离。



## 4.2在linux中pcb就是task_struct

在 Linux 中，PCB（Process Control Block）通常被称为 `task_struct`，它是用于管理进程的数据结构。`task_struct` 结构体定义了进程的各种属性和状态信息，包括但不限于以下内容：

1. 进程标识符（PID）：唯一标识一个进程的数字。
2. 状态：表示进程的当前状态，如就绪（Runnable）、运行（Running）、睡眠（Sleeping）等。
3. 调度信息：包括进程的调度策略、优先级等。
4. 进程间关系：描述进程之间的父子关系、兄弟关系等。
5. 文件描述符表：记录了进程打开的文件和输入输出流。
6. 内存管理信息：存储了进程的地址空间信息。
7. 信号处理器：用于处理进程接收到的信号。
8. 执行上下文：保存了进程的寄存器状态、程序计数器等。

`task_struct` 结构体是 Linux 内核中非常重要的数据结构之一，通过维护 `task_struct`，操作系统可以进行进程的创建、终止、切换和调度等操作。在进程调度过程中，内核通过修改 `task_struct` 来实现不同进程之间的切换与调度。每个正在运行或等待执行的进程都有一个对应的 `task_struct` 数据结构。

因此，在 Linux 操作系统中，PCB 即 `task_struct` 结构体，它是管理进程的核心数据结构。



## 4.3进程的简单操作

创建进程：进程就是一个pcb，是一个task_struct结构体（linux中），创建一个进程实际上就是创建了一个task_struct结构体。

```shell
ps -ef				#打印所有的进程信息
ps -aux				#更加详细的信息
ulimit -a			#显示当前用户的资源限制信息的命令。它将显示各种系统资源的软限制和硬限制
ulimit -u			#查看一个用户的最大进程数量（最大用户进程数（max user processes））
```

![image-20230811021121612](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230811021121612.png)

UID：进程属于谁的）

PID：进程ID

PPID：当前进程的父进程的ID

STIME：起始进程运行的时间

TTY：终端号

TIME：这个进程在CPU上已经运行的时间

CMD：这个进程是哪一个命令运行出来的进程

![image-20230811025807557](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230811025807557.png)

USER：进程所属的用户

PID：进程ID

%CPU：当前进程的CPU使用率

%MEM：当前进程的内存使用率

VSZ：虚拟内存的使用的大小

RSS：物理内存的使用大小

TTY：终端号

STAT：状态（Ss是休眠状态）（后边的+表示是一个前台的进程，前台的进程表示当前占据终端的进程）

START：起始运行时间

TIME：CPU上的运行时间

COMMAND：执行的指令

![image-20230811090324266](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230811090324266.png)

![image-20230811090355959](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230811090355959.png)



### 4.3.1ulimit -a

`ulimit -a` 是一个用于显示当前用户的资源限制信息的命令。它将显示各种系统资源的软限制和硬限制。

运行 `ulimit -a` 将输出以下类型的资源限制信息：

- core 文件大小限制（core file size）
- 最大数据段大小（data seg size）
- 虚拟内存限制（virtual memory）
- 堆栈大小限制（stack size）
- CPU 时间限制（cpu time）
- 最大用户进程数（max user processes）
- 文件描述符限制（file descriptors）
- 管道缓冲区大小（pipe size）
- 锁定内存大小限制（max locked memory）
- 伪终端设备数目（max pseudo-terminals）
- 最大内存区域数目（max memory region）

请注意，输出中的值可能因操作系统和系统配置而异。软限制是为当前会话设置的限制值，而硬限制是系统允许的最大限制。超出软限制的尝试将导致操作失败或

产生错误，而超出硬限制将导致操作系统发送信号或终止进程。

### 4.3.2配置用户最大进程数量

用户最大进程数量是由系统管理员通过配置文件来设置的。在大多数Linux系统中，可以通过修改`/etc/security/limits.conf`文件来设置用户的最大进程数量限制。

您可以按照以下步骤进行配置：

1. 打开终端，并以管理员身份登录或使用sudo权限。
2. 编辑`/etc/security/limits.conf`文件。例如，使用vi编辑器执行以下命令：

```shell
sudo vi /etc/security/limits.conf
```

1. 在文件的末尾添加以下配置行，其中`username`是您要设置最大进程数量的用户名：

```shell
username hard nproc limit
```

`limit`是您希望设置的最大进程数量限制值。 4. 保存并关闭文件。 5. 重新启动系统或注销并重新登录，以使更改生效。

请注意，这只影响新的登录会话。对于已经登录的会话，需要重新启动或注销并重新登录才能应用新的限制。

此外，还有其他方式可以对用户的最大进程数量进行临时更改，如使用ulimit命令或修改pam模块配置文件。然而，这些更改通常只适用于当前会话，并在注销或

重新启动后失效。



## 4.4进程状态

用于操作系统对于进程的管理。（什么状态该给进程进行什么样的操作）（总体上分为运行态、就绪态、阻塞态）

linux中的进程状态：

运行态（R）：正在运行或者轮转到时间片则能够运行统称运行态。

可中断休眠态（S）：可以被中断的休眠状态（满足唤醒条件，或者休眠被中断则进入运行态）

不可中断休眠态（D）：不能被中断的休眠状态（满足唤醒条件之后才会进入运行态）

停止态（T）：程序停止运行的状态（依然会被调度，但是什么都不做）

死亡态（X）：进程退出了就是死亡态，一闪而逝的状态。

僵尸态（Z）：进程已经退出不再调度了，但是这个进程的资源还没有被完全释放，等待处理的一种状态。



### 4.4.1僵尸进程

僵尸进程：处于僵尸态的进程，是一种退出了，但是资源没有完全被释放的进程。

产生：子进程先于父进程退出，但是父进程没有关注到子进程的退出，子进程为了保存自己的退出原因，所以资源没有完全被释放，因此系统不会完全释放子进程

的资源，这个子进程进入僵尸状态。

子进程退出之后，在进程pcb中保存了自己的退出返回值，在父进程没有关注处理的情况下，pcb资源是不会被释放的。

危害：资源泄漏（一种是pcb所占的内存资源一直无法被回收，一种是一个用户所能创建的进程数量是有限制的）

解决方案：

​	处理：退出父进程。

​	避免：进程等待。



### 4.4.2孤儿进程

孤儿进程：父进程先于子进程退出，子进程就会成为孤儿进程，运行在后台，父进程成为1号进程（孤儿院）（早期名字叫init进程，后期叫systemd）

孤儿进程不需要处理，是默默在后台运行的，默默完成功能的。（僵尸进程资源没有被释放，孤儿进程交给操作系统释放资源）

孤儿进程是正常运行的状态，只不过是运行在后台的，不需要处理，孤儿进程有自己的应用方向。（将需要默默运行在后台的这种程序，需要弄成精灵进程（特殊

的孤儿进程））



当一个进程的父进程先于它自己终止时，该进程将成为孤儿进程。在这种情况下，操作系统会接管孤儿进程，并将其父进程设置为init进程（进程ID为1）。

一旦成为孤儿进程，操作系统会负责回收和释放该进程所占用的资源。这包括关闭打开的文件描述符、释放内存、清除进程所持有的其他资源等。操作系统会确保孤儿进程不会继续运行下去，以避免资源泄漏和系统稳定性问题。

因此，一般情况下，孤儿进程的资源会被适当地释放。但需要注意的是，如果孤儿进程已经创建了其他子进程，并且这些子进程仍然在运行，那么这些子进程可能

会继续存在并占用资源，直到它们自己完成或被终止。

总的来说，操作系统会处理孤儿进程的资源释放，以确保系统的正常运行和资源管理。



### 4.4.3精灵进程（守护进程）

精灵进程（守护进程）：课后调研，如何实现。（特殊的孤儿进程）



## 4.5创建子进程

pid_t fork(void)	创建进程的接口。				fork是一个系统调用接口。（用户不能直接访问内核）

返回值：在父进程中返回的是子进程的pid，在子进程中返回0



## 4.6objdump

`objdump` 是一个用于分析目标文件（object file）的命令行工具。它可以显示目标文件的各种信息，如符号表、代码段、数据段等。

`objdump` 可以用于不同的架构和文件格式，例如ELF（Executable and Linkable Format）、COFF（Common Object File Format）等。

一般来说，您可以使用以下示例命令来使用 `objdump` 工具：

```
Copy Codeobjdump -<options> <object_file>
```

其中，`<options>` 是您希望执行的选项，而 `<object_file>` 则是要分析的目标文件。

例如，要查看一个 ELF 格式的可执行文件的汇编代码，可以使用以下命令：

```
Copy Codeobjdump -d executable_file
```

这将显示可执行文件的汇编代码。

请注意，`objdump` 的选项和使用方式取决于您所使用的操作系统和具体的文件格式。建议您查阅相关文档或运行 `objdump --help` 以获取更多详细信息和特定于

您环境的选项。



以下是常见的 `objdump` 命令选项：

- `-a`：显示所有头部信息。
- `-d`：反汇编代码段。
- `-t`：显示符号表。
- `-r`：显示重定位表。
- `-x`：显示全部段的详细信息。
- `-s`：显示目标文件的完整内容。
- `-H`：显示目标文件的文件格式信息。
- `-G`：显示全局偏移表。
- `-R`：显示动态重定位表。
- `-W`：显示全部调试信息。
- `-L`：显示动态链接信息。

这只是一些常见选项的例子。实际上，`objdump` 支持更多选项，具体取决于您所使用的操作系统和文件格式。

您可以通过运行 `objdump --help` 命令获取完整的选项列表和说明，以了解在您的环境中可用的选项。



## 4.7问题

1.创建进程，就是从创建进程的那个位置开始复制父进程？

答：不是的，是整体复制，只是因为程序计数器保存的位置是创建子进程成功之后的指令，因此复制过来之后，子进程从这里开始运行的。



# 5.环境变量

```shell
env				#显示当前系统环境变量的值
set				#查看shell中所有变量，不限于环境变量（shell中有两种变量，一种叫普通的临时变量，一种叫环境变量）
#环境变量具有父子进程的传递性，普通变量不具有。
```

`env`是一个在命令行环境下使用的命令，用于显示当前系统环境变量的值。

当在终端或命令提示符中键入`env`命令时，它将输出系统环境变量的列表。这些环境变量是一些由操作系统或用户设置的键值对，可以在程序运行期间提供各种配置和信息。常见的环境变量包括`PATH`、`HOME`、`USER`等。

示例输出可能如下所示：

```shell
USER=john
HOME=/home/john
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

在Linux和Unix系统中，可以通过设置环境变量来配置系统和应用程序的行为。可以使用`export`命令或直接在命令行中指定环境变量来设置它们。例如：

```shell
export MY_VAR=my_value			#设置环境变量
MYVAL=1000						#设置普通变量
env | grep MY_VAR				#查看环境变量
set | grep MYVAL				#查看普通变量 或者 环境变量（查看所有变量）
export MYVAL					#声明环境变量
ehco $a							#查看指定变量
unset MYVAL						#删除环境变量
```

上述命令将创建一个名为`MY_VAR`的环境变量，并将其值设置为`my_value`。然后，可以通过运行`echo $MY_VAR`来获取该环境变量的值。

使用环境变量可以灵活地控制和配置不同应用程序的行为，使其适应特定的需求和环境。



环境变量：也是一种变量，是一种保存系统运行环境参数的变量，便于运行环境参数的配置（改变了环境变量的值，是直接生效的，修改配置文件要让系统重新加

载一遍配置文件），环境变量还有一种特性，是继承性（父子进程的传递），子进程会拥有父进程的环境变量（默认情况下）（进程之间的数据通信），。

不同终端的环境变量是不一样的。



典型环境变量：

PATH：程序运行的默认搜索路径，在命令行终端中输入命令名称可以直接执行对应名称的命令程序，实际上是因为shell捕捉到输入的命令名称之后，然后去PATH

环境变量指定的路径下去找这个程序，找到了就运行，找不到就报命令没有找到的错误。

```shell
PATH=${PATH}:./				#把./添加到PATH中
PATH=$PATH:./				#把./添加到PATH中
```

```c
//环境变量接口
char* getenv(const char* name);	//通过名称获操作系统的环境变量的值（参数：环境变量名称，返回值：环境变量的字符串首地址，如果不是环境变量返回NULL）
int setenv(const char* name,const char* value,int overwrite);				//添加或者设置环境变量（第三个参数是是否覆盖已有的环境变量）
int putenv(char* string);													//添加或者设置环境变量
```

铺垫：shell中运行的程序，父进程都是shell，或者反过来说，shell中运行的进程都是shell的子进程。

代码操作：getenv()（备注：setenv()也可以）、extern char **environ;		main(int argc,char* argv[],char *env[]);



![image-20230812002017212](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230812002017212.png)

```c
//env.c（环境变量的值）
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
 
int main()
{
	char *env1 =  getenv("MYVAL1");				//不是环境变量，返回NULL
	if(env1 == NULL)
	{
		printf("not fount MYVAL1\n");
    }
	else
	{
		printf("%s\n",env1);
	}
    char *env2 = getenv("MYVAL2");
    	
    if(env2 == NULL)
    {
        printf("not fount MYVAL2\n");
    }
    else
    {
        printf("%s\n",env2);
    }

    while(1)
    {
        sleep(1);
    }
 
    return 0;
}
//输出：
//not fount MYVAL1
//2000
//解释：./env是在shell中运行的，继承了父进程shell的环境变量，env1不是环境变量，就是NULL，env2是环境变量，从当前shell中继承过来，可以访问。
```

![image-20230812002105160](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230812002105160.png)

![image-20230812002349951](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230812002349951.png)

另一个终端：

![image-20230812002152688](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230812002152688.png)



```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
 
int main(int argc,int* argv[])
{
    extern char **environ;      //声明已有的全局变量，这个变量中保存了所有能够访问到的环境变量的字符串地址
    int i;
    for(i = 0; environ[i] != NULL; i++)
    {
        printf("%s\n",environ[i]);
    }
    return 0;
}
//代码的功能和env命令行的作用一样
```



```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
 
//参数：程序运行参数的个数，程序运行参数字符串地址，环境变量的字符串 地址（参数名称无所谓，全局变量名称必须是environ）
int main(int argc, int* argv[], char *environ[])
{    
	// extern char **environ;      //声明已有的全局变量，这个变量中保存了所有能够访问到的环境变量的字符串地址
    int i;
    for(i = 0; environ[i] != NULL; i++)
    {   
        printf("%s\n",environ[i]);
    }
    return 0;
}
```



# 6.程序地址空间

![image-20230812053211248](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230812053211248.png)

百度网盘：每个人只要创建账号就有1G磁盘用于存储数据。

一个人有300G的空间。

假设有5亿人使用网盘，1T100块钱，1亿块硬盘100亿块钱。

因为大部分人用不了这么多，用的时候再给你分配。

系统为每个进程都描述一个完整的、连续的、线性的虚拟地址空间，实际物理内存用的时候再给进程分配，这样的话，对于每个进程自己的感觉，看起来都有一块

完整的、连续的内存可以使用。

给每个进程虚拟一个地址空间，让进程访问完整连续的地址，但是这些虚拟地址在使用的时候通过页表映射一块物理内存地址，进行访问物理内存。

通过映射的这种方式，实现了数据在物理内存上的离散式存储，提高内存利用率。（虚拟内存技术）



总结：

虚拟地址空间：是系统为每个进程通过mm_struct结构体虚拟的一个地址空间，使用虚拟地址空间的目的是为了让进程能够访问一块连续的、完整的地址，并且经

过页表映射到物理内存之后，可以实现数据在物理内存上的离散式存储，提高内存利用率，并且在页表中可以进行内存访问控制。



虚拟地址如何通过页表获取到物理地址的呢？

内存管理方式：

1.分段式内存管理：将地址空间分为多段（代码段、数据段...），便于编译器进行地址管理。、

分段式虚拟地址组成：段号 + 段内的地址偏移量。

在系统中有一个段表：一个个段表项（段号，物理内存段起始地址）。

![image-20230812054430167](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230812054430167.png)



2.分页式内存管理：将地址空间分为多个小块（页），实现数据离散式存储，提高内存利用率。（面试时候问的最多的）

分页式虚拟地址组成：页号 + 页内偏移。

在系统中有一个页表（页号，物理内存块起始地址，权限控制，缺页中断位...）

![image-20230812060708027](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230812060708027.png)

缺页中断：缺页中断表示当前地址要访问的数据不在物理内存中。

为什么会有缺页中断？

交换内存：（磁盘）
![image-20230812134033706](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230812134033706.png)

当物理内存不够使用的时候，则将物理内存中不活跃的数据，保存到磁盘的交换分区中，腾出的物理内存可以给新的程序数据使用。

什么样的数据是不活跃的数据，或者说应该把哪些数据放到交换分区上？

最久未使用算法（LRU）（着重看）、最少未使用、......



操作系统中可以使用LRU（least recently used）内存淘汰旧数据的策略，如果内存需要加载新数据但空间又不足，则会按照最近访问时间进行排序，并将最老的

数据淘汰，假设现在内存空间大小为6，原本内存中没有数据，对内存中数据的访问顺序如下：1、2、5、3、4、6、1、4、3、6、7、8、3、9，则缺页次数为几

次？

答：刚开始内存中没有数据，缺页中断6次，7和8缺页中断2次，9缺页中断1次，总共缺页中断9次。

643521    164352   416352    341652   634152    763415    876341    387641   938764



现在有个虚拟地址xxx，有个页表，请问对应的物理地址是多少？

一个分页存储管理系统中，地址长度为32位，其中页号占8位，则页表长度是多少？

答：页号占了8位，有2^8页表项。



有个虚拟地址十进制5480，页面大小4096个字节，页表如下，请问物理地址是多少？

页号	物理块号

3				5

2				8

1				6

0				3

答：

页号 = 5480 / 4096

页内偏移 = 5480 % 4096

物理地址 = 6 * 4096 + 页内偏移 = 6 * 4096 + 1384 = 24576 + 1384 = 25960。



某计算机主机地址空间大小为256MB，按字节编址。虚拟地址空间大小为4GB，采用页式存储管理，页面大小为4KB，TLB（快表）采用全相联映射，有4个页表

项，内容如下表所示。（H表示16进制）

有效位 | 标记 | 页框号 | ... |

0    | FF180H | 0002H | ... |

1    | 3FFF1H | 0035H | ... |

0    | 02FF3H | 0351H | ... |

1    | 03FFFH | 0153H | ... |

则对虚拟地址03FF F180H进行虚实地址变换的结果是多少？

答：

虚拟地址空间大小：2^32

页面大小：2^12

页号：2^20

03fff			高20位页号

180			  低12位偏移

页框号是物理地址

页表里面03FFFH对应的是0153H

物理地址是00153180H（前面补0）



3.段页式内存管理：将虚拟地址空间进行分段，在每个分段内进行分页式管理，集合了分段分页的优点进行内存管理。（是当前使用的内存管理方式，前面两种都

有优缺点）



选学：多级反馈调度算法：O(1)





# 7.总结

1.冯诺依曼体系结构：

五大硬件单元：输入、输出、存储器、运算器、控制器。

所有设备都是围绕内存工作的。

2.操作系统：

定位：一款搞管理的软件。

管理：先描述，再组织。

系统调用接口：操作系统向上层提供访问内核指定功能的接口。

库函数：对系统调用接口的封装。

3.进程概念：

概念：进程就是进行中的程序，在操作系统的角度进程实际上是对于运行中程序的动态描述，叫做pcb进程控制块，在linux中是一个task_struct结构体。通过这个

程序运行的动态描述，实现对程序运行调度以及资源的管理。

描述：内存指针（指向了程序在内存中的位置）、上下文数据 （处理过的数据叫做上文，处理中的数据叫做中文，将要处理的数据叫做下文）、程序计数器（将

要进行的指令，操作系统轮询调度回来要处理的指令位置）、标识符进程PID、IO信息等。

分时机制：多任务操作系统中使用分时机制实现多任务并发处理，轮询处理。

时间片：cpu处理程序执行的这段时间。

并发：轮询处理。		并行：同时处理。

4.进程状态：linux下的状态

进程创建：pid_t fork(void);

通过复制父进程创建一个新的子进程，对于父进程返回子进程pid，对于子进程返回0。

进程状态：运行态、可中断休眠态、不可中断休眠态、死亡态、停止态、僵尸态。

僵尸进程：僵尸态的进程（进程退出了但是资源没有完全被释放的进程）。

产生：子进程先于父进程退出，父进程没有关注到子进程的退出状态，因此系统不会自动回收子进程资源，子进程进入僵尸状态。

危害：资源泄漏（进程数量有限制，内存资源）

解决办法：退出父进程（解决） 或者 进程等待（避免）。

孤儿进程：父进程先于子进程退出后，子进程成为孤儿进程，运行在后台，父进程成为1号进程。

守护进程：特殊的孤儿进程。

创建子进程的优点：安全（尤其是服务器）、效率高。

5.环境变量：保存运行环境参数的变量，运行环境的配置更加灵活，进程通信。

命令操作：env（查看所有的环境变量），set（查看所有的变量，包括普通变量）、echo（直接打印环境变量的值，普通变量也可以）、export（设置环境变量

的值）、unset（删除环境变量）。

代码操作：getenv()、main第三个参数、全局变量char** environ（使用前声明一下，库里面定义的）。

环境变量是具有父子进程之间的传递特性的。

6.程序地址空间：进程的虚拟地址空间。（程序是不占空间的）

概念：系统给进程描述的一个虚拟的地址空间。（mm_struct）

为什么：让进程访问虚拟地址，使进程拥有一个连续的、完整的地址使用并且系统为进程创建了一个页表，用于映射虚拟地址与物理地址关系，进而实现数据在物

理内存上离散式存储，提高内存利用率，并且进行内存访问控制。

页表是如何进行虚拟地址与物理地址的映射的？（虚拟地址映射物理地址）

内存管理方式：分段式、分页式、段页式。

分段式：虚拟地址组成：段号 + 段内偏移量。		段表：段号 + 物理端地址

​				对内存进行分段，便于编译器进行地址管理。

分页式：虚拟地址组成：页号 + 页内偏移量			页表：页号 + 物理块地址

​				对内存进行分块，进行数据离散式存储，提高内存利用率，以及内存访问控制。

段页式：先对内存进行分段，在每个段内进行分页。

缺页中断：通过虚拟地址进行页表映射访问物理内存时发现数据不在物理内存中。

内存置换算法：LRU（最久未使用）......









# 8.面试题

进程间通讯，引出套接字。

进程间通信的方式应用场景。

为什么用多线程，优势在哪，劣势在哪。

进程地址空间布局讲一下。

一个程序总共生成了多少个进程。

进程之间通信方式

进程和线程的区别

进程调度算法

进程之间的互斥和同步

多进程和多线程的区别

多线程的同步方法和如何使用

进程、线程和协程区别

