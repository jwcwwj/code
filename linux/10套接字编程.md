# 1.udp协议和tcp协议的区别

socket套接字编程：网络通信程序的编写；（接口 + 流程）

udp协议通信程序的编写/tcp协议通信程序的编写。

udp协议与tcp协议的区别初始：

udp协议：用户数据报协议。

特性：无连接、不可靠、面向数据报。

应用场景：实时性要求大于安全性要求的场景，比如视频传输。

tcp协议：传输控制协议。

特性：面向连接，可靠传输、面向字节流。

应用场景：安全性要求大于实时性要求的场景，比如文件传输。



# 2.客户端和服务端

在网络通信程序中，通信两端被分为：客户端、服务端。

客户端：通常是提供给客户的通信端，通常是编写通信程序中主动请求的一端。（需要知道服务端的IP地址才可以主动请求）

服务端：通常指被动接受请求，提供服务的通信端。

客户端是主动发送请求的一端，也就意味着客户端必须提前能够知道服务器的地址信息（ip + port）是多少。

服务端的地址信息通常是固定的，并且是提前提供给客户端的。

网络通信依靠的是计算机上的硬件：网卡。

udp通信程序的编写：套接字接口

udp通信程序：

![image-20230916022502751](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230916022502751.png)

一个套接字（进程）使用一个端口。



tcp通信程序的编写：

tcp通信程序：

![image-20230921005455626](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230921005455626.png)



# 3.接口认识（udp）

Socket接口是一组用于在网络上进行通信的函数和数据结构。它为Socket编程提供了抽象层，使得程序员可以使用简单的函数调用来实现网络通信。

Socket接口通常使用C语言提供的网络库或API实现，例如Windows下的Winsock库、Linux下的BSD Socket（POSIX Socket）等。

在Socket编程中，常用的Socket接口函数包括：

1. `socket`：创建一个新的套接字对象并返回其句柄
2. `bind`：将套接字对象绑定到指定的IP地址和端口号上
3. `listen`：开始监听传入的连接请求
4. `accept`：接受传入的连接请求，创建新的套接字以与客户端进行通信，并返回与该客户端通信的套接字对象
5. `connect`：与服务器建立连接
6. `send`：通过套接字发送数据
7. `recv`：从套接字接收数据
8. `close`：关闭套接字

Socket接口的数据结构包括：

1. `sockaddr`：表示一个通用的网络地址结构体，其中包含IP地址和端口号等信息
2. `sockaddr_in`：用于IPv4地址族的地址结构体
3. `sockaddr_in6`：用于IPv6地址族的地址结构体

Socket接口提供了一种通用的方法来实现网络通信，使得开发者可以在不同的平台上使用相同的代码来实现网络应用。同时，Socket接口的使用也需要遵守各种协议和规范，例如TCP/IP协议、HTTP协议等。

## 3.1创建套接字：

```shell
man 2 socket
```

```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
int socket(int domain, int type, int protocol);
```

作用：用于创建一个新的套接字对象，并返回套接字的文件描述符（句柄）

参数：

domain：地址域类型；（指定套接字的协议族或地址族）		

AF_INET：IPv4通信，使用IPv4的地址结构。	AF_INET6：IPv6通信，使用IPv6的地址结构。

type：套接字类型；		

- `SOCK_STREAM`：面向连接的可靠数据流套接字，使用TCP协议
- `SOCK_DGRAM`：无连接的不可靠数据报套接字，使用UDP协议
- `SOCK_RAW`：原始套接字，可以直接访问底层网络协议 

protocol：本次通信协议；指定套接字使用的具体协议。如果在`domain`和`type`参数中已经指定了具体的协议，可以设置为0，让系统自动选择适合的协议。

```shell
#查看协议
vim /usr/include/netinet/in.h
```

返回值：新创建的套接字的文件描述符（句柄），如果创建失败，则返回-1，并设置全局变量errno来表示错误类型。（有种说法：套接字在linux中是一种特殊文

件）

```c
#include <sys/socket.h>
#include <stdio.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("socket creation failed");
        return 1;
    }
    
    // 套接字创建成功，进行其他操作
    
    // 关闭套接字
    close(sockfd);
    
    return 0;
}
```

以上示例创建了一个IPv4的面向连接的套接字，然后进行了一些操作，并最终关闭套接字。

需要注意的是，`socket`函数只是创建了一个套接字对象，并没有绑定地址或进行连接操作，后续的绑定、监听、连接、发送和接收等操作需要调用其他Socket接

口函数来完成。



## 3.2为套接字绑定地址信息

```shell
man 2 bind
```

```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
```

作用：将一个套接字对象绑定到指定的IP地址和端口号上。

参数：

sockfd：要绑定的套接字的文件描述符（创建的套接字返回的操作句柄）。

addr：指向包含要绑定的IP地址和端口号的`sockaddr`结构体的指针。可以根据使用的地址族（例如`AF_INET`或`AF_INET6`）来确定具体的结构体类型（`sockaddr_in`或`sockaddr_in6`）。

addrlen：`addr`指向的结构体的大小（以字节为单位）（地址信息长度）。

返回值：返回值为0表示绑定成功，-1表示绑定失败，并设置全局变量errno来表示错误类型。

```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdio.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("socket creation failed");
        return 1;
    }
    
    struct sockaddr_in address;
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY; // 绑定到任意可用的IP地址
    address.sin_port = htons(8080); // 绑定到端口8080
    
    int bind_result = bind(sockfd, (struct sockaddr *)&address, sizeof(address));
    if (bind_result == -1) {
        perror("bind failed");
        return 1;
    }
    
    // 绑定成功，进行其他操作
    
    // 关闭套接字
    close(sockfd);
    
    return 0;
}
```

以上示例创建了一个IPv4的面向连接的套接字，并将其绑定到任意可用的IP地址和端口8080上。

需要注意的是，`bind`函数通常在服务器端使用，用于指定服务器的监听地址和端口。而客户端通常不需要显式调用`bind`函数，而是通过`connect`函数来建立与服务器的连接。



## 3.3接收数据

```shell
man 2 recvfrom
```

```c
#include <sys/types.h>
#include <sys/socket.h>
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);
```

作用：从已连接的套接字接收数据，并可以获得发送数据方的地址信息。

参数：

socked：接收数据的套接字的文件描述符（操作句柄）。

buf：用于接收数据的缓冲区。

len：接收缓冲区的大小，即`buf`的长度。（要接收的数据长度）

flags：可选的接收标志，例如`MSG_DONTWAIT`表示非阻塞方式接收，默认0表示阻塞接收。

src_addr：用于存储发送数据方的地址信息的结构体指针。如果不关心发送方的地址信息，可以将该参数设为`NULL`。（本条数据的源端地址信息）

addrlen：`src_addr`指向的结构体的大小。在调用`recvfrom`之前，需要将该值设置为发送方地址结构体的实际大小。接收完成后，`addrlen`将被修改为实际发送

方地址的大小。（输入输出参数、指定要接收多长的地址结构，并且返回实际接收的地址长度）

返回值：成功返回实际接收到的数据的字节数，失败返回-1，并设置全局变量errno来表示错误类型。

```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdio.h>
#include <string.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0); // 创建一个UDP套接字
    if (sockfd == -1) {
        perror("socket creation failed");
        return 1;
    }
    
    struct sockaddr_in address;
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(8080);
    
    int bind_result = bind(sockfd, (struct sockaddr *)&address, sizeof(address));
    if (bind_result == -1) {
        perror("bind failed");
        return 1;
    }
    
    char buffer[1024];
    struct sockaddr_in client_address;
    socklen_t client_addrlen = sizeof(client_address);
    
    ssize_t recv_result = recvfrom(sockfd, buffer, sizeof(buffer), 0,
                                   (struct sockaddr *)&client_address, &client_addrlen);
    if (recv_result == -1) {
        perror("receive failed");
        return 1;
    }
    
    // 打印接收到的数据
    printf("Received: %s\n", buffer);
    
    // 打印发送方的地址信息
    char client_ip[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &(client_address.sin_addr), client_ip, INET_ADDRSTRLEN);
    printf("Client IP: %s\n", client_ip);
    printf("Client Port: %d\n", ntohs(client_address.sin_port));
    
    // 关闭套接字
    close(sockfd);
    
    return 0;
}
```

以上示例创建了一个UDP套接字，并将其绑定到任意可用的IP地址和端口8080上。然后使用`recvfrom`函数从该套接字接收数据，并获取发送方的地址信息。

需要注意的是，`recvfrom`函数适用于面向无连接的套接字（如UDP），如果要使用面向连接的套接字（如TCP），应该使用`recv`函数进行接收。



## 3.4发送数据

ssize_t：有符号int

size_t：无符号int

```shell
man 2 sendto
```

```c
#include <sys/types.h>
#include <sys/socket.h>
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);
```

作用：通过已连接的套接字发送数据，并指定目标地址信息。

参数：

socked：要发送数据的套接字的文件描述符（操作句柄）。

buf：要发送的数据的缓冲区。（要发送数据的空间首地址）

len：要发送的数据的字节数。（要发送的数据长度）

flags：可选的发送标志，例如`MSG_DONTWAIT`表示非阻塞方式发送。（默认0，阻塞发送）

dest_addr：目标地址信息的结构体指针，用于指定数据发送的目标地址。对于面向无连接的套接字（如UDP），可以使用任何有效的地址信息。对于面向连接的套接字（如TCP），应该使用`connect`函数事先建立连接，并可以将此参数设为`NULL`。（对端地址信息）

addrlen：`dest_addr`指向的结构体的大小。（地址结构长度）

返回值：成功返回实际发送的字节数，失败返回-1，并且可以通过errno来表示错误类型。（ 对于TCP返回实际发送的字节数，可以不是指定的字节数，UDP要么成功要么失败，不会出现发送一部分的情况，这是面向数据报的特性决定的。）

```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdio.h>
#include <string.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0); // 创建一个UDP套接字
    if (sockfd == -1) {
        perror("socket creation failed");
        return 1;
    }
    
    struct sockaddr_in server_address;
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(8080);
    
    char message[] = "Hello, server!";
    
    ssize_t send_result = sendto(sockfd, message, strlen(message), 0,
                                 (struct sockaddr *)&server_address, sizeof(server_address));
    if (send_result == -1) {
        perror("send failed");
        return 1;
    }
    
    // 关闭套接字
    close(sockfd);
    
    return 0;
}
```

以上示例创建了一个UDP套接字，并将其绑定到任意可用的IP地址和端口8080上。然后使用`sendto`函数通过该套接字向服务器发送数据。

需要注意的是，对于面向无连接的套接字（如UDP），可以使用`sendto`函数直接发送数据并指定目标地址，而对于面向连接的套接字（如TCP），应事先建立连接（使用`connect`函数）来指定目标地址，然后使用`send`函数进行发送。



## 3.5关闭套接字

```shell
man 2 close
```

```c
#include <unistd.h>
int close(int fd);
```

作用：关闭一个文件描述符。

参数：fd：要关闭的文件描述符。

返回值：返回0表示成功关闭文件描述符，返回-1表示关闭失败，并设置全局变量errno来表示错误类型。

```c
#include <unistd.h>
#include <stdio.h>

int main() {
    int fd = open("example.txt", O_RDONLY); // 打开一个文件，获取文件描述符
    if (fd == -1) {
        perror("open failed");
        return 1;
    }
    
    // 使用文件描述符进行读写操作...
    
    int close_result = close(fd); // 关闭文件描述符
    if (close_result == -1) {
        perror("close failed");
        return 1;
    }
    
    return 0;
}
```

以上示例使用`open`函数打开了一个文件，获取到文件描述符后进行读写操作。然后使用`close`函数关闭文件描述符。

需要注意的是，关闭文件描述符后，不能再对其进行任何读写操作。另外，文件描述符是有限资源，应该在使用完毕后及时关闭，以释放资源并避免资源泄漏。



上面的是流程内的接口，下面的是流程外的接口，不得不需要的，是字节序转换接口。

## 3.6字节序转换接口（网络字节序（Network Byte Order）和主机字节序（Host Byte Order）之间的转换。）

```
man 3 htonl
```

```c
#include <arpa/inet.h>
uint32_t htonl(uint32_t hostlong);		//htonl函数用于将32位无符号整数（hostlong）从主机字节序转换为网络字节序。
uint16_t htons(uint16_t hostshort);		//htons函数用于将16位无符号整数（hostshort）从主机字节序转换为网络字节序。
uint32_t ntohl(uint32_t netlong);		//ntohl函数用于将32位无符号整数（netlong）从网络字节序转换为主机字节序。
uint16_t ntohs(uint16_t netshort);		//ntohs函数用于将16位无符号整数（netshort）从网络字节序转换为主机字节序。
```

h表示主机字节序，n表示网络字节序，l表示长（32位），s表示短（16位）。

字节序指的是在存储和传输多字节数据时，字节的顺序。主机字节序是特定计算机体系结构所采用的字节序，而网络字节序是在网络通信中约定的字节序，通常是大端字节序（Big Endian）。

```c
#include <arpa/inet.h>
#include <stdio.h>

int main() {
    uint32_t host_long = 0x12345678;
    uint16_t host_short = 0x1234;

    // 主机字节序转网络字节序
    uint32_t network_long = htonl(host_long);
    uint16_t network_short = htons(host_short);

    printf("Host long: 0x%08X\n", host_long);
    printf("Network long: 0x%08X\n", network_long);
    printf("Host short: 0x%04X\n", host_short);
    printf("Network short: 0x%04X\n", network_short);

    // 网络字节序转主机字节序
    uint32_t host_long2 = ntohl(network_long);
    uint16_t host_short2 = ntohs(network_short);

    printf("Host long 2: 0x%08X\n", host_long2);
    printf("Host short 2: 0x%04X\n", host_short2);

    return 0;
}
```

以上示例将一个32位无符号整数和一个16位无符号整数从主机字节序转换为网络字节序，并输出转换后的结果。然后再将转换后的数据从网络字节序转换回主机字节序，并输出结果进行对比。

注意点：port端口转换使用s（端口只有2字节数据），ip转换使用l，不能混用。



## 3.7将字符串点分十进制IP地址转换为整形网络字节序IP地址

"192.168.2.2"	->	0xc0a80202	（16进制）

```shell
man 3 inet
```

```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
//int inet_aton(const char *cp, struct in_addr *inp);
in_addr_t inet_addr(const char *cp);
```

作用：`net_addr`函数用于将点分十进制字符串形式的IPv4地址转换为32位无符号整数（in_addr_t）。

参数：cp：指向要转换的点分十进制字符串形式的IPv4地址的指针。

返回值：函数返回值是转换后的32位无符号整数表示的IPv4地址。如果转换失败，则返回`INADDR_NONE`。

```c
#include <arpa/inet.h>
#include <stdio.h>

int main() {
    const char *ip_address = "192.168.0.1";
    
    in_addr_t address = inet_addr(ip_address);
    if (address == INADDR_NONE) {
        fprintf(stderr, "Invalid IP address\n");
        return 1;
    }
    
    printf("IPv4 address: %s\n", ip_address);
    printf("In_addr_t value: 0x%08X\n", address);
    
    return 0;
}
```

以上示例将一个点分十进制字符串形式的IPv4地址转换为32位无符号整数，并输出转换后的结果。如果转换失败（例如，输入的字符串不是有效的IPv4地址），则输出错误信息。



## 3.8将网络字节序IP地址转换为字符串点分十进制

```shell
man 3 into
```

```c
char *inet_ntoa(struct in_addr in);
```

作用：将32位无符号整数表示的IPv4地址（in_addr）转换为点分十进制字符串形式。

参数：in：32位无符号整数表示的IPv4地址（in_addr）。

返回值：函数返回一个指向静态缓冲区的指针，该缓冲区包含转换后的点分十进制字符串形式的IPv4地址。每次调用`inet_ntoa`函数时，静态缓冲区都会被覆盖，因此在使用返回值之前应该立即复制它。

```c
#include <arpa/inet.h>
#include <stdio.h>

int main() {
    struct in_addr in;
    in.s_addr = htonl(0xC0A80001); // 192.168.0.1

    char *ip_address = inet_ntoa(in);
    printf("In_addr_t value: 0x%08X\n", ntohl(in.s_addr));
    printf("IPv4 address: %s\n", ip_address);

    return 0;
}
```

以上示例将一个32位无符号整数表示的IPv4地址转换为点分十进制字符串形式，并输出转换后的结果。注意在使用转换结果之前需要立即复制它到其他变量中，以避免静态缓冲区被覆盖的问题。



上面的这两个接口只能实现ipv4的地址转换，下面的不仅可以实现ipv4的地址转换，也可以实现ipv6的地址转换。



## 3.9用于将网络字节序的IP地址转换为人类可读的字符串形式。

```shell
man 3 inet_ntop
```

```c
#include <arpa/inet.h>
const char *inet_ntop(int af, const void *src,char *dst, socklen_t size);
```

作用：用于将网络字节序的IP地址转换为人类可读的字符串形式。

参数：

af：表示地址族（address family），可以是`AF_INET`（IPv4）或`AF_INET6`（IPv6）。

src：指向存储IP地址的内存块的指针。

dst：用于存储转换后的字符串形式IP地址的缓冲区。

size：缓冲区大小。

返回值：返回一个指向转换后的字符串形式IP地址的指针（即`dst`)。如果转换成功，函数返回`dst`的指针；如果出现错误，函数返回`NULL`。

```c
#include <arpa/inet.h>
#include <stdio.h>

int main() {
    struct in_addr in;
    in.s_addr = htonl(0xC0A80001); // 192.168.0.1

    char ip_address[INET_ADDRSTRLEN];
    const char *result = inet_ntop(AF_INET, &(in.s_addr), ip_address, INET_ADDRSTRLEN);
    if (result == NULL) {
        fprintf(stderr, "Failed to convert IP address\n");
        return 1;
    }

    printf("In_addr_t value: 0x%08X\n", ntohl(in.s_addr));
    printf("IPv4 address: %s\n", ip_address);

    return 0;
}
```

以上示例将一个32位无符号整数表示的IPv4地址转换为点分十进制字符串形式，并输出转换后的结果。在此示例中，我们使用了一个大小为`INET_ADDRSTRLEN`的缓冲区`ip_address`来存储转换结果。

注意，`inet_ntop`函数对IPv6地址同样适用。只需将`af`参数设置为`AF_INET6`即可。同时，指向IPv6地址的指针应该是`struct in6_addr*`类型。



## 3.10将人类可读的IP地址转换为网络字节序的二进制格式。

```shell
man 3 inet_pton
```

```c
#include <arpa/inet.h>
int inet_pton(int af, const char *src, void *dst);
```

作用：将人类可读的IP地址转换为网络字节序的二进制格式。

参数：

af：表示地址族（address family），可以是`AF_INET`（IPv4）或`AF_INET6`（IPv6）。

src：指向包含人类可读IP地址的字符串的指针。

dst：用于存储转换后二进制格式IP地址的内存块。

返回值：返回一个整数值，表示转换结果。如果转换成功，返回1；如果转换失败或地址族不支持，返回0。

```c
#include <arpa/inet.h>
#include <stdio.h>

int main() {
    struct in_addr in;
    struct in6_addr in6;

    const char *ipv4_address = "192.168.0.1";
    const char *ipv6_address = "2001:0db8:85a3:0000:0000:8a2e:0370:7334";

    int result_ipv4 = inet_pton(AF_INET, ipv4_address, &(in.s_addr));
    if (result_ipv4 == 1) {
        printf("IPv4 address converted successfully: 0x%08X\n", ntohl(in.s_addr));
    } else if (result_ipv4 == 0) {
        fprintf(stderr, "Invalid IPv4 address\n");
    } else {
        fprintf(stderr, "Conversion error for IPv4 address\n");
    }

    int result_ipv6 = inet_pton(AF_INET6, ipv6_address, &(in6.s6_addr));
    if (result_ipv6 == 1) {
        printf("IPv6 address converted successfully: %s\n", ipv6_address);
    } else if (result_ipv6 == 0) {
        fprintf(stderr, "Invalid IPv6 address\n");
    } else {
        fprintf(stderr, "Conversion error for IPv6 address\n");
    }

    return 0;
}
```

以上示例将人类可读的IPv4和IPv6地址转换为网络字节序的二进制格式，并输出转换结果。在此示例中，我们使用了`struct in_addr`和`struct in6_addr`来存储转换后的结果。

注意，`inet_pton`函数对IPv6地址同样适用。只需将`af`参数设置为`AF_INET6`即可。同时，指向IPv6地址的指针应该是`struct in6_addr*`类型。



## 3.11解释地址族

地址族（address family）是用于标识和处理不同类型的网络协议的一种机制。在网络编程中，地址族用于指定网络套接字（socket）的地址类型，以便正确地传输数据。

常见的地址族包括：

1. **AF_INET**：IPv4地址族。用于表示IPv4地址，通常以点分十进制字符串（如"192.168.0.1"）的形式表示。
2. **AF_INET6**：IPv6地址族。用于表示IPv6地址，通常以冒号分隔的八组十六进制数的形式表示（如"2001:0db8:85a3:0000:0000:8a2e:0370:7334"）。
3. **AF_UNIX**：UNIX域地址族。用于在同一台计算机上的进程之间进行本地通信，使用文件系统路径作为套接字地址。
4. **AF_NETLINK**：Netlink地址族。用于与Linux内核通信，用于执行系统配置、网络监控等任务。
5. 其他更少使用的地址族，如AF_IPX（IPX/SPX地址族）和AF_APPLETALK（AppleTalk地址族）等。

通过指定适当的地址族，网络编程可以根据不同的网络协议来处理套接字通信。例如，使用IPv4地址族可以实现基于IPv4的网络通信，而使用IPv6地址族可以支持IPv6地址的传输。

通常，在创建套接字时，需要指定期望的地址族，并为套接字分配相应的地址类型。这有助于确保套接字能够正确地与其他网络节点通信，并处理相应的地址格式和协议。



## 3.12综合使用（udp）

```c
//文件名:udp_srv.c
//服务端
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>       //字节序转换接口头文件  inet_addr
#include <netinet/in.h>      //地址结构、协议类型头文件
#include <sys//socket.h>     //套接字接口头文件

//服务端的代码
int main()
{
    //1.创建套接字
    //int socket(地址域类型, 套接字类型, 协议类型);     返回值：套接字操作句柄（描述符）
    int sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);       //AF_INET是IPv4的地址域类型，SOCK_DGRAM是数据报套接字，UDP通信给0，0表示默认的，因为数据报套接字默认的协议就是UDP，也可以给17表示UDP协议，给IPPROTO_UDP更加直观
    if(sockfd < 0)
    {
        //创建套接字失败
        perror("socket error");
        return -1;
    }

    //2.为套接字绑定的地址信息
    //(虚拟机：xshell连接的虚拟机IP地址，端口自定义大于5000的)
    //（云服务器：绑定的时候用的是内网地址，不要用公网地址，使用ifconfig查看，显示的是什么就连接什么）
    //绑定地址信息要组织地址结构
    //int bind(套接字描述符, 地址信息, 地址长度);
    struct sockaddr_in addr;    //定义IPv4地址结构
    addr.sin_family = AF_INET;  //IPv4的地址域类型
    addr.sin_port = htons(9000);   //设定地址端口。1024以上都可以随便使用，但是推荐给5000以上，这个9000是主机字节序的9000，真正到了内部转换为网络字节序就不知道是多少了，使用htons转换为网络字节序的9000
    //剩下的是2个字节的端口，4个字节的IP地址
    addr.sin_addr.s_addr = inet_addr("192.168.0.203");;   //结构体嵌套
    int len = sizeof(addr);     //IPv4的地址长度，求结构体长度也可以，是一样的值，不影响
    int ret = bind(sockfd, (struct sockaddr*)&addr, len);       //成功返回0，失败返回小于0的值（一般是-1）
    if(ret < 0)
    {
        //绑定失败
        perror("bind error");
        return -1;
    }
    
    //3.接收数据
    //recvfrom(句柄, 空间, 长度, 标志, 对端地址, 对端地址长度);   返回值：返回实际接收到的数据的字节数，失败返回小于0的数字（一般是-1）
    char buf[1024] = {0};   //缓冲区（空间）
    struct sockaddr_in paddr;   //对端地址
    len = sizeof(struct sockaddr_in)
    ret = recvfrom(sockfd, buf, 1023, 0, (struct sockaddr*)&paddr, &len);         //上面第2步定义ret了，是一个int类型
    //sockfd 是操作句柄，buf是空间，1023是为了放置字符串结尾标志'\0'，0表示默认的阻塞接收
    //如果不想获取对端地址，第5个参数传NULL，第6个参数给0(一般都是要获取的，知道是谁发的)
    if(ret < 0)
    {
        //接收出错
        perror("recvfrom error");
        return -1;
    }

    //网络字节序端口转换为主机字节序端口查看
    uint16_t cport = ntohs(paddr.sin_port);       //paddr是对端地址
    char* cip = inet_ntoa(paddr.sin_addr);

    printf("client-[%s:%d] say：%s\n", cport, cip, buf);

    //4.回复数据
    memset(buf, 0x00, 1024);
    printf("server say: ");
    fflush(stdout);
    fgets(buf, 1023, stdin);    
    char* data = "下课了";
    //sendto(发送缓冲区, 发送的数据, 要发送的数据长度, 标志位, 对端地址, 对端地址长度);
    //返回值：成功返回实际发送的字节数，失败返回-1
    ret = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr*)&paddr, len);        //标志位为0，表示默认阻塞发送 
    if(ret < 0)
    {
        //回复失败
        perror("sendto error");
        return -1;
    }

    //5.关闭套接字
    close(sockfd);

    return 0;
}
```

```cpp
//文件名：udpsocket.hpp
//客户端
/*
 * 封装实现一个udpsocket类
 * 通过实例化的对象调用对应的成员接口，
 * 可以实现udp客户端或服务端的搭建
 */
#include <cstdio>       //perror的头文件是stdio.h
#include <iostream>
#include <string>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/.socket.h>

class UdpSocket
{
private:
    int _sockfd;    //套接字描述符 
    
public:
    UdpSocket():
        sockfd(-1)
    {}

    //创建套接字
    bool Socket()
    {
        _sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);    //IPv4  用户数据报套接字 UDP通信
        if(_sockfd < 0)
        {
            perror("socket error");
            return false;
        }
    return true;
    }

    //绑定地址信息，绑定ip地址和端口
    bool Bind(std::string &ip, uint16_t port)
    {
        struct sockaddr_in addr;
        addr.sin_family = AF_INET;
        addr.sin_port = htons(port);
        addr.sin_addr.s_addr = inet_addr(ip.c_str());
        socklen_t len = sizeof(struct sockaddr_in);
        int ret;
        ret = bind(_sockfd, (struct sockaddr*)&addr, len);
        if(ret < 0)
        {
            perror("bind error");
            return false;
        }
        return true;
    }

    //发送
    bool Send(std::string &data, std::string &ip, int port)
    {
        struct sockaddr_in addr;
        addr.sin_family = AF_INET;
        addr.sin_port = htons(port);
        addr.sin_addr.s_addr = inet_addr(ip.c_str());
        socklen_t len = sizeof(struct sockaddr_in);
        int ret = sendto(_socked, data.c_str(), data.size(), 0, (sockaddr*)&addr, len);
        if(ret < 0)
        {
            perror("snedto error");
            return false;
        }
        return true;
    }

    //接收
    bool Recv(std::string* buf, std::string* ip = NULL, std::string* port = NULL)
    {
        //客户端不需要获取地址信息，后面传值是两个NULL
        struct sockaddr_in addr;
        socklen_t len = sizeof(struct sockaddr_in);
        
        char tmp [4096] = 0;    //临时空间的长度
        int ret = recvfrom(_sockfd, tmp, 4096, 0, (sockaddr*)&addr, &len);  //返回值是实际空间的长度
        if(ret < 0)
        {
            perror("recvfrom error");
            return false;
        }

        //自带申请空间拷贝数据  
        //std::string类的assign方法用于将一个字符串分配给另一个字符串，并替换原有的内容。
        buf->assign(tmp, ret);      //将实际空间中的数据拷贝到临时空间中

        if(ip != NULL)
        {
            *ip = inet_ntoa(addr.sin_addr);
        }

        if(port != NULL)
        {
            *port = ntohs(addr.sin_port);
        }

        return true;
    }

    bool Close()
    {
        if(_sockfd != -1)
        {
            close(_sockfd);
        }
        return true;
    }
};
```

```c
//文件名：udp_cli.cpp
//客户端
#include "udpsocket.hpp"

#define CHECK_RET(q) if((q) == false){return -1;}

int main()
{
    UdpSocket sock;
    //1.创建套接字
    CHECK_RET(sock.Socket());
    //2.绑定地址信息(UDP不推荐)
    while(1)
    {
        //3.发送数据
        std::cout << "client say: ";
        std::string buf;
        std::cin >> buf;
        CHECK_RET(sock.Send(buf, "192.168.0.203", 9000));
        //4.接收数据
        buf.clear();        //清空字符串内容，成为空字符串
        CHECK_RET(sock.Recv(&buf));
        std::cout << "server say: " << buf << "\n";
    }

    //关闭套接字
    sock.Close();

    return 0;
}
```

```makefile
all:udp_srv udp_cli
udp_srv:udp_srv.c
	gcc $^ -o $@
udp_cli:udp_cli.cpp
	g++ $^ -o $@
```

服务端绑定了地址和端口，客户端没有绑定地址和端口，客户端可以有多个，但服务端只能有一个。

第一个服务端： 

![image-20230920195713958](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230920195713958.png)

第二个服务端：显示信息：绑定错误，地址已经在使用中。（代码写的是服务端失败了显示错误信息后直接退出）

![image-20230920195806747](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230920195806747.png)

第一个客户端：

![image-20230920195644245](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230920195644245.png)

第二个客户端：

![image-20230920195913721](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230920195913721.png)

绑定了地址只能开辟一个会话，没有绑定可以开辟多个会话。

推荐服务端绑定地址和端口，客户端不绑定地址和端口，这样就有多个客户端和一个服务端，一个服务端为多个客户端提供服务，每个客户端给服务端发送信息，

在服务端会显示客户端的ip地址和端口，现实的端口永远都不是一样的，ip地址取决于客户端的ip地址，一个电脑上有多个客户端，ip地址就是一样的，要是客户

端在不同的电脑上，ip地址就是不一样的。

总结：客户端不主动绑定地址信息，只在有要求的情况下菜主动绑定，比如银行这种安全性高的，主动绑定设置白名单，防止黑客攻击。



### 3.12.1问题

服务端和客户端是一对一的，不是一对多的。（这个理解不清楚）

在传统的客户端/服务器模型中，服务端和客户端之间是一对多的关系，即一个服务端可以同时处理多个客户端的请求。每个客户端与服务端之间都建立一条独立的连接，通过这条连接进行通信。

然而，在某些特定情况下，服务端和客户端可以是一对一的关系，也称为点对点通信。在点对点通信中，只有一个客户端与服务端进行通信，不存在多个客户端同时连接的情况。

例如，某个实时聊天应用程序中，两个用户之间进行私密聊天时，可以采用点对点通信方式。其中一个用户作为客户端，另一个用户作为服务端，二者直接建立连接进行数据传输，而不需要经过中间服务器。

所以，客户端和服务端的关系可以根据具体的应用场景和需求来确定，可以是一对多的关系（传统的客户端/服务器模型），也可以是一对一的关系（点对点通信）。



## 3.13netstat命令：查看当前的网络状态信息

```shell
netstat		#查看网络状态（如何查看各个套接字的状态信息，如何查看网络监听状态都是这个命令）
netstat -a	#查看所有网络状态信息
netstat -n	#并不以服务名称显示IP地址或者端口，看具体的端口（因为固定的端口显示的是名称，不是端口号，加上-n查看的是端口号）
netstat -p	#查看对应的网络状态信息是哪一个进程的
netstat -t	#查看tcp的信息
netstat	-u	#查看udp的信息
```

![image-20230920201702534](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230920201702534.png)

在当前主机上能看到所有的网络状态信息，运行一个网络状态程序，存在一个问题：绑定地址失败了程序并没有退出，但是这个进程并没有实现网络通信，可以通过netstat查看网络状态信息，查看这个地址端口有没有被绑定和使用起来，就可以知道这个进程有没有进行网络通信。

查看网络状态信息，查看的是当前操作系统上的所有套接字信息，每一个套接字都会有一个绑定的IP地址和端口。

![image-20230924050344208](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230924050344208.png)

Proto：网络状态连接是哪一个协议的；

Recv-Q：接收缓冲区中还有多少数据；

Send-Q：发送缓冲区中还有多少数据没有发送；

Local Address：本次通信本地端的地址；（源端地址信息）

Foreign Address：对端地址信息；

State：状态；（LISTEN表示是一个监听套接字，没有对端的，只用来获取新建连接）（ESTABLISHED就绪状态，可以用来进行数据通信的状态，通信套接字有源

端地址信息和对端地址信息）（客户端的源端地址信息是服务端的对端地址信息）

PID/Program name：对应运行程序的名称。

这里显示的所有的信息不是网络通信进程信息，是每一个套接字的信息。





# 4.接口认识（tcp比dup多的几个接口）

![image-20230921010641421](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230921010641421.png)

## 4.1创建套接字

```c
int socket(int domain, int type, int protocol);
```

## 4.2绑定地址

```c
int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
```

## 4.3服务端开始监听

```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
int listen(int sockfd, int backlog);
```

作用：listen() 函数将给定的套接字 sockfd 标记为被动套接字，用于表示服务器端等待接受客户端连接请求。backlog 参数指定了套接字可以排队等待的最大连接数。

参数：

sockfd：需要标记为被动套接字的套接字描述符。（被监听的套接字）

backlog：等待连接队列的最大长度，即可以排队等待的最大连接数。（服务端能够在同一时间处理的最大连接数）

已完成连接队列的节点数量 = bakclog + 1；

返回值：成功返回0，失败返回-1，并设置全局变量errno。

注意点：

- isten() 函数通常在调用 bind() 函数绑定了套接字地址后使用，用于准备接受新的连接请求。
- 调用 listen() 后，套接字进入监听状态，等待客户端发起连接请求。
- backlog 参数指定了内核为该套接字维护的等待连接队列的最大长度。超过该值后，新的连接请求可能会被拒绝。
- 实际能够并发处理的连接数不仅取决于 backlog 的值，还受到系统资源限制和应用程序处理能力的影响。

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }
    
    // 设置套接字选项等...
    
    int backlog = 5;
    if (listen(sockfd, backlog) < 0) {
        perror("listen failed");
        exit(EXIT_FAILURE);
    }
    
    printf("Listening for incoming connections...\n");
    
    // 接受连接请求、处理客户端请求等...
    
    return 0;
}
```

以上示例代码创建了一个 TCP 套接字，然后调用 listen() 函数将该套接字标记为被动套接字，并设置等待连接队列的最大长度为 5。之后可以通过其他函数（如 accept()）来接受客户端的连接请求，并处理相应的业务逻辑。



### 4.3.1SYN泛洪攻击

SYN 泛洪攻击是一种常见的网络攻击方式，旨在通过发送大量伪造的 SYN 请求使目标服务器耗尽资源，导致服务不可用。下面是对 SYN 泛洪攻击的解释和常见防御方法：

1. 攻击原理：SYN 泛洪攻击利用 TCP 三次握手的过程中，向目标服务器发送大量伪造的 SYN 请求，但不完成后续的 ACK 阶段，从而导致服务器资源被占用。当服务器同时处理大量未完成的连接请求时，其资源（如 CPU、内存）会被耗尽，无法为正常请求提供响应。
2. 攻击过程：攻击者通过伪造源 IP 地址向目标服务器发送大量的 SYN 请求，目标服务器收到请求后会为每个请求创建一个追踪数据结构，并等待后续的 ACK 响应。然而，由于攻击者伪造的 IP 地址不存在或无法回复，服务器会一直等待超时，导致资源消耗过大。
3. 防御方法：
   - 防火墙配置：在网络边界的防火墙上设置规则，限制源地址的连接请求速率，过滤可能是伪造的 SYN 请求。
   - SYN Cookie 技术：服务器使用 SYN Cookie 算法来生成临时的 SYN-ACK 响应，而不会为每个 SYN 请求分配资源，从而避免资源耗尽。
   - 加大网络带宽和服务器处理能力：增加服务器的带宽和处理能力，可以减轻攻击对性能造成的影响。
   - 使用反向代理或负载均衡器：通过使用反向代理或负载均衡器将流量分发到多台服务器上，可以均衡负载，提高系统的容错能力。
   - IDS/IPS 系统：入侵检测/预防系统可以监测和拦截 SYN 泛洪攻击的流量。
   - 云服务提供商的 DDoS 防护：使用云服务提供商的 DDoS 防护服务，可以帮助过滤和缓解 SYN 泛洪攻击的影响。

需要注意的是，防御 SYN 泛洪攻击是一个综合性的任务，合理配置网络设备、优化服务器架构以及采取其他安全措施都是必要的。网络管理员和系统管理员应该密切关注网络安全，并根据实际情况采取相应的防御措施。

## 4.4客户端发送连接请求

```v
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
```

作用：connect() 函数用于建立与远程主机的连接。它通过给定的套接字描述符 sockfd，将该套接字连接到指定地址 addr。（服务端监听之后客户端才能发送连接请求，连接请求不到之后还会继续发，不是发送一次就结束的。）

参数：

sockfd：需要连接的套接字描述符。（描述符）

addr：指向目标主机的地址结构的指针，可以是 sockaddr、sockaddr_in 等类型的地址结构。（服务端地址信息）

addrlen：地址结构的长度。（地址长度）

返回值：成功返回0，失败返回-1，并设置全局变量errno。

注意点：

- 在调用 connect() 函数之前，需要先创建一个套接字，并使用 bind() 函数（对于服务器端）或者不使用 bind() 函数（对于客户端）为套接字绑定地址。
- 参数 addr 和 addrlen 指定了远程主机的地址信息。具体传递的地址结构类型和长度由套接字的域类型决定（如 AF_INET 对应 sockaddr_in 结构）。
- connect() 函数通常用于客户端，在客户端中，我们会创建一个套接字，并使用 connect() 将套接字连接到服务器端的地址。
- 在 connect() 函数调用成功后，套接字就可以用来进行数据的发送和接收操作了。
- connect() 函数会阻塞等待直到连接建立成功或出错。连接成功后，才能进行后续的数据传输操作。

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);  // 服务器端口号
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  // 服务器 IP 地址

    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("connect failed");
        exit(EXIT_FAILURE);
    }

    printf("Connected to the server!\n");

    // 进行数据传输操作...

    return 0;
}
```

以上示例代码创建了一个 TCP 套接字，然后使用 connect() 函数将该套接字连接到指定的服务器地址（IP 地址为 127.0.0.1，端口号为 8080）。如果 connect() 函数调用成功，就表示与服务器建立了连接。接下来，可以使用该套接字进行数据的发送和接收操作。

## 4.5服务端获取新建连接

```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

作用：accept() 函数用于从监听套接字的等待连接队列中接受一个新的连接请求，并创建一个与客户端连接的新套接字。

参数：

sockfd：监听套接字描述符，即通过调用 bind() 和 listen() 函数之后用于监听连接请求的套接字。（监听套接字，服务端最早创建的套接字，只用于获取新建连接，不用于通信的）

addr：指向用于存储客户端地址信息的结构体指针。在函数调用成功后，该指针所指的结构体会被填充为客户端的地址信息。（新的连接的客户端地址信息）

addrlen：指向表示客户端地址长度的变量的指针。在函数调用成功后，该变量会被赋值为客户端地址的实际长度。（输入输出参数，指定地址信息长度，以及返回实际长度）

不获取的实际地址长度的话：addr给NULL，addrlen给0。

返回值：成功返回一个新的套接字描述符（往后与客户端的通信都通过这个描述符完成），该套接字与客户端的连接建立成功，失败返回-1，并设置全局变量errno查看上一次系统调用错误的信息（原因）。

注意事项：

- accept() 函数通常用于服务器端，用于接受客户端的连接请求并建立与客户端的连接。
- 在调用 accept() 之前，需要先通过调用 socket()、bind() 和 listen() 函数来创建并监听套接字。
- accept() 函数会一直阻塞等待，直到有客户端连接请求到达。一旦有连接请求到达，accept() 函数会返回一个全新的套接字描述符，该描述符用于与客户端进行数据的收发操作。原始的监听套接字可以继续用来接受其他连接请求。
- accept() 函数也可以通过设置非阻塞套接字来进行非阻塞式的调用，此时不会阻塞等待连接请求到达，而是立即返回，如果没有连接请求到达，则返回 -1 并设置 errno 为 EAGAIN 或 EWOULDBLOCK。
- 参数 addr 和 addrlen 用于获取客户端的地址信息。可以使用 sockaddr、sockaddr_in 等类型的地址结构来存储客户端地址信息。在函数调用成功后，相关的地址信息会被填充到对应的结构体中。

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);  // 服务器端口号
    server_addr.sin_addr.s_addr = INADDR_ANY;  // 监听所有网络接口

    if (bind(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    if (listen(sockfd, 5) < 0) {
        perror("listen failed");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in client_addr;
    socklen_t client_addrlen = sizeof(client_addr);

    int newsockfd = accept(sockfd, (struct sockaddr*)&client_addr, &client_addrlen);
    if (newsockfd < 0) {
        perror("accept failed");
        exit(EXIT_FAILURE);
    }

    printf("Accepted a new connection from: %s\n", inet_ntoa(client_addr.sin_addr));

    // 进行数据传输操作...

    return 0;
}
```

以上示例代码创建一个 TCP 套接字，然后使用 bind() 函数将其绑定到指定的地址（端口号为 8080，监听所有网络接口）。接下来，使用 listen() 函数开始监听连接请求。一旦有客户端连接请求到达，accept() 函数会接受该请求，并返回一个新的套接字描述符（newsockfd）用于与客户端进行数据收发操作。在 accept() 调用成功后，可以使用 newsockfd 来与客户端进行通信。

## 4.6发送数据

```c
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
```

作用：用于通过指定的套接字发送数据。

参数：

sockfd：套接字描述符，即要发送数据的套接字。（描述符）

buf：指向要发送数据的缓冲区的指针。（要发送的数据）

len：要发送的数据的长度，以字节为单位。（数据长度）

flags：发送操作的可选标志，可以是0或以下常量的按位或（使用|操作符）的组合。（0） 

- MSG_CONFIRM：请求发送数据时进行确认。
- MSG_DONTROUTE：不要尝试路由，直接发送。
- MSG_DONTWAIT：非阻塞发送。
- MSG_EOR：表示消息的结束。
- MSG_MORE：还有更多的数据要发送。
- MSG_NOSIGNAL：忽略 SIGPIPE 信号，如果发送的对端已经关闭连接，则返回 EPIPE 错误。
- MSG_OOB：发送紧急（带外）数据。

返回值：成功返回实际发送的字节数，可能小于len（tcp），失败返回-1，并设置全局变量errno，用于查看上一次系统调用接口的错误信息。（连接断开会触发

异常）

注意事项：

- send() 函数通常用于客户端或服务器端，用于将数据发送给连接的对端。
- 在调用 send() 函数之前，需要先通过 socket() 和 connect() 或 bind()、listen()、accept() 等函数来创建并建立与对端的连接。
- send() 函数会将 buf 指向的数据发送给指定的套接字。
- len 参数指定要发送的数据的长度，以字节为单位。
- flags 参数用于指定发送操作的可选标志。可以使用 0 表示无特殊标志，或者使用上述常量的按位或的组合来设置多个标志。
- send() 函数可能会阻塞等待直到所有数据都发送完成（默认情况下），除非使用 MSG_DONTWAIT 标志来设置非阻塞发送。
- 返回值表示实际成功发送的字节数，可能小于 len。如果返回 -1，则表示发送失败，可以通过 errno 变量来获取失败的原因。



tcp是字节流传输，可以传输一半，udp是数据报传输，只能传输全部，要么不传输。

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <string.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);  // 服务器端口号
    server_addr.sin_addr.s_addr = INADDR_ANY;  // 监听所有网络接口

    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("connection failed");
        exit(EXIT_FAILURE);
    }

    const char* message = "Hello, server!";  // 要发送的消息
    ssize_t bytes_sent = send(sockfd, message, strlen(message), 0);
    if (bytes_sent < 0) {
        perror("send failed");
        exit(EXIT_FAILURE);
    }

    printf("Sent %zd bytes to the server\n", bytes_sent);

    close(sockfd);

    return 0;
}
```

以上示例代码创建了一个 TCP 套接字，并使用 connect() 函数与服务器建立连接。然后，通过调用 send() 函数将消息发送给服务器。在执行 send() 函数时，需要传递要发送的数据的指针（buf）、数据的长度（len）和可选的标志（flags）。如果 send() 函数返回的值小于 0，则说明发送失败，可以通过 perror() 函数打印出错误信息。最后，通过调用 close() 函数关闭套接字。

## 4.7接收数据

```c
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
```

作用：用于从指定的套接字接收数据。

参数：

sockfd：套接字描述符，即要接收数据的套接字。（描述符）

buf：指向接收数据的缓冲区的指针。（空间地址）

len：要接收的数据的长度，以字节为单位。（要接收的数据长度）

flags：接收操作的可选标志，可以是 0 或以下常量的按位或（使用 | 运算符）的组合：（0）

- MSG_DONTWAIT：非阻塞接收。
- MSG_OOB：接收紧急（带外）数据。
- MSG_PEEK：预览下一个消息，但不从输入队列中删除该消息。

返回值：成功返回实际接收的字节数，如果没有可用的数据或对方已关闭连接，则返回0，发生错误返回-1，并设置全局变量errno，来查看错误原因。

注意事项：

- ecv() 函数通常用于客户端或服务器端，用于从连接的对端接收数据。
- 在调用 recv() 函数之前，需要先通过 socket() 和 connect() 或 bind()、listen()、accept() 等函数来创建并建立与对端的连接。
- recv() 函数会将接收到的数据存储在 buf 指向的缓冲区中，len 参数指定要接收的数据的长度，以字节为单位。
- flags 参数用于指定接收操作的可选标志。可以使用 0 表示无特殊标志，或者使用上述常量的按位或的组合来设置多个标志。
- recv() 函数可能会阻塞等待直到接收到足够的数据（默认情况下），除非使用 MSG_DONTWAIT 标志来设置非阻塞接收。
- 返回值表示实际成功接收的字节数，如果返回 0，则表示对端已经关闭连接，否则可以通过 errno 变量来获取失败的原因。

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <string.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);  // 服务器端口号
    server_addr.sin_addr.s_addr = INADDR_ANY;  // 监听所有网络接口

    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("connection failed");
        exit(EXIT_FAILURE);
    }

    char buffer[1024] = {0};  // 接收缓冲区
    ssize_t bytes_received = recv(sockfd, buffer, sizeof(buffer), 0);
    if (bytes_received < 0) {
        perror("receive failed");
        exit(EXIT_FAILURE);
    }

    printf("Received %zd bytes from the server: %s\n", bytes_received, buffer);

    close(sockfd);

    return 0;
}
```

以上示例代码创建了一个 TCP 套接字，并使用 connect() 函数与服务器建立连接。然后，通过调用 recv() 函数从服务器接收消息。在执行 recv() 函数时，需要传递一个接收缓冲区的指针（buf）、接收数据的长度（len）和可选的标志（flags）。如果 recv() 函数返回的值小于等于 0，则说明接收失败或对端已经关闭连接，可以通过 perror() 函数打印出错误信息。最后，通过调用 close() 函数关闭套接字。



注意点：tcp通信因为socket结构中包含完整五元组因此不需要指定地址。

## 4.8关闭套接字

```c
int close(int fd);
```



## 4.9综合使用（tcp）

```c++
//文件名：tecpsocket.hpp
#include <cstdio>
#include <iostream>
#include <string>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <unistd.h>

#define LISTEN_BACKLOG 5
#define CHECK_RET(q) if((q) == false){return -1;}

class TcpSocket
{
    private:
        int _sockfd;        //操作句柄

    public:
        TcpSocket()
            :_sockfd(-1)
        {
            
        }

        //创建套接字
        bool Socket()
        {
            //tcp提供的是字节流传输服务，需要使用流式套接字SOCK_STREAM
            _sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if(_sockfd < 0)
            {
                //创建失败
                perror("socket error");
                return false;
            }
            return true;
        }

        //绑定地址信息
        bool Bind(const std::string &ip, const uint16_t port)
        {
            struct sockaddr_in addr;
            addr.sin_family = AF_INET;
            addr.sin_port = htons(port);
            addr.sin_addr.s_addr = inet_addr(ip.c_str());       //返回字符串的首地址，和下面取字符串的首元素的地址一样
            //addr.sin_addr.s_addr = inet_addr(&ip[0]);
            socklen_t len = sizeof(sockaddr_in);
            int ret = bind(_sockfd, (sockaddr*)&addr, len);
            if(ret < 0)
            {
                perror("bind error");
                return false;
            }
            return true;
        }

        //切换到监听状态
        bool Listen(int backlog = LISTEN_BACKLOG)
        {
            //listen(描述符, 同一时间连接数);
            int ret = listen(_sockfd, backlog);
            if(ret < 0)
            {
                perror("listen error");
                return false;
            }
            return true;
        }

        //连接服务器
        bool Connect(const std::string &ip, const int port)
        {
            struct sockaddr_in addr;
            addr.sin_family = AF_INET;
            addr.sin_port = htons(port);
            addr.sin_addr.s_addr = inet_addr(ip.c_str());       //返回字符串的首地址，和下面取字符串的首元素的地址一样
            //addr.sin_addr.s_addr = inet_addr(&ip[0]);
            socklen_t len = sizeof(sockaddr_in);
            //connect(描述符, 服务端地址, 地址长度);
            int ret = connect(_sockfd, (sockaddr*)&addr, len);
            if(ret < 0)
            {
                perror("connect error");
                return false;
            }
            return true;
        }

        //服务端获取新连接
        bool Accept(TcpSocket* sock, std::string *ip = NULL, uint16_t* port = NULL)
        {
            //原来的套接字是监听套接字，新创建的套接字是通信套接字
            //int accept(监听套接字, 回去客户端地址, 长度);
            sockaddr_in addr;
            socklen_t len = sizeof(sockaddr_in);
            int newfd = accept(_sockfd, (sockaddr*)&addr, &len);
            if(newfd < 0)
            {
                perror("accept error");
                return false;
            }

            sock->_sockfd = newfd;
            if(ip != NULL)
            {
                *ip = inet_ntoa(addr.sin_addr);
            }

            if(port != NULL)
            {
                *port = ntohs(addr.sin_port);
            }
            return true;
        }

        //接收数据
        bool Recv(std::string *buf)
        {
            //int recv(描述符, 空间, 数据长度, 标志位);     标志位给0是默认阻塞接收
            //返回值：实际获取大小  返回值是0不是没有接收数据，是连接断开了     -1是出错了
            char tmp[4096] = {0};       
            int ret = recv(_sockfd, tmp, 4096, 0);
            if(ret < 0)
            {
                //出错
                perror("recv error");
                return false;
            }
            else if(ret == 0)
            {
                //连接断开
                perror("peer shutdown");
                return false;
            }
            buf->assign(tmp, ret);      //拷贝字符串，参数是字符串首地址和字符串长度。
            return true;
        }

        //发送数据
        bool Send(const std::string &data)
        {
            //int send(描述符, 数据, 长度, 标志位);         标志位为0表示阻塞发送
            int total = 0;      //记录发送了多少数据
            
            while(total < data.size())
            {
                //发送数据一般不是一次性发送的，一般是多次发送，从上一次
                int ret = send(_sockfd, data.c_str() + total,  data.size() - total, 0);
                //int ret = send(_sockfd, &data[0] + total, data.size() - total, 0);      //和上面作用一样
                if(ret < 0)
                {
                    perror("send error");
                    return false;
                }
                total += ret;
            }
            return true;
        }

        bool Close()
        {
            if(_sockfd != -1)
            {
                close(_sockfd);
            }
            return true;
        }
};
```

```c++
//文件名：tcp_srv.cpp
#include "tcpsocket.hpp"

//服务端
int main(int argc, char* argv[])
{
    //通过程序运行参数指定服务端要绑定的地址
    //  ./tcp_rev 192.168.0.203(IP地址) 9000(端口号)
    if(argc != 3)
    {
        //参数包含文件名本身，如果不是3，就是传参错误
        printf("usage：./tep_rev 192.168.0.203 9000\n");
        return -1;
    }

    std::string srvip = argv[1];
    uint16_t srvport = std::stoi(argv[2]);  //stoi是将字符串转换为整数类型
    TcpSocket lst_lock;     //监听套接字
    //1.创建套接字
    CHECK_RET(lst_lock.Socket());
    //2.绑定地址信息
    CHECK_RET(lst_lock.Bind(srvip, srvport));
    //3.开始监听
    CHECK_RET(lst_lock.Listen());
    while(1)
    {
        //4.获取新建连接
        TcpSocket cli_sock;
        std::string cli_ip;
        uint16_t cli_port;
        bool ret = lst_lock.Accept(&cli_sock, &cli_ip, &cli_port);
        if(ret == false)
        {
            continue;
        }

        std::cout << "get newconn" << cli_ip << "-" << cli_port << "\n";
        //5.收发数据    使用获取的新建套接字进行通信
        std::string buf;
        ret = cli_sock.Recv(&buf);
        if(ret == false)
        {
            cli_sock.Close();
            continue;
        }
        std::cout << "client say: " << buf << std::endl;

        buf.clear();
        std::cout << "server say: ";
        std::cin >> buf;
        ret = cli_sock.Send(buf);

        if(ret == false)
        {
            cli_sock.Close();
        }
    }
    //6.关闭套接字
    lst_lock.Close();
    return 0;
}
```

```c++
//文件名：tcp_cli.cpp
#include "tcpsocket.hpp"

//客户端
int main(int argc, char* argv[])
{
    //客户端可以不绑定地址信息，但是必须知道服务端的地址信息
    if(argc != 3)
    {
        printf("usage：./tcp_cli srv_ip srv_port\n");
        return -1;
    }

    std::string srv_ip = argv[1];
    uint16_t srv_port = std::stoi(argv[2]);

    TcpSocket cli_sock;
    //1.创建套接字
    CHECK_RET(cli_sock.Socket());
    //2.绑定地址信息（不推荐绑定）
    //3.向服务端发起连接
    CHECK_RET(cli_sock.Connect(srv_ip, srv_port));
    while(1)
    {
        //4.收发数据
        std::string buf;
        std::cout << "client say: ";
        std::cin >> buf;
        //客户端向服务端发送数据，客户端出问题直接退出，服务端接收出问题不能直接退出，还要接收下一个客户端
        CHECK_RET(cli_sock.Send(buf));
        //接收数据
        //清空缓冲区
        buf.clear();
        CHECK_RET(cli_sock.Recv(&buf));
        std::cout << "server say: " << buf << std::endl;
    }
    //5.关闭套接字
    CHECK_RET(cli_sock.Close());
    return 0;
}
```





![](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230924051357925.png)

解释连接是好的，但为啥不可以继续通信：

服务端的流程：

1.创建套接字；

2.绑定地址信息；

3.开始监听；

while(1)

{

​	4.获取新建连接；（是一个阻塞接口，如果有新建连接就获取，没有新建连接就阻塞等待）

​	5.使用新连接接收数据；（阻塞接口）

​	6.使用新连接发送数据；（阻塞接口）

}

7.关闭监听套接字；

原因：accept、recv以及send都是阻塞接口，任意一个接口的调用，都有可能会导致服务端流程阻塞。

本质原因：当前的服务端，因为不知道什么时候有新连接到来，什么时候哪个客户端有数据到来，因此流程只能固定的去调用接口，但是这种调用方式有可能会造

成阻塞。

要是把第4步获取新建连接放在循环外面会导致一直在于一个客户端进行通信，就无法与其他的客户端进行通信了。

解决办法：多执行流并发操作。（多线程和多进程都可以）

获取新建连接可能会导致阻塞，与某一个客户端进行通信也可能会导致阻塞，这个时候想法就是创建多执行流让一个执行流负责与一个客户端的通信，有多少个客

户端就有多少个执行流，这些执行流单独负责某一个客户端的通信操作，就算某一个客户端阻塞了也是阻塞的是当前的执行流，不会影响到其他的执行流。

解决方案：多执行流并发处理。（为每个客户端都创建一个执行流负责与这个客户端进行通信。）

好处：

1.主线程卡在获取新建连接这里，但是不影响客户端的通信；

2.某个客户端的通信阻塞，也不会影响主线程以及其他线程，影响的只是当前线程；

在主线程中，获取新建连接，一旦获取到了则创建一个执行流，通过这个新建连接与客户端进行通信。

多线程：普通线程与主线程数据共享，指定入口函数执行。

主线程不能随意释放套接字，因为资源共享，一旦释放其他线程无法使用。

多进程：子进程复制了父进程，但是数据独有。

1.注意僵尸进程的处理；

2.注意父子进程数据各自独有，父进程用不到新建套接字，因此创建子进程之后直接释放掉，否则会造成资源泄漏。

```shell
#将一个目录下的文件全部拷贝到一个空目录（目录）中
cp -r ./TCP/* process_TCP/ 
```

第一种方法：多线程；（只修改服务端代码）

```cpp
#include "tcpsocket.hpp"
#include <pthread.h>

void *thr_entry(void* arg)
{
    bool ret;
    TcpSocket* cli_sock = (TcpSocket*)arg;
    while(1)
    {
        //5.收发数据    使用获取的新建套接字进行通信
        std::string buf;
        ret = cli_sock->Recv(&buf);
        if(ret == false)
        {
            cli_sock->Close();
            delete cli_sock;
            return NULL;
        }
        std::cout << "client say: " << buf << std::endl;

        buf.clear();
        std::cout << "server say: ";
        std::cin >> buf;
        ret = cli_sock->Send(buf);

        if(ret == false)
        {
            cli_sock->Close();
            delete cli_sock;
            return NULL;
        }
    }
    cli_sock->Close();
    delete cli_sock;
    return NULL;
}

//服务端
int main(int argc, char* argv[])
{
    //通过程序运行参数指定服务端要绑定的地址
    //  ./tcp_rev 192.168.0.203(IP地址) 9000(端口号)
    if(argc != 3)
    {
        //参数包含文件名本身，如果不是3，就是传参错误
        printf("usage：./tep_rev 192.168.0.203 9000\n");
        return -1;
    }

    std::string srvip = argv[1];
    uint16_t srvport = std::stoi(argv[2]);  //stoi是将字符串转换为整数类型
    TcpSocket lst_lock;     //监听套接字
    //1.创建套接字
    CHECK_RET(lst_lock.Socket());
    //2.绑定地址信息
    CHECK_RET(lst_lock.Bind(srvip, srvport));
    //3.开始监听
    CHECK_RET(lst_lock.Listen());
    while(1)
    {
        //4.获取新建连接
        TcpSocket* cli_sock = new TcpSocket();
        std::string cli_ip;
        uint16_t cli_port;
        bool ret = lst_lock.Accept(cli_sock, &cli_ip, &cli_port);
        if(ret == false)
        {
            continue;
        }

        std::cout << "get newconn" << cli_ip << "-" << cli_port << "\n";
        //创建线程专门负责与指定客户端的通信
        pthread_t tid;
        pthread_create(&tid, NULL, thr_entry, (void*)cli_sock);
        pthread_detach(tid);    //分离线程，之后就不用关心了
    }
    //6.关闭套接字
    lst_lock.Close();
    return 0;
}
```



第二种解决方法：多进程（只修改服务端代码）

```c++
#include "tcpsocket.hpp"
#include <signal.h>
#include <sys/wait.h>

void sigcb(int no)
{
    //等待任意一个子进程退出，非阻塞处理所有的线程
    //返回值：大于0表示有子进程退出，等于0表示没有子进程退出，小于0表示出错了
    //在一次退出重处理所有子进程
    while(waitpid(-1, NULL, WNOHANG) > 0);
}   

//服务端
int main(int argc, char* argv[])
{
    //通过程序运行参数指定服务端要绑定的地址
    //  ./tcp_rev 192.168.0.203(IP地址) 9000(端口号)
    if(argc != 3)
    {
        //参数包含文件名本身，如果不是3，就是传参错误
        printf("usage：./tep_rev 192.168.0.203 9000\n");
        return -1;
    }

    //方法1：信号忽略，忽略SIGCHLD信号，告诉父进程子进程退出了直接释放资源，子进程不会直接成为僵尸进程
    signal(SIGCHLD, SIG_IGN);

    //方法2：使用回调函数也可以
    //signal(SIGCHLD, sigcb);

    std::string srvip = argv[1];
    uint16_t srvport = std::stoi(argv[2]);  //stoi是将字符串转换为整数类型
    TcpSocket lst_lock;     //监听套接字
    //1.创建套接字
    CHECK_RET(lst_lock.Socket());
    //2.绑定地址信息
    CHECK_RET(lst_lock.Bind(srvip, srvport));
    //3.开始监听
    CHECK_RET(lst_lock.Listen());
    while(1)
    {
        //4.获取新建连接
        TcpSocket cli_sock;
        std::string cli_ip;
        uint16_t cli_port;
        bool ret = lst_lock.Accept(&cli_sock, &cli_ip, &cli_port);
        if(ret == false)
        {
            continue;
        }

        std::cout << "get newconn" << cli_ip << "-" << cli_port << "\n";
        
        //创建进程  父子进程数据各有一份，互不影响
        pid_t pid = fork();
        if(pid < 0)
        {
            //创建进程失败，出错了，上去重新处理下一个
            cli_sock.Close();
            continue;
        }
        else if(pid == 0)
        {
            //子进程
            while(1)
            {
                //5.收发数据    使用获取的新建套接字进行通信
                std::string buf;
                ret = cli_sock.Recv(&buf);
                if(ret == false)
                {
                    cli_sock.Close();
                    continue;
                }
                
                std::cout << "client say: " << buf << std::endl;

                buf.clear();
                std::cout << "server say: ";
                std::cin >> buf;
                ret = cli_sock.Send(buf);

                if(ret == false)
                {
                    cli_sock.Close();
                    exit(0);
                }      
            }
            //子进程不用等待直接退出
            cli_sock.Close();   //释放的是子进程中的cli_sock
            exit(0);        
        } 
        //进程等待
        cli_sock.Close();   //释放的是父进程中的cli_sock，父进程的cli_sock有多个，关闭不会对子进程造成影响
        //父子进程数据独有，父进程关闭不会对子进程造成影响，不关闭会造成资源泄漏
    }

    //6.关闭套接字
    lst_lock.Close();
    return 0;
}
```



# 7.总结

套接字编程：网络通信程序的编写。

udp通信程序的编写、tcp通信程序的编写。

udp协议与tcp协议的区别：

udp：用户数据报协议，无连接、不可靠、面向数据报。

应用：传输实时性要求高于安全性的场景，比如视频传输，可以允许丢包。（udp速度更快、实时性更高，udp不保证数据有序）

tcp：传输控制协议，面向连接、可靠传输、面向字节流。

应用：安全性要求高于实时性的场景，比如文件传输。（tcp数据有序，每个数据都有一个编号，传输到之后根据编号排序）



网络通信是两端主机的通信：

客户端：发送请求的一端，主动发起请求的一端。

服务端：提供服务的一端，被动接受请求的一端。

服务端收到客户端的请求，服务端就会知道客户端的IP，这个时候服务端是可以给客户端发送信息的，但是服务端和客户端的身份不会发生改变，因为客户端和服

务端是根据功能决定的，主动和被动是在代码上体现的。



udp通信流程：

server：

1.创建套接字，在内核中创建socket结构；

2.为套接字绑定地址信息：给创建的socket结构中添加ip + port；

2.1描述发送数据的源端地址信息；

2.2告诉系统收到的哪些数据应该放到这个socket的接收缓冲区中；

3.接收数据，从接收缓冲区取出数据；

4.发送数据，将数据放到发送缓冲区；

5.关闭套接字，释放资源。



client：

1.创建套接字；

2.绑定地址信息：客户端不推荐主动绑定；（但是可以绑定，比如安全性比较高的场景，像银行这种，设置防火墙的白名单，防止黑客攻击，限制发送方的地址信

息，这个时候客户端必须使用指定的地址和端口发送信息）

3.发送数据：发送数据时若套接字没有绑定地址信息，则会选择合适地址信息进行绑定。

4.接收数据；

5.关闭套接字。



接口介绍：

socket

bind

sendto

recvfrom

close

htonl

ntohl

inet_addr

inet_ntoa

struct sockaddr{sin_family,sin_port,sin_addr.s_addr};



udp：

服务端：创建套接字，绑定地址信息，接收数据，发送数据，关闭套接字。

客户端：创建套接字，发送数据，接收数据，关闭套接字。

tcp：

服务端：创建套接字，绑定地址信息，开始监听、获取新建套接字的描述符（tcp具有五元组，不需要发送和接收指定IP地址和端口）、收发数据、关闭套接字。

客户端：创建套接字、向服务端发起请求连接、收发数据、关闭套接字。



结构体：

```c
struct sockaddr 
{
    sa_family_t sa_family;		//2个字节
    char sa_data[14];
}
```

```c
//ipv4结构体
struct sockaddr_in
{
    sin_family;
    sin_port;
    sin_addr.s_addr;
    sin zero[];
}
//通信的时候只需要使用前三个成员，剩下的补位和sockaddr一样
```

```c
struct sockaddr_in addr;
len = sizeof(struct sockaddr_in);
bind((struct sockaddr*)&addr);		//sockaddr_in强转为sockaddr
```

```shell
vim /usr/include/netinet/in.h		#查看结构体
```

```c
//ipv6结构体
struct in6_addr
{
    union
    {
        uint8_t __u6_addr8[16];
        uint16_t __u6_addr16[8];
        uint32_t __u6_addr32[4];
    }__in6_u;
#define s6_addr         __in6_u.__u6_addr8
#ifdef __USE_MISC
# define s6_addr16      __in6_u.__u6_addr16
# define s6_addr32      __in6_u.__u6_addr32
#endif
};
```



套接字编程：

tcp通信程序的编写：

通信流程：创建套接字、绑定地址信息、开始监听、获取新建连接、使用新建连接与客户端进行通信、关闭套接字

客户端：创建套接字、向服务端发起连接、收发数据、关闭套接字。

存在问题：客户端只能与一个客户端通信一次。

本质原因：在没有新连接到来时accept阻塞，没数据时recv阻塞。

解决方案：多执行流并发处理。

在服务端accept获取新连接之后创建一个新的执行流与客户端进行通信。

多进程：1.僵尸进程的处理；	2.父子进程数据独有，释放父进程描述符；

多线程：1.线程之间共享资源（文件描述符表）

























