# 1.本节目标

复习C文件IO相关操作
认识文件相关系统调用接口
认识文件描述符,理解重定向
对比fd和FILE，理解系统调用和库函数的关系
理解文件系统中inode的概念
认识软硬链接，对比区别
认识动态静态库，学会结合gcc选项，制作动静态库  



基础IO：回顾IO库函数接口，学习系统调用IO接口，探讨IO操作句柄，重定向实现、文件系统的了解、动态库与静态的生成与使用。



# 2.回顾库函数IO接口

头文件：#include <stdio.h>

## 2.1fopen

```c
FILE *fopen(const char *pathname, const char *mode);
```

参数：pathname：要打开的文件路径名称		mode："r"   "r+"    "w"    "w+"    "a"   "a+"    "b"  

r：只读				r+：可读可写					

w：只写，文件不存在则创建新文件，文件存在清空文件内容			w+：可读可写，文件不存在则创建新文件，文件存在清空文件内容

a：追加只写，总是将数据写入文件末尾，文件不存在则创建新文件，文件存在不清空文件内容

a+：读和追加写，打开文件后从起始读，但是写总是在末尾，不存在则创建新文件，文件存在不清空文件内容

b：对文件数据进行二进制操作

返回值：失败返回NULL，成功返回一个文件流指针FILE*，通过这个指针就可以找到对应的文件，并且这个文件中记录了当前这个文件读写到哪个位置了、继续读

写应该从哪读，记录了很多描述信息。



## 2.2fwrite

```c
size_t fwrite(const void *ptr, size_t size, size_t nmemb,FILE *stream);
```

ptr：要写入文件的数据的空间地址				size：块大小			nmemb：块个数（size和nmemb的乘积是写入文件的数据总长度）

stream：操作句柄（fopen返回的文件流指针）		

返回值：

成功返回实际写入文件的块个数（完整的写入的快个数，不一定是nmemb，nmemb是理论上写入的块个数）（返回的是完整写入的块个数）

失败返回0



## 2.3fread

```c
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
```

ptr：一块缓冲区内存空间的地址，用于存放读取的数据			size：块大小			nmemb：块个数（size和nmemb的乘积是从文件读取的数据总长度）			

stream：操作句柄（fopen返回的文件流指针）

返回值：

成功返回读取到完整块个数。

出错返回0，文件读取到文件末尾返回0，读取的数据不足一块也返回0。（建议：块大小为1，块个数为操作的数据长度，这样更加明确读到的数据大小，否则

不按照这个建议读取一块数据50字节，但是实际只读取了40字节的时候也会返回0，通过返回值无法确定是否已经读取到的数据）

fread()不区分文件结束和错误，调用者必须使用feof(3)和error(3)来确定哪个发生了。



```c
int feof(FILE *stream);
```

返回值：

如果文件流已经到达文件末尾，则返回非零值（通常是1）。

如果文件流尚未到达文件末尾或发生了错误，则返回0。



```c
#include <error.h>
void error(int status, int errnum, const char *format, ...);
```





## 2.4fclose

```c
int fclose(FILE *stream);		//关闭文件，释放资源
```

`stream`：指向要关闭的文件流的指针。

返回值：

如果关闭文件流成功，则返回0。

如果关闭文件流失败，则返回非零值。（一般不会）



## 2.5fseek

```c
int fseek(FILE *stream, long offset, int whence);			//跳转文件读写位置
```

stream：操作句柄，打开文件返回的文件流指针

offset：相对起点开始偏移量，是一个数字，正数向文件末尾跳转，负数向文件头部跳转

whence：相对起点（SEEK_SET：起始位置		SEEK_CUR：当前位置		SEEK_END：末尾位置）

返回值：成功返回0，失败返回-1



## 2.6ftell

```c
long ftell(FILE *stream);
```





## 2.7rewind

```c
void rewind(FILE *stream);
```





## 2.8fgetpos

```c
int fgetpos(FILE *stream, fpos_t *pos);
```





## 2.9fsetpos

```c
int fsetpos(FILE *stream, const fpos_t *pos);
```





## 2.10综合使用

```c
//文件名：review.c
#include <stdio.h>
#include <string.h>

int main()
{
    //fopen(文件路径名,打开方式);
    FILE* fp = fopen("./test.txt","w+");
    
    //文件打开失败
    if(fp == NULL)
    {
        //perror是上一次使用的系统调用接口的错误，fopen是库函数，库函数封装了系统调用接口，库函数会调用系统调用接口。
        //库函数 = 系统调用接口 + 其他
        //一个库函数使用的系统调用接口有的时候不止一个，是多个系统调用接口
        perror("fopen error");      //perror对于库函数可以使用，但不要迷信
        return -1;
    }

    //fseek(fp, -10, SEEK_SET);  ok
    fseek(fp, 10, SEEK_END);            //ok

    char* ptr = "今天的天气好晴朗！\n";

    //fwrite(空间地址, 大小, 个数,  句柄);
    int ret = fwrite(ptr, strlen(ptr), 1, fp);
    if(ret == 0)
    {
        perror("fwrite error");
        return -1;
    }

    printf("ret:%d\n",ret);

    //跳转读写位置
    //fseek(句柄, 偏移量, 相对起点);
    fseek(fp, 0, SEEK_SET);

    char buf[1024] = {0};

    ret = fread(buf, 1, 1023, fp);  

    if(ret == 0)
    {
        printf("没有读取到数据\n");
    }

    printf("buf:%s ----- %d\n", buf + 10, ret);


    //printf("%ld\n",strlen(buf));

    fclose(fp);
    return 0;
}

//总结：无论如何偏移都可以写入数据
```



# 3.系统调用IO接口

## 3.1open

```c
int open(const char *pathname, int flags, mode_t mode);
```

pathname：文件路径名。

flags：标志位

必选其一：O_RDONLY（只读）、O_WRONLY（只写）、O_RDWR（可读可写）（只能选一个，不能同时使用）

可选项：

​	O_CREAT：如果文件不存在则创建，如果存在直接打开

​	O_EXCL：跟O_CREAT一起使用的，如果文件已经存在报错返回

​	O_TRUNC：打开文件时截断文件长度为0（情况;内容）

​	O_APPEND：将写入设置为追加写

用法：用哪个就使用二进制或操作

w+：O_RDWR | O_CREAT | O_TRUNC;

a+：O_RDWR | O_CREAT | O_ADDEND;

mode：文件的权限设置，0777（八进制），如果使用了O_CREAT就一定要指定。（没有O_CREAT，第三个参数顶多是忽略，不会报错的）

文件的实际权限 = mode & ~umask 

```shell
man 2 umask						#查看系统调用接口umask
mode_t umask(mode_t mask);		#系统调用接口，将当前进程的文件权限掩码设置为0，避免open中设置的权限受到影响（只对当前进程生效）（一般有文件操作的时候 会在文件创建之前声明当前进程权限掩码为0）
```

返回值：

成功返回非负整数，是文件的操作句柄，这个操作句柄称之为文件描述符。

失败返回-1。

​	![image-20230815145237739](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230815145237739.png)![image-20230815145250230](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230815145250230.png)



## 3.2write

```c
ssize_t write(int fd, const void *buf, size_t count);
```

fd：open返回的操作句柄，用于明确操作的是哪个打开的文件。

buf：要写入的数据。

count：要写入数据的长度。

返回值：

成功返回实际写入文件的数据长度。

失败返回-1。



## 3.3read

```c
ssize_t read(int fd, void *buf, size_t count);
```

fd：open返回的操作句柄，用于明确操作的是哪个打开的文件。

buf：存放读取到的数据的缓冲区。

count：要读取的数据长度。

返回值：

成功返回实际读取到的数据长度。（没有读到数据算成功读取，返回0）

失败返回-1。



## 3.4lseek

```c
off_t lseek(int fd, off_t offset, int whence);
```

fd：open返回的操作句柄。

offset：偏移量。

whence：相对起始偏移位置。（文件开头：SEEK_SET		当前位置：SEEK_CUR		文件末尾：SEEK_END）

返回值：

成功返回：跳转后的位置，相对于文件起始位置的偏移量。

失败返回-1。



## 3.5close

```c
int close(int fd);
```



## 3.6综合使用

```c
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>

int main()
{
    umask(0);   //将当前进程的文件权限掩码设置为0
    //int open(文件名, 选项标志, 权限);
    int fd = open("test.txt", O_RDWR | O_CREAT | O_APPEND, 0777);
    if(fd < 0)
    {
        perror("open error");
        return -1;
    }

    char* ptr = "计算机科学与技术\n";
    
    //write(句柄, 数据, 长度);      返回实际写入的长度，失败了返回值是负数
    int ret = write(fd, ptr, strlen(ptr));
    
    if(ret < 0)
    {
        perror("write error");
        return -1;
    }

    //lseek(句柄, 偏移量, 相对位置);
    lseek(fd, 0, SEEK_SET);

    char buf[1024] = {0};
    ret = read(fd, buf, 1023);      //字符串最后一位是'\0'

    if(ret < 0)
    {
        perror("read error");
        return -1;
    }

    printf("%d ----- %s\n", ret, buf);


    close(fd);

    return 0;
}
```



库函数的IO接口和系统调用的IO接口，都是用于完成IO的。

那为啥还要封装库函数呢，接下来学习文件描述符本质上是个什么东西、在操作系统里面进行IO操作的时候和打开文件的时候都发生了什么事情、文件描述符和文

件流指针的区别（库函数和系统调用接口的区别）。



# 4.文件描述符

文件描述符：系统调用IO接口的操作句柄，是一个非负数。

```shell
fdisk -l			#用于列出系统上的所有磁盘和分区的信息
ls /dev				#dev上存储设备文件
df					#用于显示文件系统的磁盘空间使用情况
```

当您在终端中运行 `fdisk -l` 命令时，它会显示磁盘设备的详细列表，包括设备名称、分区表类型、起始扇区、结束扇区、总扇区数等信息。这些信息可以帮助您

了解系统上可用的磁盘和分区情况。

需要注意的是，运行 `fdisk -l` 命令需要具有超级用户（root）权限或者对应的授权。

![image-20230816061913295](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230816061913295.png)

在这个示例输出中，`/dev/sda` 是磁盘设备的名称。我们可以看到这个设备有两个分区：`/dev/sda1` 和 `/dev/sda2`。它们各自具有不同的起始扇区、结束扇区和总扇区数，并且显示了分区的文件系统类型（例如，Linux）和标识符（例如，83 表示 Linux 分区）。



![image-20230816064327374](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230816064327374.png)

![image-20230816065905334](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230816065905334.png)

文件描述符本质：内核中进程打开的文件描述信息表中的下标。



# 5.重定向原理(>> / >)

文件描述符表是一个数组，文件描述符的分配规则是最小未使用，每次分配的时候总会找到下标最小的未使用的位置，每次打开最小的是3，说明0,1,2被占用了。

三种文件：标准输入文件（fd = 0）、标准输出文件（fd = 1）、标准错误文件（fd = 2）。

一个程序运行起来以后默认会打开3个文件，就是上面的三种文件。



重定向（对文件描述符的重定向）：通过改变文件描述符这个下标位置保存的文件描述信息，进而改变这个描述符所操作的文件，实现改变数据的流向。

```c
int dup2(int oldfd, int newfd);			//明确重定向，让newfd从oldfd中拷贝文件描述信息地址，把newfd重定向到oldfd对应的文件上
```

```c
//文件名：redir.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

int main()
{
    int fd = open("test.txt", O_RDWR | O_CREAT, 0777);
    if(fd < 0)
    {
        perror("open error");
        return -1;
    }

    dup2(fd, 1);        //将标准输出重定向到test.txt

    printf("fd = %d\n", fd);

    return 0;
}
```



`redir` 是一个用于重定向网络流量的 Unix 命令行工具。它可以将输入或输出从一个来源（如标准输入、文件或套接字）重定向到另一个目标（如标准输出、文件或套接字）。

`redir` 的常见用途是在网络调试和测试中。通过使用 `redir`，您可以将网络流量从一个端口重定向到另一个端口，以便在不影响实际网络连接的情况下对流量进行捕获、修改或分析。

以下是 `redir` 命令的基本用法：

```
Copy Coderedir [options] <source> <destination>
```

其中，`<source>` 是要重定向的来源，可以是输入文件、套接字或标准输入；`<destination>` 是要重定向到的目标，可以是输出文件、套接字或标准输出。

`redir` 命令的一些常用选项包括：

- `-a`：以追加模式打开目标文件。
- `-b`：后台运行 `redir` 进程。
- `-c`：关闭 `redir` 进程的标准输入。
- `-d`：启用调试模式，输出详细的调试信息。
- `-e`：以非阻塞模式打开目标文件。
- `-L`：启用日志记录，将流量记录到指定文件中。

请注意，`redir` 是一个通用的工具，其具体行为和选项可能会因不同操作系统和版本而有所区别。因此，确保查阅相关文档或 `redir` 命令的手册页面以获取更准确的使用说明。

```shell
#要使用redir命令，需要先安装redir，redir不是操作系统默认安装的标准命令，需要手动安装。
sudo apt install redir			#Debian / Ubuntu
sudo dnf install redir			#Fedora / CentOS
```



文件描述符和文件流指针：

​	文件描述符：int，系统调用IO接口的操作句柄。

​	文件流指针：FILE*，库函数IO接口的操作句柄，是一个结构体，内部封装了一个成员，就是文件描述符。

库函数与系统调用接口的关系：库函数封装了系统调用接口。

通过库函数进行IO操作，最终是会归纳到使用系统调用接口完成IO操作。

```c
//文件名：stream.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main()
{
    FILE* fp = fopen("./test.txt", "rb+");

    if(fp == NULL)
    {
        perror("fopen error");
        return -1;
    }

    stdout->_fileno = fp->_fileno;
    printf("你好啊\n");     //输出到文件

    fp->_fileno = 1;        //标准输出的文件描述符

    char* ptr = "吃什么呢?\n";  
    fwrite(ptr, strlen(ptr), 1, fp);    //写入到显示器（终端）

    fclose(fp);

    return 0;
}
```

![image-20230816085707387](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230816085707387.png)

缓冲区对于系统调用接口是不存在的，缓冲区是文件流指针的缓冲区。

库函数IO与系统调用IO的区别：

缓冲区：通常所说的那个换行刷新缓冲区的这个缓冲区，是文件流指针所有的，对于文件描述符或者系统调用来说，是没有的。

文件流指针中的这个缓冲区被称之为用户态缓冲区。



文件描述信息表查看：

```shell
grep -R 'struct files_struct {' /usr/src/
vim /usr/src/linux-hwe-5.15-headers-5.15.0-78/include/linux/fdtable.h
```

![image-20230816200513852](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230816200513852.png)

![image-20230816200505740](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230816200505740.png)

files_struct结构体中中的fd_array就是文件描述信息表。（文件描述信息表是一个数组，描述符数量是有限的）





在我们自己实现的minishell中加入重定向功能：>> / >

1.捕捉键盘输入；

​	1.1解析重定向（判断有没有>符号）

​	1.2将重定向符号之前信息按照以前的命令处理方式进行处理

​	1.3取出重定向的文件名称

2.解析输入信息（得到命令名称 + 运行参数）

3.创建子进程

​	3.5在程序替换之前进行标准输出重定向到指定的文件			open、dup2

4.在子进程中进行程序替换（替换失败子进程退出）

5.父进程等待子进程退出

```c
char *strchr(const char *s, int c);			//在一个字符串中匹配指定的字符，返回这个字符的位置
```







```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <ctype.h>
#include <fcntl.h>
#include <sys/stat.h>

int main(int argc,int* argv[])
{
    while(1)
    {
        printf("[user@host path]$ ");
        fflush(stdout);
        char buf[1024] = {0};
        fgets(buf, 1023, stdin);
        buf[strlen(buf) - 1] = '\0';
        
        //重定向检测
        int direct_flag = 0;        //0表示没有重定向   1表示清空重定向  2表示追加重定向
        char* ptr = buf;
        char* redirect_file = NULL; //文件名的起始地址

        while(*ptr != '\0')
        {
            if(*ptr == '>')
            {
                direct_flag = 1;
                *ptr = '\0';
                ptr++;
                if(*ptr == '>')
                {
                    direct_flag = 2;
                    *ptr = '\0';
                    ptr++;
                }
                while(*ptr != '\0' && *ptr == ' ')
                    ptr++;
                redirect_file = ptr;
                while(*ptr != '\0' && *ptr != ' ')
                    ptr++;
                *ptr = '\0';
            }
            ptr++;
        }

        ptr = buf;
        int myargc = 0;
        char *myargv[32] = {NULL};
        while(*ptr != '\0')
        {
            if(*ptr != ' ')
            {
                myargv[myargc] = ptr;
                myargc++;
                while(*ptr != '\0' && *ptr != ' ')
                    ptr++;
                *ptr = '\0';
            }
            ptr++;
        }
        myargv[myargc] = NULL;

        /*
           for(int i = 0; i < myargc; i++)
           {
           printf("[%s]\n", myargv[i]);
           }
           */

        if(strcmp("cd", myargv[0]) == 0)
        {
            chdir(myargv[1]);
            continue;
        }

        pid_t pid = fork();
        if(pid < 0)
        {
            perror("fork error");
            continue;
        }
        else if(pid == 0)
        {
            //子进程
            if(direct_flag == 1)
            {
                //清空重定向
                int fd;
                fd = open(redirect_file, O_CREAT | O_RDWR | O_TRUNC, 0664);
                dup2(fd, 1);
            }
            else if(direct_flag == 2)
            {
                //追加重定向
                int fd;
                fd = open(redirect_file, O_CREAT | O_RDWR | O_APPEND, 0664);
                dup2(fd, 1);
            }

            execvp(myargv[0], myargv);  //重定向不会随着程序替换而改变
            perror("execvp error");     //系统调用错误的原因
            exit(-1);           //替换成功执行不到，替换失败退出
        }

        wait(NULL);        //父进程等待
    }

    return 0;
}
```



# 6.动态库与静态库的生成和使用

生成可执行程序的链接方式：

​	**动态链接**：链接动态库，只是在生成的程序中记录库中的函数信息表，并没有将具体代码实现写入到程序中。因此运行动态链接生成的程序的时候需要依赖动态

​	库的存在。好处是内存中共享一份（没有代码冗余）。

​	**静态链接**：静态链接库，在生成的程序中直接将库中所需函数的实现写入到可执行程序中，生成的程序比较大，但是没有依赖性。



动态链接：链接动态库，只在生成可执行程序时记录库文件中的函数符号信息表，并没有把代码实现写入可执行程序中，因此程序运行时需要依赖动态库的存在，

并且将动态库也要加载到内存中，好处是多个程序用到相同的库函数，则可以在内存中使用同一份库函数。

静态链接：链接静态库，在生成可执行程序时，直接将使用到的库函数的实现拿出来写入到可执行程序中，因此生成的可执行程序较大，但是运行的时候不需要依

赖静态库的存在。



要生成一个可执行程序时用到了库函数，使用动态库函数好还是使用静态库函数好？

动态库的优点：共享，代码荣誉小，代码模块化，便于模块代码替换。

一些模块化，便于功能替换的一些接口使用动态库。（比如：卡牌游戏，新不良人游戏，还有不同厂家的摄像头对接）

静态库的优点：依赖性低，多份代码，只有自己一个程序使用的时候大多数会使用静态库。

功能改动性小，并且只有当前程序使用的时候使用静态库。



**库的生成**：库中的函数不能有main函数

**1.将原码经过编译汇编之后，解释成为二进制指令（机器指令代码）。**

-E（进行预处理）、-S（进行编译）、-c（进行汇编）			

gcc -c -fPIC testlib.c -o testlib.o			（只有一个-c，包括了预处理、编译、汇编）	



解释：fPIC	产生位置无关代码

在使用GCC编译器时，选项-fPIC表示生成位置无关代码（Position Independent Code，PIC）。当将源文件编译成目标文件（.o）时，使用-fPIC选项可以生成适用于共享库的目标文件。

共享库是一种可被多个程序共享和重复使用的二进制代码集合。为了使共享库能够在内存中加载并链接到多个程序中，使用位置无关代码是必要的。位置无关代码不依赖于特定的内存地址，而是通过相对地址和间接寻址来访问变量和函数。

-fPIC选项告诉GCC生成位置无关代码，它会产生与特定地址无关的目标文件。这使得目标文件可以在内存的任意位置加载，并且能够与其他模块共享，从而提供了更大的灵活性和可重用性。

总结一下，使用-fPIC选项可以生成适用于共享库的位置无关目标文件，使得共享库可以在不同程序之间进行共享和重复使用。



**2.将编译完成后的二进制指令组织打包成为库文件。**

动态库的生成：gcc --shared testlib.o（可以同时有多个.o文件） -o libtestlib.so（这个库文件名字是libtest）（--shared表明生成库，就不要求有main函数了）

gcc编译器默认生成的可执行程序，现在告诉编译器要生成的是一个动态库	（动态库是在运行的时候加载的）

动态库文件的命名格式：lib是前缀，.so是动态库的后缀，中间是动态库的名字



静态库的生成：ar -cr libtestlib.a testlib.o ......		（libtestlib.a是要生成的文件，testlib.o是要加入的文件，加入的文件可以是多个）

静态库文件的命名格式：lib是前缀，.a是静态库的后缀，中间是静态库的名字

解释：

在这个命令中，`ar` 是一个用于创建和管理静态库的工具。 `-cr` 选项指示 `ar` 创建一个新的库文件，并将 `testlib.o` 添加到其中。`libtestlib.a` 是要创建的库文件名。

因此，`ar -cr libtestlib.a testlib.o` 的作用是将 `testlib.o` 文件添加到名为 `libtestlib.a` 的静态库中。

静态库是一种包含对象文件的存档文件，它可以通过链接器链接到应用程序中。使用静态库可以将代码进行打包，以便在编译时将其嵌入到最终的可执行文件中。



**库的使用**：

使用-l选项指定要连接的库名称：gcc main.c -o main -ltestlib

但是链接器在链接库文件生成可执行程序的时候，会到指定的一些路径下去找库文件（动态库），找到了就链接，找不到报错。

生成可执行程序时链接使用：

**1.库文件放在指定路径下：/usr/lib64**（库文件必须在指定路径下，否则链接器找不到，编辑器是在指定路径下找的）

```shell
sudo cp ./libtestlib.so /usr/lib64/			#把这个动态库放到/usr/lib64/目录中
```

**2.设置环境变量**：export LIBRARY_PATH=$LIBRARY_PATH:./（将库文件所在路径添加到LIBRARY_PATH中环境变量）（防止覆盖）（环境变量只对当前终端生

效）

**3.使用gcc的-L选项指定库路径：gcc main.c -o main -L./ -ltestlib**（链接的是静态库，gcc默认的链接方式是动态库）(常用)



**运行可执行程序时加载使用：只针对动态链接生成的程序**

**1.库文件所在路径放在指定路径下：/usr/lib64**（库文件必须在指定路径下，否则链接器找不到，编辑器是在指定路径下找的）

**2.设置环境变量：export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./**（将库文件所在路径添加到LIBRARY_PATH中环境变量）（防止覆盖）（环境变量只对当

前终端生效）（export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库所在路径）



**运行程序：./main**



**工作中：在使用第三方库的时候，大多数都是使用静态库，因为所用的库文件只有当前这一个程序会使用，不用担心在内存中造成冗余，静态库快速。**



## 6.1总结静态库和动态库的生成和使用（直接按流程使用）

```shell
ldd main		#查看程序所依赖的库文件
```

![image-20230817083839188](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230817083839188.png)



```c
//文件：mian.c
#include <stdio.h>
#include "testlib.h"

extern void testprint();

int main()
{
    testprint();
    return 0;
}
```

```c
//文件：testlib.c
#include <stdio.h>

void testprint()
{
    printf("这是一个库函数\n");
}
```

```c
//文件：testlib.h
void testprint();
```

![image-20230817082947806](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230817082947806.png)



```shell
#静态库的运行顺序（一个终端成功，所有终端都可以成功）
gcc -c -fPIC testlib.c -o testlib.o		#库的生成	1.将原码经过编译汇编之后，解释成为二进制指令（机器指令代码）。
gcc main.c -o main -ltestlib			#库的使用	使用-l选项指定要连接的库名称
ar -cr libtestlib.a testlib.o			#静态库的生成 2.将编译完成后的二进制指令组织打包成为库文件。
gcc main.c -o main -L./ -ltestlib		#使用gcc的-L选项指定库路径
./main
```

![image-20230817083807289](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230817083807289.png)





```shell
#动态库的运行顺序（只针对当前终端，换一个终端就失败）
gcc -c -fPIC testlib.c -o testlib.o			#库的生成	1.将原码经过编译汇编之后，解释成为二进制指令（机器指令代码）。
gcc main.c -o main -ltestlib				#库的使用	使用-l选项指定要连接的库名称
gcc --shared testlib.o -o libtestlib.so		#动态库的生成 2.将编译完成后的二进制指令组织打包成为库文件。
sudo cp ./libtestlib.so /usr/lib64/			#库文件所在路径放在指定路径下
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./	#设置环境变量（每次换一个终端就要设置一次当前终端的环境变量，最好的办法是直接在配置文件中修改，一直都可以使用）		（export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库所在路径）
./main
```

![image-20230817083522458](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230817083522458.png)



```shell
cp -r ./lib ./libcopy		#拷贝目录

#打包
tar -czvf libcopy.tar.gz libcopy/ 		#也可以不用拷贝之后打包，因为打包不会将之前的文件销毁，仅仅只是打包
sz libcopy.tar.gz						#打包之后移动到主机上
```



# 7.文件系统（选学，了解）

![image-20230818113026131](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230818113026131.png)

inode节点：文件的元信息节点（名称、时间、权限、数据库地址......）

文件的存储：

在超级块中找到对应的inode位图以及data位图区域地址，在对应位图中找到空闲的inode节点号以及空闲数据块号，进而存储文件数据到数据块中，并且将文件

的元信息保存到inode节点中。（在所在目录文件中加入目录项信息，当前文件名以及inode节点号）

文件数据的读取：从所在目录文件中找到文件的目录项信息（通过文件名找到inode节点号），在文件系统的inode区域中通过inode节点号找到inode节点，从

inode节点中获取到数据块号，这时候就可以从对应数据块中取出数据了。



# 8.软链接文件和硬链接文件

这两种文件都是针对一个源文件创建的，通过创建的软链接或硬链接文件访问源文件的数据。

```shell
ls -i   					#显示文件的inode节点号
ln main.c main.hard			#创建main.c的硬链接
ln -s main.c main.soft		#创建main.c的软链接
```

硬链接文件创建后，文件的链接数+1，硬链接文件的inode节点号与源文件的inode节点号相同。

硬链接文件实际上只是源文件的一个目录项信息，与源文件公用同一个inode节点。



![image-20230818131857657](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230818131857657.png)



软链接文件创建后，源文件并没有什么变化，但是软链接文件有独立的inode节点，但是文件内容中保存的是源文件的路径。



删除原文件，对于硬链接文件没有影响，只是链接数-1，依然可以访问文件数据。对于软链接来说，则软链接失效。

软链接只认路径，不认文件。

删除原文件之后再创建一个和原文件名字一样的文件，软链接根据记录的路径访问这个新创建的文件。

删除文件的原理：当删除一个文件的时候，只是将和文件绑定的inode号进行解绑，如果和这个inode绑定的文件数是1，才是真正的删除。这样，也不会直接删除

inode绑定的data，只是将inode和data变成一个未使用的状态。（删除文件不是真正的删除，还原文件就是通过inode找到data来进行还原的。）（删除文件之后

只要不从给磁盘写入数据，覆盖之前的data，拿就拿保证百分之百还原文件。）

软链接文件可以跨分区建立，但是硬链接文件不可以。

软链接文件可以针对目录创建，但是硬链接不可以。

![image-20230818132050302](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230818132050302.png)

l开头的是软链接文件。（和windows中的快捷方式差不多，linux中没有快捷方式一说）

软链接用的比较多，硬链接不多。（硬链接用于重要文件的备份，防止误删了，误删了原文件硬链接依然可用）



# 9.总结

库函数IO接口：fopen、fwrite、fread、fseek、fclose

文件打开方式：r	r+	w	w+	a	a+	b	（w：文件已经存在清空文件		a：文件已经存在不清空文件内容）

注意事项：

库函数IO接口这里分为文本操作和二进制操作。

fread返回值具有歧义，需要注意返回值的判断。（返回的操作的完整块的个数，返回0有可能读到数据了，有可能没有读到数据，还有出错了也要进行判断）



系统调用IO接口：open、write、read、lseek、close

文件打开方式：O_RDONLY（只读）、O_WRONLY（只写）、O_RDWR（可读可写）（三选其一）

可选项：O_CREAT（文件不存在则创建新文件）、O_TRUNC（打开文件时清空文件内容）、O_APPEND（追加）

文件的创建权限：给定的权限会受到权限掩码的影响，得到的实际权限不同。



文件描述符：

本质：内核中进程打开的文件描述信息表（数组）的下标。

分配规则：最小未使用。

重定向原理：通过改变文件描述符这个下标对应文件描述信息，进而实现操作的文件描述符不变，但是实际操作的文件发生改变，进而实现数据流向的改变。

```c
int dup2(int oldfd, int newfd);		//对newfd进行重定向，newfd拷贝oldfd，oldfd不变
```

文件描述符与文件流指针：文件流指针是个结构体封装了文件描述符。

FILE*：库函数操作句柄

int：系统调用操作句柄

一个进程中默认会打开三个文件：标准输入（0  stdin）、标准输出（1  stdout）、标准错误（2  stderr）。

缓冲区：我们通常所说的缓冲区，是文件流指针中创建的缓冲区。



在minishell中加入重定向：

1.捕捉键盘输入

2.解析输入信息（重定向类型、重定向文件名称、命名名称、运行参数）

​	2.1根据命令中的>确定是否包含重定向，根据个数确定重定向类型

​	2.2>之前是基础指令部分，解析出命令名称和运行参数

​	2.3>之后是重定向信息部分，解析出重定向类型，重定向文件名称

3.创建子进程

4.在子进程中根据重定向类型进行标准输出重定向	dup2(fd,1);

5.在子进程中进行程序替换（替换失败要退出子进程）

6.父进程等待子进程退出



动态库和静态库的生成和使用