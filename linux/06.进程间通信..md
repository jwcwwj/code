# 1.本节目标

进程间通信介绍
管道（传输数据）
消息队列（传输数据）
共享内存（共享数据）
信号量 （控制）



进程间通信：进程间的几种通信方式的学习（管道、共享内存、消息队列、信号量）		还有套接字（网络通信）

为什么进程间无法直接通信？

答：因为进程之间具有独立性，每个进程访问的都是自己的独立的虚拟地址空间，使用的都是虚拟地址，通过页表映射到物理内存。因此就算将数据的内存地址交

给其他进程。其他进程也无法访问（当然其实也无法直接给）

只能通过操作系统提供的几种方式来进行。

本质上来说是操作系统为多个进程提供了一处公共的数据传输媒介（内存）。

因为通信场景不同，因此提供了多种不同的方式：管道、共享内存、消息队列、信号量。



每个进程都有自己的虚拟地址空间，访问的都是自己的虚拟地址，因此进程之间具有独立性，无法直接通信。

进程间通信原理：系统为进程间提供公共传输媒介实现公共访问进而实现通信。





# 2.管道

管道：用于传输数据。

特性：半双工通信。（可以从a到b，也可以从b到a，但同一时间只能发生一个）

本质：管道就是系统内核中的一块缓冲区（内核空间中开辟的一块内存），不存在用户态（用户态各个进程都有自己的地址），用户不能直接访问，管道就是内核

当中开辟的内存，让各个进程通过系统调用接口进行访问，进程无法直接访问，只能通过系统调用接口来进行访问。（多个进程访问同一块缓冲区就可以实现数据

传输）

通信原理：多个进程只要能够访问同一块内核中的缓冲区（管道）就能实现通信。

ipc就是进程间通信。

分类：

匿名管道：管道没有名字，也就是缓冲区没有标识符。

匿名管道只能用于具有亲缘关系的进程间通信。（父子进程，兄弟进程、叔侄进程、爷孙进程）

命名管道：管道具有标识符。

命名管道可用于同一主机上的任意进程间通信。

## 2.1匿名管道

匿名管道：管道缓冲区没有标识符，无法被其他进程找到，因此只能通过子进程复制父进程的方式获取到管道的操作句柄，进行通信。

管道是当做文件使用的，但并不是文件，是操作系统中内核的缓冲区。

linux中一切接文件，指的是llinux中把一切当做文件使用。

![image-20230817170007944](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230817170007944.png)

管道的读写特性（管道的流式传输）：

​	1.管道中没有数据，则read会阻塞。

​	2.管道中数据满了，则write会阻塞。（管道是内核中的缓冲区，linux中一切皆文件，但要管道真的不是文件，理解管道是内存缓冲区，内存不能无限制的使

​	用）

管道的流式传输：数据先进先出的规则。（先放的数据先出，后放的数据后出）

若管道的所有读端被关闭，则继续write就会触发异常，导致进程退出。

若管道的所有写端被关闭，read读完所有数据后，则不再阻塞，返回0.

```c
//文件：pipe1.c
#include <stdio.h>
#include <unistd.h>     //系统调用接口大多数都是这个头文件
#include <string.h>

int main()
{
    //创建管道
    int pipefd[2];
    int ret = pipe(pipefd);     //成功返回0，失败返回-1
    
    if(ret < 0)
    {
        perror("pipe error");
        return -1;
    }

    //创建子进程，复制父进程以及指向管道的两个标识符
    pid_t pid = fork();     //父进程返回子进程的id，子进程返回0，子进程创建失败返回负数
    if(pid < 0)
    {
        perror("fork error");
        return -1;
    }
    else if(pid == 0)
    {
        //子进程
        sleep(3);
        char *ptr = "还有8分钟\n";
        int total = 0;
        while(1)
        {
            //write参数：pipefd[1]是操作句柄，用于明确打开的文件，ptr是要写入的数据，strlen(ptr)是要写入的数据。
            //返回值：成功返回实际写入文件的数据长度，失败返回-1。
            int ret = write(pipefd[1], ptr, strlen(ptr));     //pipefd[1]是写数据
            total += ret;
            printf("子进程写入成功%d\n",total);
        }
    }
    else
    {
        //父进程
        sleep(10);
        char buf[1024] = {0};           
        //read参数：pipefd[0]是操作句柄，用于明确打开的文件，buf存放读取到的数据的缓冲区，1023是最大可以读取的数据长度。
        //返回值：成功返回实际读取到的数据长度（没有读到数据算成功读取，返回0），失败返回-1.
        read(pipefd[0], buf, 1023);             //pipefd[0]是读数据
        printf("父进程：%s\n", buf);
    }

    return 0;
}
```



管道：| 连接两个命令，将前边命令进程要输出到标准输出的结果，不再输出到标准输出，而是将这个数据传输到后边的命令进程。

ps -ef | grep pipe

ps -ef：将所有进程信息写入到标准输出。

grep pipe：不断循环从标准输入读取数据进行字符串匹配过滤。（管道中没有数据就阻塞）



shell进程中创建两个进程：一个进程运行ps，一个进程运行grep。

要将ps进程的数据，交给grep进程只能通过进程间通信完成。（匿名管道完成）

1.创建管道；

2.创建两个进程，在各自进程中进行程序替换；

3.在程序替换之前，ps进程应该标准输出重定向到管道写入端；

​								  grep进程应该标准出入重定向到管道读取段；

4.父进程等待子进程退出。

```c
//文件：pipe2.c
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

int main()
{
    int pipefd[2];
    int ret = pipe(pipefd);
    
    if(ret < 0)
    {
        perror("pipe error");
        return -1;
    }

    if(fork() == 0)
    {
        //第一个子进程
        dup2(pipefd[1], 1);     //把标准输出重定向到管道的写入端，将数据写入管道
        execlp("ps", "ps", "-ef", NULL);        //ps退出之后pipefd[1]也就被关闭了
        exit(-1);           //替换失败才会执行到这，替换成功执行不到这
    }

    if(fork() == 0)
    {
        //第二个子进程
        close(pipefd[1]);
        dup2(pipefd[0], 0);     //把标准输入重定向到管道的读取端，从管道读取数据

        //execlp参数：新的程序文件名称、新的程序文件名称、运行参数、NULL
        execlp("grep", "grep", "pipe", NULL);
        exit(-1);
    }

    //关闭父进程
    close(pipefd[0]);
    close(pipefd[1]);
    wait(NULL);
    wait(NULL);

    return 0;
}
```



## 2.2命名管道

命名管道：可以用于同一主机上任意进程间通信，管道缓冲区具有标识符。

```shell
mkfifo filename					#创建一个管道文件	举例子：mkfifo test.fifo
```

![image-20230819141205696](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230819141205696.png)

管道文件创建成功，p表示管道文件，大小是0个字节，这个文件（./test.fifo）不是所说的命名管道，是命名管道的标识符。

不管是命名管道还是匿名管道都是一个管道，**管道的本质就是缓冲区**，就是个内存，不是文件，文件（./test.fifo）只是外在的体现，只是个名字，只是让多个文件

通过这个标识符（文件标识符）找到这个缓冲区（管道）。

命名管道本质依然是内核中的一块缓冲区，但是命名管道有名字具有标识符，而这个标识符（./test.fifo）就是一个可见于文件系统的管道类型文件，多个进程可以

通过打开同一个管道文件访问同一块内核中的缓冲区实现通信。

代码操作：int mkfifo(char* path,int  mode);		c创建命名管道

path：管道文件的一个路径名称		mode：权限



管道有一个特性：有读才有写，有写才有读。

创建的管道标识符只是一个标识符，没有在内核中开辟缓冲区，内存中的缓冲区并不会随着管道标识符（文件）的创建而创建，等到真正用的时候（要去通信了）

才会创建缓冲区。（缓冲区不是写入就创建，必须是同时具有读写的情况下才会开辟内存，实现通信的。）

第一个终端中： 

![image-20230819142822178](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230819142822178.png)

第二个终端中：

![image-20230819142853888](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230819142853888.png)

之后第一个终端中的命令就运行完了。

第一个终端中：

![image-20230819143545405](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230819143545405.png)

![image-20230819143639817](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230819143639817.png)

写入数据之后大小不会变，永远只是一个标识符，一切通信都是以缓冲区来实现通信的。



对管道的读写操作，依然是IO操作。



打开特性：

若以只读方式打开命名管道文件，则会阻塞，直到这个管道文件被以写的方式打开。

若以只写方式打开命名管道文件，则会阻塞，直到这个管道文件被以读的方式打开。

```c
//文件：fifo_read.c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <errno.h>
#include <fcntl.h>

//从管道读取数据
int main()
{
    umask(0);
    char* fifo_name = "./test.fifo";
    int ret = mkfifo(fifo_name, 0664);

    //EEXIST表示文件已经存在    是对文件已经存在的处理，文件存在不报错退出
    if(ret < 0 && errno != EEXIST)
    {
        //不是因为文件已经存在而报错，创建管道失败的原因和文件已经存在无关
        perror("mkfifo error");
        return -1;
    }

    //open(文件名,打开方式,权限);
    //open创建的是普通文件，mkfifo创建的是管道文件
    int fd = open(fifo_name, O_RDONLY);     //只有第二个参数是O_CREAT的时候才有第三个参数
    if(fd < 0)
    {
        perror("open error");
        return -1;
    }

    printf("open fifo success\n");

    while(1)
    {
        char buf[1024] = {0};
        int ret = read(fd, buf, 1023);
        if(ret < 0)
        {
            perror("read error");
            return -1;
        }
        else if(ret == 0)
        {
            printf("all write closed\n");
            return -1;
        }
        printf("buf：%s\n", buf);
    }

    close(fd);
    return 0;
}

```

```c
//文件：fifo_write.c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>

int main()
{
    umask(0);
    char* fifo_name = "./test.fifo";
    int ret = mkfifo(fifo_name, 0664);
    if(ret < 0 && errno != EEXIST)
    {
        //不是因为文件已经存在而报错，文件已经存在不报错
        perror("mkfifo error");
        return -1;
    }

    int fd = open(fifo_name, O_WRONLY);
    if(fd < 0)
    {
        perror("open error");
        return -1;
    }

    while(1)
    {
        char buf[1024] = {0};
        scanf("%s", buf);
        int ret = write(fd, buf, strlen(buf));
        if(ret < 0)
        {
            perror("write error");
            return -1;
        }
    }

    close(fd);

    return 0;
}
```

## 2.3总结

管道：内核中的一块缓冲区，多个进程通过访问同一缓冲区实现通信。



分类：

匿名管道：只能用于具有亲缘关系的进程间通信。

原因：没有标识符，只能通过子进程复制父进程的方式获取操作句柄。

命名管道：可以用于同一主机任意一个进程间通信。

原因：标识符是管道文件，通过打开同一个管道文件访问同一个缓冲区。



特性：

半双工通信：可以选择方向的单向通信。

管道提供字节流传输服务：有序的、基于连接的、可靠的传输方式（读写上不限制大小的方式）。

基于连接：所有读端被关闭，则write触发异常，所有写端被关闭则read读完数据返回0，不再阻塞。



管道自带同步与互斥：

互斥（访问的安全性）：通过保证同一时间对临界资源的唯一访问保证操作安全性。（一个资源在我访问期间别人不能访问）

同步（访问的合理性）：通过某种条件判断，实现对资源访问获取的有序合理性。

互斥的具体体现：对管道进行写操作时写入数据大小不超过PIPE_BUF默认4096字节大小，则保证操作原子性。

原子性操作：要么一次完成，要么不做，体现的是中间不可被打断或者中间不会被打断的特性。

同步的具体体现：若管道中没有数据则read阻塞，若管道中数据满了则write阻塞。

管道生命周期随进程。

int pipe(int pipefd[2]);

int mkfifo(char* path, int mode);



# 3.共享内存

共享内存：用于进程间的数据共享。

共享内存实现通信的原理：开辟一块物理内存空间，各个进程将同一块物理内存空间映射到自己的虚拟地址空间中，通过虚拟地址进行访问，进而实现数据共享。

共享内存是最快的进程间通信方式，因为通过虚拟地址空间映射后，直接通过虚拟地址访问物理内存，相较于其他方式少了两步数据拷贝操作。

共享内存相较于其他进程间通信方式少了两次拷贝方式。



操作流程：

1.创建或打开共享进程：

```c
int shmget(key_t key, size_t size, int shmflg);
```

key：标识符，通过相同的标识符，多个进程可以打开同一块共享内存。

size：要创建的共享内存大小，如果共享内存已经存在了，要创建的共享内存操作就是打开，打开的时候size操作是被忽略的，不会修改原先的size。（单位是内

存页）

shmflg：打开方式 + 权限。（操作方式或（|）连接）

IPC_CREAT（不存在则创建，存在则打开）

IPC_CREAT | IPC_EXCL（如果文件存在则报错，不存在则创建打开）

IPC_CREAT | IPC_EXCL | 0664（打开方式 + 权限）

返回值：

成功返回非负整数，操作句柄。

失败返回-1。



2.与进程建立映射关系（映射到虚拟内存）：

```c
void *shmat(int shmid, const void *shmaddr, int shmflg);
```

shmid：shmget返回的操作句柄。

shmaddr：映射首地址，通常置NULL，让系统自己选择合适的首地址。

shmflg：SHM_RDONLY（只读）、0（可读可写） 

返回值：

成功返回映射后的首地址。

失败返回（void*）-1.



3.对共享内存进行内存操作：

memcpy、strcpy、printf......



4.与进程间解除映射关系

```c
int shmdt(const void *shmaddr);
```

shmaddr：shmat返回的映射首地址。

返回值：成功返回0，失败返回-1。



5.删除共享内存

```c
int shmctl(int shmid, int cmd, struct shmid_ds *buf);
```

shmid：shmget返回的操作句柄。

cmd：要对共享内存进行的操作类型。（IPC_RNID：标记要删除的共享内存，不会立即删除，等到映射链接数为0的时候删除，标记后如果有新的进程要映射共享

内存是不能映射的）（总结：映射链接数为0时删除共享内存，禁止新的映射连接）

buf：用于获取或设置共享内存属性的，简单使用置NULL即可。

返回值：成功返回0，失败返回-1。



```shell
ipcs				#查看系统内核当中所有的进程间通信资源
ipcs -m				#查看系统内核当中所有的共享内存进程间通信资源
ipcs -q				#查看系统内核当中所有的消息队列进程间通信资源
ipcs -s				#查看系统内核当中所有的信号量进程间通信资源
ipcrm -m 196668		#删除共享内存的196668（196668是共享内存id）(删除不是立即删除，是标记删除，这个命令也是通过函数实现的)（执行这个命令之后不会立即删除，但标识符会变成全0）
ipcs -m | column -t	#将输出的关于共享内存的进程间通信资源进行对齐
任何命令 | column -t  #任何输出到终端中的内容都可以对齐
```



```c
//文件：shm_read.c
#include <stdio.h>
#include <unistd.h>
#include <sys/shm.h>        //共享内存的头文件
#include <string.h>
#include <stdlib.h>

#define IPC_KEY 0x01234567      //进程标识符
#define PROJ_ID 0X12345467      //项目标识符

int main()
{
    //key_t key = ftok("./", PROJ_ID);      //第一种生成进程标识符的办法    第二种方法是指定一个进程标识符
    //1.创建或打开共享进程    shmget(标识符、大小（字节）、打开方式和权限);   返回值：操作句柄
    int shmid = shmget(IPC_KEY, 32, IPC_CREAT | 0664);
    if(shmid < 0)       
    {
        perror("shmget error");
        return -1;
    }

    //2.与进程建立映射关系（映射到虚拟内存）
    //shmat(句柄, 映射首地址, 访问方式);   映射首地址是NULL表示自由分配首地址    访问方式是0表示可读可写     返回值：映射成功后的首地址
    void* shm_start = shmat(shmid, NULL, 0);      //映射首地址

    if(shm_start == (void*)-1)
    {
        //映射失败
        perror("shmat error");
        return -1;
    }
    
    //3.对共享内存进行内存操作
    while(1)
    {
        printf("%s\n",(char*)shm_start);        //共享内存中没有数据，什么都不会打印，但是会不断地进行IO操作
        sleep(1);
    }

    //4.与进程间解除映射关系    成功返回0，失败返回-1
    shmdt(shm_start);

    //5.删除共享内存
    //shcmctl(句柄, 操作类型, 信息结构);
    shmctl(shmid, IPC_RMID, NULL);


    return 0;
}
```

```c
//文件：shm_write.c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/shm.h>

#define IPC_KEY 0x01234567

int main()
{
    int shmid = shmget(IPC_KEY, 32, IPC_CREAT | 0664);
    if(shmid < 0)
    {
        perror("shmget error");
        return -1;
    }

    void *shm_start = shmat(shmid, NULL, 0);
    
    if(shm_start == (void*)-1)
    {
        perror("shmat error");
        return -1;
    }

    int i = 0;

    while(1)
    {
        //printf把格式化的数据写入到表中输出
        //printf("今天的天气号好晴朗 + %d", i);
        
        //sprintf把格式化的数据写入到指定的空间，用于连接字符串
        sprintf(shm_start, "今天的天气好晴朗+%d", i++);       //非阻塞接口
        sleep(1);       

        //fprintf把格式化的数据写入到指定的文件中
        //fprint(FILE*, "今天的天气好晴朗+%d", i);
    }

    shmdt(shm_start);

    shmctl(shmid, IPC_RMID, NULL);

    return 0;
}
```

![image-20230820225223834](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230820225223834.png)

![image-20230820225243647](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230820225243647.png)

![image-20230820225310233](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230820225310233.png)

共享内存谁都可以修改，一端的操作不影响另一端的操作，读的操作不影响写的操作，写的操作不影响读的操作。

操作系统版本：

system：支持类unix接口。

POSIX：Linux和windows都支持。

```c
key_t ftok(const char* pathname, int proj_id);		//用于产生一个IPC key标识符，不好用（文件删除后，其他的进程打不开，重新生成一个，inode节点号是不一样的）
//参数：pathname：文件名	proj_id：项目标识符
//生成原理：通过pathname取出inode节点号，从inode节点号截取一段的数据，在proj_id中截取一段的数据，合到一块就是进程标识符。
```



## 3.1总结

共享内存通信原理：开辟一块物理内存，多个进程将同一块内存映射到自己的虚拟地址空间，进行访问，进而实现数据共享。

特性：

1.效率最高的进程间通信方式。

2.生命周期随内核。

注意事项：各个进程对共享内存的操作都是不安全的操作。



# 4.消息队列（了解）

消息队列限制多，效率低，现在使用的不多了，可以使用共享内存实现消息队列。

实际上就是一个内核中的优先级队列。

通信原理：在内核中创建一个优先级队列，多个进程通过对同一个队列添加或者获取节点实现数据通信。

消息队列有最大长度限制的。



使用不多的原因：因为消息队列限制较多，效率也不高，因此使用度较低。（可以用共享内存实现消息队列，共享内存效率高）



![image-20230822034316611](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230822034316611.png)

添加的节点的结构由用户自己定义，用户自己确定数据有多长。每个用户添加节点时节点类型都要不同，类型既是优先级判断基准也是身份判断标准。



特性：

1.自带同步与互斥，消息队列操作是安全的；

2.生命周期随内核。



# 5.信号量（了解）

这里讲解的是system V，只限于了解和原理层面，后期会详细讲解posix标准信号量。

本质：就是一个内核中的计数器（posix不是） + pcb等待队列，用于实现进程间的同步与互斥。

停车场：车位技术牌，对停车场中的空闲空闲车位资源的计数。

原理：对资源进行计数，在进程获取资源之前先通过计数判断获取是否合理，不合理则阻塞等待。直到条件满足后唤醒阻塞的进程。

信号量是实现同步与互斥的具体手段，同步与互斥是一种概念。

P操作：计数 - 1，判断访问是否合理，不合理则阻塞，合理则正确返回。

V操作：计数 + 1，唤醒阻塞进程。



同步的实现：对资源进行计数，通过计数实现合理访问。

互斥的实现：计数最大为1，表示只有一个资源，计数前计数 - 1，在访问期间其他进程不可访问，访问完毕之后，计数 + 1。



同步的实现换种说法，获取资源前进行P操作，合理则获取，不合理则阻塞。

​										产生一个资源则进行一次V操作。

互斥的实现换种说法：计数最大为1，表示只有一个资源，访问前P操作，访问完V操作。



进程对共享内存的操作本身是不安全的，可以通过信号量实现安全操作。

生命周期是随内核的。

大多数的system V操作都是随内核的。



同步的实现：通过计数器对资源进行计数，在获取资源之前，先访问信号量，通过计数判断，通过计数判断会否能够，不能获取则阻塞进程，可以获取则正确返回

获取资源。

阻塞进程：将进程状态置为可中断休眠，将pcb挂到等待队列上。

同步的实现：通过计数器对资源进行计数，在获取资源之前，先进行P操作，等待产生一个资源后，进行V操作。

互斥的实现：将信号量的计数初始设置为1，表示资源只有1个，在访问资源之前进行P操作，访问完毕之后进行V操作。



# 6.总结

进程间通信（IPC）：进程之间无法直接通信，因为每个进程都有自己的独立的虚拟地址空间，访问都是自己的虚拟地址，具有独立性，因此无法直接通信。

操作系统为用户提供的用于在进程之间进行数据通信的方式。

通信方式种类：管道、共享内存、消息队列、信号量、套接字（网络通信）。



## 1.管道

本质：内核中的一块缓冲区。（内核空间中开辟的一块内存）

原理：多个进程通过访问同一个管道缓冲区实现数据传输通信。



分类：

匿名管道：只能用于具有亲缘关系的进程间通信。

原因：缓冲区没有标识符，只能通过子进程复制父进程的方式获取操作句柄。

命名管道：可以用于同一主机上任意进程间通信。

原因：缓冲区具有标识符，标识符是一个可见于文件系统的管道类型文件，多个进程通过打开同一个管道文件访问内核中同一块缓冲区。



特性：

1.半双工通信；

2.提供字节流传输服务：有序的、基于连接的、传输比较灵活；

​	数据先进先出；

​	所有读端关闭则write触发异常，所有写段关闭则read返回0不再阻塞；

3.自带同步和互斥；

​	同步：通过同一时间对临界资源的唯一访问保证访问操作的安全性。

​	互斥：通过条件判断对临界资源进行更加有序以及合理的访问。

​	对管道进行写入操作。大小不超过PIPE_BUF（是一个宏，大小是4096字节）大小则保证原子性。

​	管道中没有数据则read阻塞，管道中数据满了则write会阻塞。

4.生命周期随进程。

​	管道是内核中的缓冲区，是内核空间中的一块内存，如果访问管道的所有进程都与这个管道脱离了关系，这时候缓冲区就会被释放。



操作：

```c
int pipe(int pipefd[2]);
int mlfifo(char* path,int mode);
```

 管道的读写操作就是基础的IO操作。



## 2.共享内存

本质：共享一块物理内存。

原理：开辟一块物理内存，多个进程将同一块内存映射到自己的虚拟地址空间中，通过自己的虚拟地址进行访问，进而实现数据共享。

操作流程：

1.创建共享内存；		shmget

2.映射到进程虚拟地址空间；		shmat

3.内存操作；		printf、strcpy、memcpy

4.解除映射关系；		shmdt

5.删除共享内存。		shmctl



```c
//操作：
ipcs -m;			//查看共享内存信息
ipcrm -m;			//删除共享内存信息
```



特性：

1.最快的进程间通信方式。（相较于其他方式少了两次数据拷贝操作）

2.生命周期随内核。

注意：进程对于共享内存的操作需要注意安全问题。



## 3.消息队列

本质：内核中一个优先级队列。

原理：多个进程通过向同一个队列中添加或者获取节点实现通信。

特性：自带同步与互斥；生命周期随内核。



## 4.信号量

本质：内核中的一个计数器。

作用：用于实现进程间的同步与互斥（保护进程对临界资源的操作是安全的）

操作：

​	P操作：计数 - 1，判断是否访问合理，不合理则阻塞进程。

​	V操作：计数 + 1，唤醒一个阻塞的进程。

同步实现：对临界资源获取的合理性。

​	通过计数器对资源进行计数，获取之前进行P操作；产生资源后进行V操作。

互斥实现：对临界资源访问的安全性。

​	通过计数器计数只有1，表示资源只有1个，同一时间只有1个进程可访问。

​	访问资源之前进行P操作；访问完毕之后进行V操作。
