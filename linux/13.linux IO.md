# 1.五种高级IO

高级IO：四种典型IO方式，多路转接IO。

四种典型IO方式：

IO：输入输出。		过程：等待IO就绪，进行数据拷贝。

典型IO：阻塞IO、非阻塞IO、信号驱动IO、异步IO。

1.阻塞IO：发起IO调用，若IO未就绪（IO条件不具备）则一直等待。

优点：流程最为简单。		缺点：效率较为低下。

![image-20231025191934700](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20231025191934700.png)





2.非阻塞：发起IO调用，若IO未就绪，则立即报错返回。

优点：效率相较于阻塞有所提高。		缺点：需要循环进行操作，不够实时。 

![image-20231025192751811](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20231025192751811.png)





3.信号驱动：自定义IO就绪信号处理，等待IO就绪收到信号打断当前操作，进行IO。

优点：效率更高，实时性更强。		缺点：操作流程更为复杂，需要定义信号处理等。

![image-20231025193052880](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20231025193052880.png)





4.异步IO：非时序性IO，自定义IO信号处理，发起IO调用，调用立即返回，但让系统完成IO，完成后通过信号通知进程。

优点：对于资源利用率极高，效率极高。		缺点：流程是最为复杂。

![image-20231025205118546](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20231025205118546.png)



相对异步的同步，解释异步，同步IO不存在。

同步IO：时序性IO，只有第一个功能完成了，才能完成下一个功能，功能是一个一个完成的。



总结：从阻塞IO到异步IO是一个对资源利用率以及效率提高的过程，也是流程变得复杂的过程。



备注：异步IO实现流程太复杂了，一般不使用，想要学习异步IO可以去看linux下的AIO，linux下的AIO就是异步IO。



阻塞：为了完成某个功能，发起一个调用，若完成功能条件不具备，则一直等待。

非阻塞：发起一个调用，若完成功能条件不具备，则立即报错返回。

阻塞与非阻塞：通常用于描述某个接口特性，表示发起调用后是否能够立即返回。

同步：一个功能完成后，才能进行下一个，若不能立即完成则一直等待。

异步：发起一个调用，让别人完成具体功能，不用等待功能完成后才能继续推进。

同步与异步：通常用于描述功能的完成流程。（外部体现就是功能是否是自己完成的）

异步阻塞与异步非阻塞：

异步阻塞：发起一个调用，让系统完成任务，进程一直等着系统完成任务。

异步非阻塞：发起一个调用，让系统完成任务，进程继续做自己的事情。



5.IO多路转接/IO多路复用：

作用：针对大量描述符进行IO就绪事件监控，让进程仅仅针对已近就绪了IO事件的描述符进行IO操作，避免了进程对未就绪的描述符进行操作所带来的性能损失或

者阻塞。

实现：selete、poll（几乎淘汰了）、epoll

IO就绪事件：可读、可写、异常。



# 2.select

select模型：针对大量描述符进行IO就绪就绪事件监控。

操作流程：

1.定义指定IO事件的描述符集合，将需要监控指定事件的描述符添加到对应集合中。

2.发起监控调用，将需要监控的事件描述符集合拷贝到内核，进行事件监控。

若监控超时了都没有描述符就绪则返回。

若有监控符就绪了指定监控的事件则返回。

在监控调用返回前，都会将描述符集合中没有就绪事件的描述符移除也就是说，调用返回后，集合中保留的只有就绪的描述符。

3.判断哪个描述符还在哪个集合中，就知道哪个描述符就绪了什么事件，进而进行对应IO操作。

## 2.1接口

```c
/* According to POSIX.1-2001, POSIX.1-2008 */
#include <sys/select.h>
/* According to earlier standards */
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
```

遵循POSIX，可以跨平台。

fd_set：描述符集合。

1.定义集合：fd_set rfds（可读事件集合）、wfds（可写事件集合）、efds（异常事件集合）。

2.清空集合：

```c
void FD_ZERO(fd_set *set);
```

3.将需要监控指定事件描述符添加到集合中：

```c
void FD_SET(int fd, fd_set *set);
```

4.发起监控调用：

```c
int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);
```

参数：

nfds：所有集合中最大的描述符的值 + 1

readfds/writefds/exceptfds：可读、可写、异常事件集合（没有什么要监控的，直接置空）

timeout：监控超时等待时间（一直等待则置空，不想等待也就是非阻塞则数据置0）

struct timeval

{

​	tv_usec,

​	tv_sec

};

返回值：返回实际就绪的描述符个数，出错返回-1，超时返回0。（超时表示没有描述符就绪，但是也没有出错）

监控调用一旦返回，返回的是就绪的描述符集合，会移除没有就绪的描述符。 

5.调用返回后，判断哪个描述符还在集合中，确定哪个描述符就绪了什么事件。

```c
int  FD_ISSET(int fd, fd_set *set);
```

6.如果要移除某个描述符的监控（从指定集合中移除指定的描述符）：

```c
void FD_CLR(int fd, fd_set *set);
```

## 2.2应用

第一个应用：

```c
//文件名：select.c
//针对标准输入进行可读事件监控
//当标准输入有数据可读，在对其进行read操作

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/select.h>
#include <time.h>

int main()
{
    fd_set rfds;
    FD_ZERO(&rfds);

    while(1)
    {
        //因为select每次调用返回前都会修改监控集合以及超时时间，所以每次都要重新添加监控描述符以及设置超时时间
        //将需要监控的描述符添加到集合中
        FD_SET(0, &rfds);
    
        struct timeval tv;
        tv.tv_sec = 3;
        tv.tv_usec = 0;
        
        //select(最大描述符 + 1, 读集合, 写集合, 异常集合, 超时时间);
        int ret = select(1, &rfds, NULL, NULL, &tv);        //返回之前会移除没有就绪的描述符
        if(ret < 0)
        {
            //监控出错了
            perror("select error");
            return -1;
        }else if(ret == 0)
        {
            //监控超时了
            printf("监控超时\n");
            continue;
        }

        //判断0号描述符在rfds集合中
        if(FD_ISSET(0, &rfds))
        {
            printf("0号描述符就绪了\n");
            char buf[1024] = {0};
            int ret = read(0, buf, 1023);
            if(ret <= 0)
            {
                printf("error\n");
                continue;
            }
            printf("buf:[%s]\n", buf);
        }
    }
    return 0;
}
```

![image-20231028205311330](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20231028205311330.png)

第二个应用：代码没bug，但有问题，和自己要实现的功能有出入。

多路转接模型通常是针对tcp服务器来进行应用的。

```c++
//文件名：select.hpp
#include <iostream>
#include <vector>
#include <time.h>
#include <sys/select.h>
#include "tcpsocket.hpp"

class Select{
    public:
        Select()
            :_max_fd(-1)
        {
            FD_ZERO(&_rfds);
        }

        //添加监控
        bool Add(TcpSocket &sock)
        {
            int fd = sock.GetFd();
            FD_SET(fd, &_rfds);
            _max_fd = _max_fd > fd ? _max_fd : fd;
            return true;
        }

        //移除监控
        bool Del(TcpSocket &sock)
        {
            int fd = sock.GetFd();
            FD_CLR(fd, &_rfds);     //从集合中移除描述符
            //可能移除的描述符刚好是最大的描述符，重新判断最大的描述符
            for(int i = _max_fd; i >= 0; i--)
            {
                if(FD_ISSET(i, &_rfds))
                {
                    _max_fd = i;
                    break;
                }
            }
            return true;
        }

        //通过参数返回就绪的套接字数据
        //Wait接口对集合中所有描述符进行监控
        //通过参数arry将所有就绪的描述符返回给外界
        bool Wait(std::vector<TcpSocket>* arry)
        {
            struct timeval tv;
            tv.tv_sec = 3;
            tv.tv_usec = 0;
            fd_set tmp = _rfds;
            //select(max + 1, 读, 写, 异常, 超时);
            int ret;
            ret = select(_max_fd + 1, &tmp, NULL, NULL, &tv);
            if(ret < 0)
            {
                //监控出错了
                perror("select error");
                return false;
            }
            else if(ret == 0)
            {
                //超时了，没有描述符就绪
                arry->clear();
                return true;
            }

            for(int i = 0; i < _max_fd; i++)
            {
                if(FD_ISSET(i, &tmp))
                {
                    TcpSocket sock;
                    sock.SetFd(i);
                    arry->push_back(sock);
                }
            }

            return true;
        }

    private:
        fd_set _rfds;   //需要监控的描述符集合-备份
        int _max_fd;    //保存当前集合中最大的描述符
};
```

```c++
//文件名：tcpsoocket.hpp
#pragma once    //解决重复包含
#include <cstdio>
#include <iostream>
#include <string>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <unistd.h>

#define LISTEN_BACKLOG 5
#define CHECK_RET(q) if((q) == false){return -1;}

struct data_t
{
    int num1;
    int num2;
    char op;
};

class TcpSocket
{
    private:
        int _sockfd;        //操作句柄

    public:
        TcpSocket()
            :_sockfd(-1)
        {
            
        }

        void SetFd(int fd)
        {
            _sockfd = fd;
        }

        int GetFd()
        {
            return _sockfd;
        }

        //创建套接字
        bool Socket()
        {
            //tcp提供的是字节流传输服务，需要使用流式套接字SOCK_STREAM
            _sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if(_sockfd < 0)
            {
                //创建失败
                perror("socket error");
                return false;
            }
            return true;
        }

        //绑定地址信息
        bool Bind(const std::string &ip, const uint16_t port)
        {
            struct sockaddr_in addr;
            addr.sin_family = AF_INET;
            addr.sin_port = htons(port);
            addr.sin_addr.s_addr = inet_addr(ip.c_str());       //返回字符串的首地址，和下面取字符串的首元素的地址一样
            //addr.sin_addr.s_addr = inet_addr(&ip[0]);
            socklen_t len = sizeof(sockaddr_in);
            int ret = bind(_sockfd, (sockaddr*)&addr, len);
            if(ret < 0)
            {
                perror("bind error");
                return false;
            }
            return true;
        }

        //切换到监听状态
        bool Listen(int backlog = LISTEN_BACKLOG)
        {
            //listen(描述符, 同一时间连接数);
            int ret = listen(_sockfd, backlog);
            if(ret < 0)
            {
                perror("listen error");
                return false;
            }
            return true;
        }

        //连接服务器
        bool Connect(const std::string &ip, const int port)
        {
            struct sockaddr_in addr;
            addr.sin_family = AF_INET;
            addr.sin_port = htons(port);
            addr.sin_addr.s_addr = inet_addr(ip.c_str());       //返回字符串的首地址，和下面取字符串的首元素的地址一样
            //addr.sin_addr.s_addr = inet_addr(&ip[0]);
            socklen_t len = sizeof(sockaddr_in);
            //connect(描述符, 服务端地址, 地址长度);
            int ret = connect(_sockfd, (sockaddr*)&addr, len);
            if(ret < 0)
            {
                perror("connect error");
                return false;
            }
            return true;
        }

        //服务端获取新连接
        bool Accept(TcpSocket* sock, std::string *ip = NULL, uint16_t* port = NULL)
        {
            //原来的套接字是监听套接字，新创建的套接字是通信套接字
            //int accept(监听套接字, 回去客户端地址, 长度);
            sockaddr_in addr;
            socklen_t len = sizeof(sockaddr_in);
            int newfd = accept(_sockfd, (sockaddr*)&addr, &len);
            if(newfd < 0)
            {
                perror("accept error");
                return false;
            }

            sock->_sockfd = newfd;
            if(ip != NULL)
            {
                *ip = inet_ntoa(addr.sin_addr);
            }

            if(port != NULL)
            {
                *port = ntohs(addr.sin_port);
            }
            return true;
        }

        //接收数据
        bool Recv(std::string *buf)
        {
            //int recv(描述符, 空间, 数据长度, 标志位);     标志位给0是默认阻塞接收
            //返回值：实际获取大小  返回值是0不是没有接收数据，是连接断开了     -1是出错了
            char tmp[4096] = {0};       
            int ret = recv(_sockfd, tmp, 4096, 0);
            if(ret < 0)
            {
                //出错
                perror("recv error");
                return false;
            }
            else if(ret == 0)
            {
                //连接断开
                perror("peer shutdown");
                return false;
            }
            buf->assign(tmp, ret);      //拷贝字符串，参数是字符串首地址和字符串长度。
            return true;
        }

        //发送数据
        bool Send(const std::string &data)
        {
            //int send(描述符, 数据, 长度, 标志位);         标志位为0表示阻塞发送
            int total = 0;      //记录发送了多少数据
            
            while(total < data.size())
            {
                //发送数据一般不是一次性发送的，一般是多次发送，从上一次
                int ret = send(_sockfd, data.c_str() + total,  data.size() - total, 0);
                //int ret = send(_sockfd, &data[0] + total, data.size() - total, 0);      //和上面作用一样
                if(ret < 0)
                {
                    perror("send error");
                    return false;
                }
                total += ret;
            }
            return true;
        }

        bool Close()
        {
            if(_sockfd != -1)
            {
                close(_sockfd);
            }
            return true;
        }
};
```

```c++
//文件名：tcp_cli.cpp
#include "tcpsocket.hpp"

//客户端
int main(int argc, char* argv[])
{
    //客户端可以不绑定地址信息，但是必须知道服务端的地址信息
    if(argc != 3)
    {
        printf("usage：./tcp_cli srv_ip srv_port\n");
        return -1;
    }

    std::string srv_ip = argv[1];
    uint16_t srv_port = std::stoi(argv[2]);

    TcpSocket cli_sock;
    //1.创建套接字
    CHECK_RET(cli_sock.Socket());
    //2.绑定地址信息（不推荐绑定）
    //3.向服务端发起连接
    CHECK_RET(cli_sock.Connect(srv_ip, srv_port));
    while(1)
    {
        //4.收发数据
        std::string buf;
        std::cout << "client say: ";
        std::cin >> buf;
        //客户端向服务端发送数据，客户端出问题直接退出，服务端接收出问题不能直接退出，还要接收下一个客户端
        CHECK_RET(cli_sock.Send(buf));
        //接收数据
        //清空缓冲区
        buf.clear();
        CHECK_RET(cli_sock.Recv(&buf));
        std::cout << "server say: " << buf << std::endl;
    }
    //5.关闭套接字
    CHECK_RET(cli_sock.Close());
    return 0;
}
```

```c++
//文件名：tcp_srv.cpp
//#include "tcpsocket.hpp"
#include "select.hpp"       //在select.hpp中包含tcpsocket.hpp

//服务端
int main(int argc, char* argv[])
{
    //通过程序运行参数指定服务端要绑定的地址
    //  ./tcp_rev 192.168.0.203(IP地址) 9000(端口号)
    if(argc != 3)
    {
        //参数包含文件名本身，如果不是3，就是传参错误
        printf("usage：./tep_rev 192.168.0.203 9000\n");
        return -1;
    }
    
    bool ret;

    std::string srvip = argv[1];
    uint16_t srvport = std::stoi(argv[2]);  //stoi是将字符串转换为整数类型
    TcpSocket lst_lock;     //监听套接字
    //1.创建套接字
    CHECK_RET(lst_lock.Socket());
    //2.绑定地址信息
    CHECK_RET(lst_lock.Bind(srvip, srvport));
    //3.开始监听
    CHECK_RET(lst_lock.Listen());
    
    Select s;
    s.Add(lst_lock);        //将监听套接字添加监控

    while(1)
    {
        std::vector<TcpSocket> arry;    //就绪数组
        ret = s.Wait(&arry);        //开始监控，arry返回就绪套接字
        if(ret = false)
        {
            //监控出错了
            return false;
        }

        for(int i = 0; i < arry.size(); i++)
        {
            //就绪的第i个元素是监听套接字
            if(arry[i].GetFd() == lst_lock.GetFd())
            {
                //4.获取新建连接
                TcpSocket cli_sock;
                std::string cli_ip;
                uint16_t cli_port;
                //bool ret = arry[i].Accept(&cli_sock, &cli_ip, &cli_port);
                ret = lst_lock.Accept(&cli_sock, &cli_ip, &cli_port);
                if(ret == false)
                {
                    continue;
                }

                std::cout << "get newconn" << cli_ip << "-" << cli_port << "\n";
                s.Add(cli_sock);        //将通信套接字添加监控
            }
            else
            {
                //就绪的套接字不是监听套接字
                //5.收发数据    使用获取的新建套接字进行通信
                std::string buf;
                ret = arry[i].Recv(&buf);
                if(ret == false)
                {
                    s.Del(arry[i]);     //某个描述符出问题了要移除监控
                    arry[i].Close();
                    continue;
                }
                std::cout << "client say: " << buf << std::endl;

                buf.clear();
                std::cout << "server say: ";
                std::cin >> buf;
                ret = arry[i].Send(buf);

                if(ret == false)
                {
                    s.Del(arry[i]);
                    arry[i].Close();
                }
            }
        }
    }
    //6.关闭套接字
    lst_lock.Close();
    return 0;
}
```

```makefile
select_srv:tcp_srv.cpp
	g++ $^ -o $@
select:select.c
	gcc $^ -o $@
#在makefile中依赖文件不要出现头文件，容易出现文件重复的警告
```

多路转接模型是针对一个或多个描述符进行IO就绪事件监控的功能。

通常应用于tcp服务器端，针对大量套接字描述符进行监控，让程序能够仅仅针对就绪的描述符进行操作，进而提高处理效率。

而udp服务端大多针对单个套接字进行操作，大多数情况也会用到多路转接模型，因为多路转接模型不但可以进行IO就绪事件监控，还可以进行超时控制。



## 2.3特性总结/优缺点

select特性总结：

优点：跨平台移植性较好。

缺点：

1.select所能监控的描述符有数量上限，上限取决于宏_FD_SETSIZE。（FD_SETSIZE默认是1024）

2.select每次进行监控都要重新向集合中添加描述符（每次都会修改），并且每次都要重新将集合拷贝到内核。

3.select监控原理是在内核中进行轮训遍历，性能随着描述符的增多而下降。

​	3.1将集合中描述符遍历一遍看看有没有就绪的。

​	3.2有就直接移除未就绪返回，没有则挂起等待。

​	3.3有描述符就绪/超时后被唤醒，重新遍历一遍移除未就绪后返回。

4.select返回的是就绪集合，需要用户判断哪个描述符还在哪个集合中，才能确定哪个描述符就绪了哪个事件。



# 3.poll

poll使用的很少了，因为相较于select不能跨平台，相较于epoll性能不如epoll。

## 3.1接口认识和操作流程

```c
#include <poll.h>
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

和select比较，poll用事件结构体替代了3种描述符集合。

struct pollfd

{

​	int fd;					//要监控的描述符

​	short events;		//fd描述符要监控的事件（POLLIN（可读）/POLLOUT（可写），还有其他异常事件）

​	short revents;		//监控调用返回后，用于记录实际就绪的事件

};

参数：fds：描述符事件结构数组；	nfds：数组中有效节点个数	timeout：超时时间

返回值：等于0表示超时，小于0表示出错，有就绪则大于0

操作流程：

1.定义事件结构体数组，为每个需要监控的描述符定义事件结构。

2.发起监控调用，将数组中有效节点拷贝到内核进行监控，超时/就绪则调用返回，返回前将描述符实际就绪的事件记录到对应节点的revents成员中。

3.调用返回后，遍历事件数组，通过每个节点的revents成员确定对应节点描述符是否就绪了某个事件。



## 3.2实例（使用poll监控标准输入）

```c
//文件名：poll.c
#include <poll.h>
#include <unistd.h>
#include <stdio.h>
#define MAX_COUNT 10

int main() 
{
    struct pollfd poll_fd[MAX_COUNT];
    poll_fd[0].fd = 0;      //监控的描述符是0号描述符
    //poll_fd[0].events = POLLIN|POLLOUT;     //监控的事件是可读事件和可写事件
    poll_fd[0].events = POLLIN;     //监控的事件是可读事件

    int nfds = 1;

    for (;;) 
    {
        int ret = poll(poll_fd, nfds, 3000);       //有效节点个数是1个，超时时间是3秒
        if (ret < 0) 
        {
            perror("poll");
            usleep(1000);
            continue;
        }
        
        if (ret == 0) 
        {
            printf("poll timeout\n");
            continue;
        }

        for(int i = 0; i < nfds; i++)
        {
            if (poll_fd[i].revents & POLLIN)    //二进制位相与操作
            {
                printf("fd:%d 就绪了\n",poll_fd[i].fd);
                char buf[1024] = {0};
                read(poll_fd[i].fd, buf, sizeof(buf) - 1);
                printf("stdin:%s", buf);
            }
        }
    }
}
```

![image-20231029033449458](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20231029033449458.png)



## 3.3总结

优缺点：

优点：

1.poll能够监控的描述符数量没有上限限制。

2.代码操作流程相较于select较为简单。

缺点：

1.跨平台移植性较差。

2.监控原理依然是遍历轮询，性能会随着描述符增多而下降。

3.监控返回后依然需要遍历事件结构数组确定描述符是否就绪。



# 4.epoll

epoll：linux下最好用的多路转接模型。

## 4.1接口认识和操作流程

接口认识：

### 4.1.1epoll_create

```c
#include <sys/epoll.h>
int epoll_create(int size);
```

作用：在内核中创建epoll句柄。

参数：size：监控的数量上限，linux2.6之后被忽略，大于0即可。

返回值：成功返回描述符，失败返回-1。



### 4.1.2epoll_ctl

```c
#include <sys/epoll.h>
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
```

作用：用于向epoll实例注册或修改文件描述符事件的函数。

参数：

epfd：epoll_create返回的epoll描述符。

op：EPOLL_CTL_ADD（将文件描述符fd添加到epoll实例中）/ EPOLL_CTL_DEL（从epoll实例中删除文件描述符） / EPOLL_CTL_MOD（修改已注册的文件描述

符fd的事件）

fd：需要注册、修改或删除的文件描述符。（要监控的描述符）（针对op类型所操作的监控描述符）

event：指向epoll_event结构体的指针，用于指定注册或修改的事件，删除直接置NULL。（针对fd描述符所定义的事件结构体）

```c
//epoll_event结构体定义：
typedef union epoll_data 
{
    void *ptr;		//关联用户自定义的数据结构
    int fd;			//文件描述符，关联某个文件描述符与事件
    uint32_t u32;	//32位的无符号整数，可以根据需要进行使用
    uint64_t u64;	//64位的无符号整数，可以根据需要进行使用
} epoll_data_t;

struct epoll_event 
{
    uint32_t events;    // 表示感兴趣的事件类型（要监控的事件，监控返回后实际就绪的事件）
    epoll_data_t data;  // 用户数据
};  
```

`events`字段用来指定感兴趣的事件类型，可以是以下几种值的组合：

- `EPOLLIN`：可读事件。
- `EPOLLOUT`：可写事件。
- `EPOLLPRI`：有紧急数据可读事件。
- `EPOLLERR`：错误事件。
- `EPOLLHUP`：挂起事件。
- `EPOLLET`：边缘触发模式（Edge Triggered）。
- `EPOLLONESHOT`：一次性事件。

`data`字段用来存储用户数据，可以是一个指针、文件描述符或整型数据。

返回值：epoll_ctl函数的返回值为0表示操作成功，-1表示操作失败，具体的错误信息可以通过errno变量获取。

在事件就绪时，可以通过`struct epoll_event`结构体的`data`字段来获取关联的数据，从而进行相应的处理。



### 4.1.3epoll_wait

```c
#include <sys/epoll.h>
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
```

作用：等待时间就绪。（`epoll_wait`函数会阻塞当前线程，直到epoll实例中有事件就绪或者超过指定的超时时间。当事件就绪时，函数会将就绪事件从内核事件

表复制到`events`数组中，并返回就绪事件的数量。如果超时时间到达而没有事件就绪，则函数返回0。如果发生错误，函数返回-1，并设置errno来指示具体的错

误类型。）

参数：

epfd：epoll描述符。

events：struct epoll_event数组首地址，用于保存就绪的描述符对应事件结构。

maxevents：通常设置为events数组的节点个数，指定要获取的事件最大个数，目的是为了防止越界。

timeout：等待就绪事件的超时时间，单位是毫秒，传入负数表示无限等待，传入0表示立即返回，1秒 = 1000毫秒。

返回值：超时返回0，出错返回-1，成功有就绪返回就绪事件个数（大于0）。



### 4.1.4操作流程

1.在内核中创建epoll句柄结构。

struct eventpoll{...rdllist, rbr...};

rbr：红黑树，用于保存要监控的描述符节点。

rbllist：双向链表，用于保存就绪的描述符对应事件结构。

2.向内核epoll句柄结构中添加要监控的描述符以及对应事件结构。

3.传入一个事件结构数组，开始监控，监控是一个异步阻塞操作。

​	3.1告诉系统开始监控，而描述符的监控由系统完成。

​	3.2系统为每个描述符的就绪事件做了一个事件回调函数，一旦某个描述符就绪了指定的事件，则会调用事件回调函数，将这个描述符对应的事件结构添加到就

​	绪事件双向链表。

​	3.3epoll_wait接口每隔一段时间查看epoll句柄结构的rdllist（就绪双向链表）是否为空，就可以判断有没有描述符就绪，超时则直接返回，如果有就绪，则将就

​	绪的事件结构信息拷贝到传入的数组中。

4.监控调用返回后，只需要遍历events数组，逐个对节点中的描述符进行对应事件的处理即可。



## 4.2应用

服务器：

```cpp
//文件名：epoll.hpp
//封装Epoll类，向外提供简单的接口即可完成对大量描述符的监控
//返回就绪的套接字/描述符

#include <iostream>
#include <vector>
#include <cstdlib>
#include <sys/epoll.h>
#include "tcpsocket.hpp"

class Epoll
{
public:
    Epoll()
        :_epfd(-1)
    {
        //int epoll_create(int size);       
        //作用：在内核中创建epoll句柄
        //参数：size是监控的数量上限，linux2.6之后被忽略，大于0即可
        //返回值：成功返回描述符(epoll句柄)，失败返回-1
        _epfd = epoll_create(1);        
        
        if(_epfd < 0)
        {
            //创建epoll句柄失败
            perror("epoll_create error");
            exit(-1);
        }
    }

    //添加监控
    bool Add(TcpSocket &sock)
    {
        //epoll_ctl(epoll句柄, 类型, 要监控的描述符, 事件结构);
        //类型：EPOLL_CTL_ADD（将文件描述符fd添加到epoll实例中）
        //事件结构：struct epoll_event  事件结构有两个成员
        
        //获取描述符（要监控的描述符）
        int fd = sock.GetFd();

        struct epoll_event ev;
        ev.data.fd = fd;
        ev.events = EPOLLIN;    //可读事件
        
        int ret = epoll_ctl(_epfd, EPOLL_CTL_ADD, fd, &ev);

        if(ret < 0)
        {
            //添加监控失败
            perror("epoll ctl add error");
            return false;
        }

        return true; 
    }

    //移除监控
    bool Del(TcpSocket &sock)
    {
        int fd = sock.GetFd();

        int ret = epoll_ctl(_epfd, EPOLL_CTL_DEL, fd, NULL);
        
        if(ret < 0)
        {
            perror("epoll ctl del error");
            return false;
        }

        return true;
        //因为epoll监控的信息都在内核中保存着，所以都是对内核里面的红黑树进行操作，向里面添加节点或者移除节点都是通过epoll_ctl完成的
    }

    //开始监控
    bool Wait(std::vector<TcpSocket>* arry)
    {
        //epoll_wait(句柄, 数组, 节点数量, 超时时间);
        //返回值：失败返回小于0的值，超时返回0，成功返回就绪事件的个数
        struct epoll_event evs[10];
        int ret = epoll_wait(_epfd, evs, 10, 3000);
        
        if(ret < 0)
        {
            //出错
            perror("epoll wait");
            return false;
        }
        else if(ret == 0)
        {
            //超时
            arry->clear();
            std::cout << "timeout\n";
            return true;
        }

        for(int i = 0; i < ret; i++)
        {
            if(evs[i].events & EPOLLIN)
            {
                //可读事件就绪
                TcpSocket sock;
                sock.SetFd(evs[i].data.fd);
                arry->push_back(sock);
            }
        }

        return true;
    }

private:
    int _epfd;
};
```

```cpp
//文件名：tcpsocket.hpp
#pragma once    //解决重复包含
#include <cstdio>
#include <iostream>
#include <string>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <unistd.h>

#define LISTEN_BACKLOG 5
#define CHECK_RET(q) if((q) == false){return -1;}

struct data_t
{
    int num1;
    int num2;
    char op;
};

class TcpSocket
{
    private:
        int _sockfd;        //操作句柄

    public:
        TcpSocket()
            :_sockfd(-1)
        {
            
        }

        void SetFd(int fd)
        {
            _sockfd = fd;
        }

        int GetFd()
        {
            return _sockfd;
        }

        //创建套接字
        bool Socket()
        {
            //tcp提供的是字节流传输服务，需要使用流式套接字SOCK_STREAM
            _sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if(_sockfd < 0)
            {
                //创建失败
                perror("socket error");
                return false;
            }
            return true;
        }

        //绑定地址信息
        bool Bind(const std::string &ip, const uint16_t port)
        {
            struct sockaddr_in addr;
            addr.sin_family = AF_INET;
            addr.sin_port = htons(port);
            addr.sin_addr.s_addr = inet_addr(ip.c_str());       //返回字符串的首地址，和下面取字符串的首元素的地址一样
            //addr.sin_addr.s_addr = inet_addr(&ip[0]);
            socklen_t len = sizeof(sockaddr_in);
            int ret = bind(_sockfd, (sockaddr*)&addr, len);
            if(ret < 0)
            {
                perror("bind error");
                return false;
            }
            return true;
        }

        //切换到监听状态
        bool Listen(int backlog = LISTEN_BACKLOG)
        {
            //listen(描述符, 同一时间连接数);
            int ret = listen(_sockfd, backlog);
            if(ret < 0)
            {
                perror("listen error");
                return false;
            }
            return true;
        }

        //连接服务器
        bool Connect(const std::string &ip, const int port)
        {
            struct sockaddr_in addr;
            addr.sin_family = AF_INET;
            addr.sin_port = htons(port);
            addr.sin_addr.s_addr = inet_addr(ip.c_str());       //返回字符串的首地址，和下面取字符串的首元素的地址一样
            //addr.sin_addr.s_addr = inet_addr(&ip[0]);
            socklen_t len = sizeof(sockaddr_in);
            //connect(描述符, 服务端地址, 地址长度);
            int ret = connect(_sockfd, (sockaddr*)&addr, len);
            if(ret < 0)
            {
                perror("connect error");
                return false;
            }
            return true;
        }

        //服务端获取新连接
        bool Accept(TcpSocket* sock, std::string *ip = NULL, uint16_t* port = NULL)
        {
            //原来的套接字是监听套接字，新创建的套接字是通信套接字
            //int accept(监听套接字, 回去客户端地址, 长度);
            sockaddr_in addr;
            socklen_t len = sizeof(sockaddr_in);
            int newfd = accept(_sockfd, (sockaddr*)&addr, &len);
            if(newfd < 0)
            {
                perror("accept error");
                return false;
            }

            sock->_sockfd = newfd;
            if(ip != NULL)
            {
                *ip = inet_ntoa(addr.sin_addr);
            }

            if(port != NULL)
            {
                *port = ntohs(addr.sin_port);
            }
            return true;
        }

        //接收数据
        bool Recv(std::string *buf)
        {
            //int recv(描述符, 空间, 数据长度, 标志位);     标志位给0是默认阻塞接收
            //返回值：实际获取大小  返回值是0不是没有接收数据，是连接断开了     -1是出错了
            char tmp[4096] = {0};       
            int ret = recv(_sockfd, tmp, 4096, 0);
            if(ret < 0)
            {
                //出错
                perror("recv error");
                return false;
            }
            else if(ret == 0)
            {
                //连接断开
                perror("peer shutdown");
                return false;
            }
            buf->assign(tmp, ret);      //拷贝字符串，参数是字符串首地址和字符串长度。
            return true;
        }

        //发送数据
        bool Send(const std::string &data)
        {
            //int send(描述符, 数据, 长度, 标志位);         标志位为0表示阻塞发送
            int total = 0;      //记录发送了多少数据
            
            while(total < data.size())
            {
                //发送数据一般不是一次性发送的，一般是多次发送，从上一次
                int ret = send(_sockfd, data.c_str() + total,  data.size() - total, 0);
                //int ret = send(_sockfd, &data[0] + total, data.size() - total, 0);      //和上面作用一样
                if(ret < 0)
                {
                    perror("send error");
                    return false;
                }
                total += ret;
            }
            return true;
        }

        bool Close()
        {
            if(_sockfd != -1)
            {
                close(_sockfd);
            }
            return true;
        }
};
```

```cpp
//文件名：tcp_cli.cpp
#include "tcpsocket.hpp"

//客户端
int main(int argc, char* argv[])
{
    //客户端可以不绑定地址信息，但是必须知道服务端的地址信息
    if(argc != 3)
    {
        printf("usage：./tcp_cli srv_ip srv_port\n");
        return -1;
    }

    std::string srv_ip = argv[1];
    uint16_t srv_port = std::stoi(argv[2]);

    TcpSocket cli_sock;
    //1.创建套接字
    CHECK_RET(cli_sock.Socket());
    //2.绑定地址信息（不推荐绑定）
    //3.向服务端发起连接
    CHECK_RET(cli_sock.Connect(srv_ip, srv_port));
    while(1)
    {
        //4.收发数据
        std::string buf;
        std::cout << "client say: ";
        std::cin >> buf;
        //客户端向服务端发送数据，客户端出问题直接退出，服务端接收出问题不能直接退出，还要接收下一个客户端
        CHECK_RET(cli_sock.Send(buf));
        //接收数据
        //清空缓冲区
        buf.clear();
        CHECK_RET(cli_sock.Recv(&buf));
        std::cout << "server say: " << buf << std::endl;
    }
    //5.关闭套接字
    CHECK_RET(cli_sock.Close());
    return 0;
}
```

```cpp
//文件名：tcp_srv.cpp
//#include "tcpsocket.hpp"
#include "select.hpp"       //在select.hpp中包含tcpsocket.hpp
#include "epoll.hpp"

//服务端
int main(int argc, char* argv[])
{
    //通过程序运行参数指定服务端要绑定的地址
    //  ./tcp_rev 192.168.0.203(IP地址) 9000(端口号)
    if(argc != 3)
    {
        //参数包含文件名本身，如果不是3，就是传参错误
        printf("usage：./tep_rev 192.168.0.203 9000\n");
        return -1;
    }
    
    bool ret;

    std::string srvip = argv[1];
    uint16_t srvport = std::stoi(argv[2]);  //stoi是将字符串转换为整数类型
    TcpSocket lst_lock;     //监听套接字
    //1.创建套接字
    CHECK_RET(lst_lock.Socket());
    //2.绑定地址信息
    CHECK_RET(lst_lock.Bind(srvip, srvport));
    //3.开始监听
    CHECK_RET(lst_lock.Listen());
    
    //Select s;
    Epoll s;        //修改的地方

    s.Add(lst_lock);        //将监听套接字添加监控

    while(1)
    {
        std::vector<TcpSocket> arry;    //就绪数组
        ret = s.Wait(&arry);        //开始监控，arry返回就绪套接字
        if(ret = false)
        {
            //监控出错了
            return false;
        }

        for(int i = 0; i < arry.size(); i++)
        {
            //就绪的第i个元素是监听套接字
            if(arry[i].GetFd() == lst_lock.GetFd())
            {
                //4.获取新建连接
                TcpSocket cli_sock;
                std::string cli_ip;
                uint16_t cli_port;
                //bool ret = arry[i].Accept(&cli_sock, &cli_ip, &cli_port);
                ret = lst_lock.Accept(&cli_sock, &cli_ip, &cli_port);
                if(ret == false)
                {
                    continue;
                }

                std::cout << "get newconn" << cli_ip << "-" << cli_port << "\n";
                s.Add(cli_sock);        //将通信套接字添加监控
            }
            else
            {
                //就绪的套接字不是监听套接字
                //5.收发数据    使用获取的新建套接字进行通信
                std::string buf;
                ret = arry[i].Recv(&buf);
                if(ret == false)
                {
                    s.Del(arry[i]);     //某个描述符出问题了要移除监控
                    arry[i].Close();
                    continue;
                }
                std::cout << "client say: " << buf << std::endl;

                buf.clear();
                std::cout << "server say: ";
                std::cin >> buf;
                ret = arry[i].Send(buf);

                if(ret == false)
                {
                    s.Del(arry[i]);
                    arry[i].Close();
                }
            }
        }
    }
    //6.关闭套接字
    lst_lock.Close();
    return 0;
}
```

```makefile
epoll_srv:tcp_srv.cpp
	g++ $^ -o $@
select:select.c
	gcc $^ -o $@
```



运行：

```shell
#第一个终端：
./epoll_srv 192.168.0.203 9005
#第二个终端
./tcp_cli 192.168.0.203 9005
```

多路转接模型不适用于有大量描述符同时就绪的情况，换一种说法，多路转接模型只适用于有大量描述符监控，但是同一时间只有少量描述符就绪的场景，有大量

描述符同时就绪的场景下使用多线程或者多执行流，多路转接模型通常适合线程池搭配使用的，有就绪的就抛出线程池，线程池里面的线程进行处理，起到一个均

衡的效果。



多路转接模型适用于哪些场景：

多路转接（Multiplexing）模型适用于需要同时处理多个I/O事件的场景。它可以提高系统的并发性和资源利用率，常见的多路转接模型有select、poll和epoll。

以下是一些适用多路转接模型的场景：

1. 网络服务器：多路转接模型特别适用于网络服务器，因为服务器通常需要同时监听多个客户端的连接请求和处理已建立连接的数据传输。通过使用多路转接模型，服务器可以在单个线程或进程中处理多个连接，而无需为每个连接创建一个独立的线程或进程，从而减少了资源开销。
2. 高并发系统：当系统需要处理大量并发请求时，使用多路转接模型可以有效地管理和调度这些请求。例如，在Web服务器中，当有多个并发的HTTP请求到达时，可以使用多路转接模型来同时处理这些请求，提高系统的并发处理能力。
3. 实时应用：多路转接模型也适用于实时应用，如多媒体流处理、游戏服务器等。这些应用通常需要快速响应输入事件，并能够同时处理多个输入源。多路转接模型可以帮助这些应用有效地管理事件，并及时处理。
4. 非阻塞I/O：多路转接模型对于需要使用非阻塞I/O的场景也非常适用。通过将套接字设置为非阻塞模式，可以避免I/O操作阻塞整个进程或线程，而多路转接模型则可以监视多个套接字的状态，当有可读或可写事件发生时立即进行处理。

需要注意的是，不同的多路转接模型在实现和性能方面可能有所不同。例如，epoll在Linux系统上通常具有更好的性能和可扩展性。因此，在选择多路转接模型时，需要考虑具体的应用需求、系统平台和性能要求。



多路转接模型通常与线程池搭配使用，以提高系统的性能和资源利用率。

在多路转接模型中，一个线程可以同时管理和监视多个I/O事件。当有事件发生时，线程会从多路转接模型中获取事件，并将其分发给线程池中的工作线程进行处理。这样可以实现事件的异步处理，避免了为每个连接创建独立线程的开销。

线程池是一组可重用的线程，它们在系统启动时就被创建，并且保持活动状态以等待任务分配。当有I/O事件发生时，多路转接模型将事件传递给线程池，线程池中的空闲线程会被唤醒并分配处理任务，从而实现事件的并发处理。

通过将多路转接模型和线程池结合使用，可以充分利用系统资源，提高系统的并发性和响应能力。线程池可以灵活管理工作线程的数量，避免过多的线程创建和销毁开销，同时多路转接模型可以有效地管理和调度事件，避免了阻塞和串行处理的问题。

需要注意的是，线程池的大小需要根据系统的负载情况和性能需求进行合理配置，以确保不会出现线程饥饿或过度竞争的情况。同时，需要注意线程安全和同步机制的使用，以避免并发访问共享资源导致的问题。



## 4.3epoll的事件触发方式

IO事件的就绪：

可写：描述符的发送缓冲区中剩余空间大小大于低水位标记。

可读：描述符的接收缓冲区中数据大小大于低水位标记。

低水位标记：类似于一个基准值。（默认1个字节）

IO就绪事件的触发方式：默认是水平触发，边缘触发是epoll特有的。

水平触发：EPOLLLT（默认，不需要设置）

可读：只要缓冲区中有数据就会触发可读事件。

可写：只要缓冲区中有剩余空间就会触发可写事件。

边缘触发：EPOLLET（需要通过epoll_ctl接口进行设置，设置是或(|)）

可读：只有新数据到来的时候才会触发可读事件。

可写：只有缓冲区从没有剩余空间变为有剩余才会触发可写事件。

边缘触发可以提高任务处理效率。

为啥要使用边缘触发？		答：大量描述符要进行操作的时候，就会出现一种情况，有的描述符在不断地触发就绪事件。

举个例子：假设有个描述符有数据来了，但是数据不完整，这种情况下使用水平触发，如果不取出数据就会一直触发事件，而使用边缘触发则可以实现在有新数据

到来的时候触发事件，查看数据是否完整。（防止一种事件不断被触发，但是不太想去处理的场景）

边缘触发的缺陷：边缘触发只有在新数据到来的时候才会触发事件，意味着在一次事件触发中就必须将需要处理的数据完全取出处理，因为在没有新数据到来的情

况下不会再次触发事件去处理剩余的数据。

如何将缓冲区中所有数据全部取出？

答：因为不知道缓冲区中有多少数据，因此只能循环进行读取，直到取不出数据为止，但是这样会出现一种情况，没有数据则继续读就会阻塞。

因此边缘触发的IO必须使用非阻塞操作，循环读取到缓冲区中没有数据的时候就会报错返回。（报的错errno = EAGAIN）

int fcntl(int fd,int cmd, .../*arg*/...);

cmd：F_GETFL：获取描述符属性通过返回值返回，arg被忽略。

​			F_SETFL：设置描述符属性。	arg = O_NONBLOCK。

通常使用F_SETFL：设置描述符属性。	arg = O_NONBLOCK。

int flag = fcntl(fd, F_GETFL, 0);

fcntl(fd,F_SETFL,flag|O_NONBLOCK);

这样使用的目的是O_NONBLOCK会覆盖别的属性，只有自己了。



## 4.4epoll优缺点

缺点：跨平台移植性较差。

优点：

1.所能监控的描述符没有数量上限。

2.描述符以及事件结构只需要向内核拷贝一次。

3.监控原理采用异步阻塞，监控由系统完成，进程只需要判断就绪链表是否为NULL即可，性能不会随着描述符增多而下降。

4.直接返回的都是就绪的描述符对应事件结构，减少空遍历。



## 4.5总结多路转接模型

适用于有大量描述符需要监控，但是同一时间只有少量活跃的场景。

poll/select适用于单个描述符的超时控制。

单个描述符的临时超时控制这里不适用epoll。

在实际使用中，多路转接模型通常搭配线程池一起使用。

对大量描述符进行监控，就绪事件后则抛入线程池进行处理。



## 4.6epoll惊群问题

epoll惊群问题是在使用epoll多路转接模型时可能出现的一种性能问题。当有多个线程或进程同时等待一个epoll实例上的事件时，当有事件触发时，操作系统会将事件通知给所有等待的线程或进程，这会导致多个线程或进程竞争处理相同的事件。

造成epoll惊群问题的原因是内核通知机制的设计。在早期的Linux内核中，当有事件发生时，内核会将事件通知给所有等待的线程或进程，而不是只通知其中的一个。这样就会导致多个线程或进程同时竞争处理相同的事件，从而浪费了系统资源。

为了解决epoll惊群问题，后续的Linux内核引入了两种解决方案：

1. 边缘触发（Edge-Triggered）模式：在边缘触发模式下，内核只通知那些在事件发生之前没有准备好的线程或进程，而不是所有等待的线程或进程。这样可以避免多个线程或进程竞争处理相同的事件，提高系统的性能。
2. 使用互斥量（Mutex）或条件变量（Condition Variable）：在应用程序中，可以使用互斥量或条件变量来保护对共享资源的访问，确保只有一个线程或进程处理事件。当一个线程或进程正在处理事件时，其他线程或进程会被阻塞，等待前一个线程或进程完成处理。

需要注意的是，为了避免epoll惊群问题，开发者在使用epoll时需要根据具体的场景和需求选择合适的解决方案。边缘触发模式适用于需要高性能的场景，而使用互斥量或条件变量可以确保线程安全和资源访问的有序性。



# 5.总结

高级IO：四种典型IO，多路转接模型。

四种典型IO：

阻塞IO、非阻塞IO、信号驱动IO、异步IO。

阻塞：为了完成一个功能，发起调用，若不具备完成条件，则调用一直等待。

非阻塞：发起调用，若不具备完成条件，则调用立即报错返回。

阻塞与非阻塞：通常用于讨论接口特性，区别在于发起调用后是否会立即返回。

同步：功能自己完成，一个完成之后才能完成下一个。

异步：功能别人完成，功能完成流程并非按发起时序完成。

异步阻塞与异步非阻塞：区别在于进程是否等待系统完成任务。

同步与异步：通常用于讨论任务完成流程，区别在于功能是否由自身完成。

同步流程清晰简单，但是效率相较于异步较低。

异步对资源利用率更高，效率更高，但是流程较为复杂。



IO多路转接模型： 

作用：IO多路转接模型，就是针对大量描述符进行IO就绪事件监控，让进程能避免对没有就绪的描述符进行操作，提高IO效率，避免对没有就绪的描述符进行操作而导致的阻塞。

实现：select、poll、epoll

select模型：

流程：

1.定义指定事件的描述符集合，添加要监控的描述符到其中。

2.将集合拷贝到内核进行IO就绪事件监控。监控调用返回前，将集合中没有就绪的描述符移除。

3.进程中判断哪个描述符还在集合中，确定哪个描述符就绪了什么事件。

接口：

1.fd_set set;

void FD_ZERO(fd_set* set);	清空集合

void FD_SET(int fd,fd_set* set);	添加描述符

2.int select(int nfds,fd_set* rfds,fd_set* wfds,fd_set* efds,timeout* t);

3.int FD_ISSET(int fd,fd_set* set);

4.void FD_CLR(int fd,fd_set* set);



select操作流程：

1.定义事件的描述符集合（位图），清空集合，添加需要监控的描述符。

2.将集合拷贝到内核中进行监控，有就绪/超时则监控返回，返回前将未就绪的描述符从集合中移除。

3.监控调用返回后，获取到就绪的描述符集合，判断哪个描述符还在哪个集合中确定这个描述符是否就绪了某个事件。

接口：fd_set/FD_ZERO/FD_SET/FD_ISSET/FD_CLR/select

优缺点：

优点：跨平台移植性良好。

缺点：

1.select所能监控的描述符有最大数量上限。

2.每次监控都需要重新向集合中添加描述符，并且拷贝到内核。

3.select监控原理遍历轮询，性能会随着描述符增多而下降。

4.select无法直接提供就绪描述符，需要监控后进行遍历判断。















  
