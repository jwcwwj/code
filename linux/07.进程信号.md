# 1.本节目标

1.掌握Linux信号的基本概念

2.掌握信号产生的一般方式

3.理解信号递达和阻塞的概念，原理

4.掌握信号捕捉的一般方式

5.重新了解可重入函数的概念



信号不是信号量，两个不是同一个技术点。

信号量是用来实现进程间同步与互斥的技术。



进程信号：是用来向进程事件通知的技术。

概念：信号就是中断。（中断就是打断当前的操作，通知发生了某一个事件。）（这里主要讲软件中断）

中断分为软件中断和硬件中断。

软件中断：向进程发送一个信号，通知进程发生了某个事件，打断进程当前操作去处理这个事件。

硬件中断：通过高低电平，通知一个事件中断。



```shell
kill -l			#查看系统当中进程信号的种类或值
```

进程信号概念：信号就是软件中断。信号就是用于向进程通知某个事件的产生，打断进程当前操作，去处理这个事件。

linux中信号的种类；62种。

1到31号：非可靠信号，最早存在的31种信号，非可靠指的是有可能会导致事件丢失的信号。（非可靠信号没有处理的话只保留一次，意味着其他没有处理的事件

被丢掉了。）

非可靠信号有可能会造成事件丢失。

34到64号：可靠信号，后添加进来的信号。（可靠信号不会丢失事件。）



信号的生命周期：

1.生产信号；

2.在进程pcb中注册信号；

3.注销信号；

4.处理信号。

处理信号在注销信号后面是为了防止信号被重复处理的情况。



1个进程可以有多个pcb，一个pcb调度一个程序，1个进程可以执行多个程序。



# 2.信号的产生

```shell
jobs			#用于查看当前终端会话中活动作业（jobs）的命令。作业指的是在后台运行的进程或任务（查看当前挂起的作业，并使用 "fg" 命令将作业移到前台继续执行，或使用 "bg" 命令让作业在后台继续执行。）
fg 1			#将一个停止的作业运行起来，1是停止运行的进程，fg给进程发送了一个继续运行的信号
```

kill杀死进程的原理是发送了一个信号，kill -9强制杀死一个进程（僵尸进程杀不死，因为不来就是死的），是发送了一个9号信号。

终止信号是 SIGTERM，对应的信号值是数字 15。

强制终止信号是 SIGKILL，对应的信号值是数字 9。

硬件产生：ctrl + c、ctrl + l、ctrl + z。（ctrl + l和命令clear作用一样，清屏）

软件产生：kill命令发送信号给指定进程：kill -signum pid。

​					kill命令杀死一个进程的原理：默认给进程发送了终止信号。

```shell
man 2 kill    #系统调用接口
```



```c
int kill(pid_t pid, int sig);		//给pid进程发送sig信号	 
```

参数：pid：进程的pid		sig：信号的值

![image-20230823155034688](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230823155034688.png)

```shell
grep -R ‘SIGKILL’ /usr/include		
/usr/include/x86_64-linux-gnu/bits/signum-generic.h			#在Ubuntu中，查看信号的宏
vim /usr/include/bits/signum.h							#在Centos中
```

![image-20230823155921875](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230823155921875.png)

​	![image-20230823160312139](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230823160312139.png)



```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>     //信号的头文件

int main()
{
    //给进程发送一个信号    
    //kill(进程ID, 信号值)
    kill(getpid(), SIGINT);                //getpid是获取当前进程自身的id,2号中断信号（SIGINT）

    while(1)
    {
        printf("------------\n");
        sleep(1);
    }
    return 0;
}
```

```makefile
signal:signal.c
	gcc -g $^ -o $@
```

gdb调试：

![image-20230823162229561](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230823162229561.png)![image-20230823162247974](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230823162247974.png)



```shell
man 3 raise		#库函数封装了系统调用接口kill
```

```c
int raise(int sig);		//给进程自身发送一个指定的信号
```

参数：sig：信号值

```c
//用raise函数修改上面的代码
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>     //信号的头文件

int main()
{
    //给进程发送一个信号    
    //kill(进程ID, 信号值)
    //kill(getpid(), SIGINT);                //getpid是获取当前进程自身的id,2号中断信号（SIGINT）
    
    //给进程自身发送一个指定的信号值
    //raise(信号值);        
    raise(SIGINT);

    while(1)
    {
        printf("------------\n");
        sleep(1);
    }
    return 0;
}
```





```shell
man 2 alarm
```



```c
unsigned int alarm(unsigned int seconds);			//在seconds秒后为进程自身发送一个时钟信号（SIGALRM 信号值是14），可以将功能称为设置一个定时器
```

参数：seconds：秒

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>     //信号的头文件

int main()
{
    //给进程发送一个信号    
    //kill(进程ID, 信号值)
    //kill(getpid(), SIGINT);                //getpid是获取当前进程自身的id,2号中断信号（SIGINT）
    
    //给进程自身发送一个指定的信号值
    //raise(信号值);        
    //raise(SIGINT);

    alarm(3);            //3秒钟后给进程自身发送一个时钟信号SIGALRM;

    while(1)
    {
        printf("------------\n");
        sleep(1);
    }
    return 0;
}
```

![image-20230823164433892](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230823164433892.png)

输出结果中文是闹钟，英文结果是Alarm clock

信号有一个很重要的作用，打断进程当前的操作。

sleep的休眠是可中断的休眠。





```shell
man 3 abort
```

```c
void abort(void);			//给进程自身发送一个SIGABRT信号，使异常进程终止
```





下面的这个sigqueue了解一下，一般用不到。

```c
man 3 sigqueue
```

```c
int sigqueue(pid_t pid, int sig, const union sigval value);		//发送一个指定信号，连带一个数据发送给一个进程（发送的数据是联合体）
```

参数：pid：进程号		sig：信号值		value：连带的数据，是一个联合体



# 3.信号的注册

注册：在进程中注册一个信号让进程知道自己收到了某个信号。

进程信号的存储是在一个位图中。

信号pending位图：用于标记是否收到了某个信号。



非可靠：如果信号没有被注册，则注册，否则什么都不做。

链表中不会出现相同非可靠信号信息节点。



可靠：不管信号是否注册，都会注册一下。

链表中有可能有多个相同的信号信息节点。



sigqueue双向链表，表示有多少信号。



# 4.信号的注销

注销：将信号信息进程pcb中移除（修改位图，删除节点）

非可靠：删除节点，修改位图为0。

可靠：删除信号节点，检查链表中是否还有相同节点，没有则修改位图。



# 5.信号的处理

处理：信号的处理也叫信号的抵达，实际上就是打断进程当前的操作，去执行进程的对应信号处理函数。

信号的处理方式：

1.默认处理方式；（默认的情况下使用的）

2.忽略处理方式；（处理方式就是移除掉什么都不做，和真正的忽略是有区别的）

3.自定义处理方式；（用户自己定义信号的处理回调函数）

```shell
man 2 signal
```

```c
typedef void (*sighandler_t)(int);			//类型定义，是一个指向函数的指针
sighandler_t signal(int signum, sighandler_t handler);
```

参数：

signum：信号值，表示要修改哪个信号的处理方式。

handler：新的信号处理方式

SIG_DFL：默认		SIG_IGN：忽略				自定义函数的名称

返回值：成功则返回当前信号原来的处理方式，失败返回SIG_ERR。



```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>     //信号的头文件

int main()
{
    //修改一个信号的处理方式    非阻塞函数
    //signal(信号, 处理方式);
    signal(SIGINT, SIG_IGN);        //修改信号为忽略

    raise(SIGINT);


    while(1)
    {
        printf("------------\n");
        sleep(1);
    }
    return 0;
}

```



```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>     //信号的头文件

void sigcb(int signo)
{
    printf("recv signal:%d\n", signo);
}

int main()
{
    //修改一个信号的处理方式    非阻塞函数
    //signal(信号, 处理方式);
    //signal(SIGINT, SIG_IGN);        //修改信号为忽略
    signal(SIGINT, sigcb);

    raise(SIGINT);


    while(1)
    {
        printf("------------\n");
        sleep(1);
    }
    return 0;
}
```

![image-20230824202619304](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230824202619304.png)



```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>     //信号的头文件

void sigcb(int signo)
{
    printf("recv signal:%d\n", signo);
    printf("该吃饭了\n");
}

int main()
{
    //修改一个信号的处理方式    非阻塞函数
    //signal(信号, 处理方式);
    //signal(SIGINT, SIG_IGN);        //修改信号为忽略
    signal(SIGALRM, sigcb);

    //raise(SIGINT);
    alarm(3);

    while(1)
    {
        printf("------------\n");
        sleep(1);
    }
    return 0;
}
```

![image-20230824203021021](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230824203021021.png)



```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>     //信号的头文件

void sigcb(int signo)
{
    printf("recv signal:%d\n", signo);
    printf("该吃饭了\n");
}

int main()
{
    //修改一个信号的处理方式    非阻塞函数
    //signal(信号, 处理方式);
    //signal(SIGINT, SIG_IGN);        //修改信号为忽略
    signal(SIGALRM, sigcb);

    //raise(SIGINT);
    alarm(3);

    while(1)
    {
        printf("------------\n");
        sleep(1);
    }
    return 0;
}
```

![image-20230824203630688](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230824203630688.png)



自定义处理方式的信号捕捉流程：

![image-20230826170040985](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230826170040985.png)



# 6.信号阻塞

阻塞：信号的阻塞，阻止信号被抵达（或者处理）。

一个信号被阻塞后，依然收到这个信号会注册，但是暂时不被处理，等到不被阻塞了再去处理。



如何阻塞一个信号呢？（或者如何让进程知道这个信号收到了暂时不用处理）

pcb中有pending位图，未决信号集合，还有阻塞信号结合。

如果要阻塞一个信号，就是在进程的阻塞信号集合中标记这个信号。



位图是内核里面的。

![image-20230828002417151](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230828002417151.png)

pending是位图表示接收的信号。

block位图是阻塞信号标记。

action->handler是调用回调函数处理信号。

举例：

位图pending收到了2号信号，标记为1，在block查看标记了2号新号，表示是阻塞信号，不会处理，没有标记在action->handler中调用回调函数处理2号信号。



具体操作：

```shell
man sigprocmask
```

```c
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);：
```

参数：

how：操作类型，有3种

SIG_BLOCK：阻塞set集合（位图）中的信号，对原来的block集合中的信号做出修改。		block = block | set

SIG_UNBLOCK：将set集合中的信号解除阻塞		block &= ~set

SIG_SETMASK：将set集合中的信号设置为阻塞集合的信号		block = set

返回值：成功返回0，失败返回-1。



流程：

先自定义特定信号的处理方式：做打印收到了哪个信号		signal

将所有信号阻塞	sigprocmask block

让程序运行停下来，在这期间给进程发送信号	getchar

解除这些信号的阻塞，查看信号处理结果	sigprocmask unblock



```shell
man sigemptyset
```

```c
int sigemptyset(sigset_t *set);							//清空set结合
int sigfillset(sigset_t *set);							//添加所有信号到set集合中
int sigaddset(sigset_t *set, int signum);				//添加指定信号signum信号到set集合中
int sigdelset(sigset_t *set, int signum);				//从set集合中移除signum信号（移除方式：把对应位置置0，是一个位图）
int sigismember(const sigset_t *set, int signum);		//判断signum信号是否在set集合中
```

实时信号：就是可靠信号，34到64号，第一时间能处理的信号。

非实时信号：就是非可靠信号，1到31号。

两个比较特殊的信号：SIGKILL（9号新号，强制杀死）和SIGSTOP（19号信号，停止信号），这两个信号不可被阻塞，不可自定义，不可被忽略，就是无法修改处

理方式的。

面试题：一个进程无法被杀死是什么原因？

1.僵尸进程（已经死了的进程）	2杀死的进程被阻塞了，被忽略了	3.这个进程处于停止状态，不去处理信号（停止就是什么都不做，停止是不处理信号的，强

制杀死是可以的）



# 7.信号的基本应用

方式1：默认方式

SIGCHLD信号：一个子进程退出后，给父进程发送的子进程状态改变信号，但是SLGCHLD默认处理方式就是什么都不做。

要避免僵尸进程，则需要在父进程中wait阻塞等待，否则会使子进程成为僵尸进程，但是这样做会使父进程阻塞，父进程什么也干不了，有点浪费资源。

如果不想阻塞等待，则可以使用信号来解决。

自定义SLGCHLD信号的处理方式，在回调函数中调用waitpid接口。

```c
//文件名：fork.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

void sigcb(int no)
{
    printf("有子进程退出了\n");
    //阻塞等待，0表示阻塞
    waitpid(-1, NULL, 0);
}

int main()
{
    //程序刚进来就修改信号的处理方式
    signal(SIGCHLD, sigcb);

    //创建子进程
    pid_t pid = fork();

    if(pid == 0)
    {
        sleep(3);
        //子进程退出，成为僵尸进程，需要等待
        exit(0);
    }

    while(1)
    {
       printf("-----------\n");
       sleep(1);
    }

    return 0;
}
```

SLGCHLD是一个非可靠信号，意味着多个子进程同时退出，有可能会出现事件丢失，没有处理到就会成为僵尸进程。

下去调研非可靠信号事件丢失的处理方法。





方式2：显示忽略方式

signal(SIGCHLD,SIG_IGN);	这个设置之后子进程退出会自动释放资源。



SIGPIPE：管道所有读端被关闭则write触发异常对应的信号。

SIGPIPE信号默认处理方式就是退出进程，若不想退出则需要自定义/忽略。

```c
//文件名：进程间通信中的fifo_write.c，要在另外一个终端中运行进程间通信中的fifo_read.c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <signal.h>

void sigcb(int no)
{
    printf("所有的管道读端已经被关闭了\n");
}

int main()
{
    signal(SIGPIPE,sigcb);
    umask(0);
    char* fifo_name = "./test.fifo";
    int ret = mkfifo(fifo_name, 0664);
    if(ret < 0 && errno != EEXIST)
    {
        //不是因为文件已经存在而报错，文件已经存在不报错
        perror("mkfifo error");
        return -1;
    }

    int fd = open(fifo_name, O_WRONLY);
    if(fd < 0)
    {
        perror("open error");
        return -1;
    }

    while(1)
    {
        char buf[1024] = {0};
        scanf("%s", buf);
        int ret = write(fd, buf, strlen(buf));
        if(ret < 0)
        {
            perror("write error");
            return -1;
        }
    }

    close(fd);

    return 0;
}
```



信号：

概念，种类，生命周期（产生、注册、销毁、处理），阻塞S，IGCHLD，SIGPIPE



# 8.关键字（和信号没关系）

volatile：

功能：保存内存可见性，让cpu每次访问变量的时候都从内存中重新获取数据。

目的：防止编译器过度优化。

不加volatile每次是从寄存器中获取数据，加上volatile每次是从内存中获取数据，但是从内存中获取数据的效率低效，从寄存器中获取数据效率比较高效。

修改一个值的时候不会加载到寄存器中，这个时候从寄存器中获取值是错误的。



```shell
gcc -O2 vol.c -o vol		#gcc对代码进行二级优化，提高程序的性能，把一些无效的指令给去掉（包括）
```

解释：

gcc 是 GNU 编译器套件中的 C 语言编译器，而 `-O2` 是 gcc 中的一个编译选项，用于开启中级优化级别。

使用 `-O2` 编译选项会启用一系列的优化技术，目的是对源代码进行优化，以提高生成的可执行程序的性能。

具体来说，`-O2` 优化级别会包括以下方面的优化：

1. 代码行为优化：对源代码进行分析，通过消除无用的代码、合并重复的代码、简化算术表达式等方式来改进代码的整体行为。
2. 控制流优化：优化控制流指令的生成和执行，例如减少条件判断、简化循环结构、实现函数内联等，以提高程序的执行效率。
3. 数据流优化：通过对数据依赖关系的分析和重组，优化数据的访问模式，例如循环展开、向量化操作等，以提高数据处理的效率。
4. 内存优化：对内存访问进行优化，例如循环变量的本地化、缓存局部性的改进等，以减少内存访问延迟，并提高程序的整体性能。

总的来说，`-O2` 编译选项会对源代码进行多方面的优化，旨在提高生成的可执行程序的运行速度和效率。然而，需要注意的是，更高级别的优化选项（如 `-O3`）可能会导致编译时间增加，并且在某些情况下可能会对代码的正确性和可读性产生一些影响。因此，在选择优化级别时需要权衡执行时间和性能优化之间的平衡。



代码优化是好事，但是要慎重使用，防止程序逻辑异常。（代码优化的时候需要把不优化的部分标注出来，使用volatile关键字，每次从内存中获取数据，防止优

化）

```c
//文件名：vol.c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>

//防止变量a优化
volatile int a = 1;

void sigcb(int no)
{
    a = 0;
    printf("%d\n", a);
}

int main()
{
    //修改信号处理方式
    signal(SIGINT, sigcb);

    while(a)
    {

    }

    printf("程序正常退出\n");

    return 0;
}
```

代码优化的关键字：volatile、static、const。

## 8.1代码优化关键字

在 C++ 中，有一些关键字和技术可以用于代码优化。以下是一些常用的代码优化相关的关键字和技术：

1. `const`：将变量声明为常量，在编译时可以进行常量折叠和优化。
2. `inline`：将函数标记为内联函数，编译器会尝试将函数的定义插入到调用处，减少函数调用的开销。
3. `constexpr`：在编译时求值的常量表达式，可以用于在编译时进行计算，减少运行时开销。
4. `auto`：自动类型推导，由编译器根据初始化表达式自动推断变量的类型，避免显式指定类型的繁琐性。
5. `register`：建议编译器将变量存储在寄存器中，以加快访问速度。
6. `restrict`：向编译器指明指针没有别的别名，可以进行更多的优化。
7. `volatile`：用于指示编译器不要对变量进行优化，适用于多线程或硬件相关的操作。
8. `[[likely]]` 和 `[[unlikely]]`：在条件语句上使用，用于指示条件的可能性，帮助编译器进行分支预测优化。
9. 内存对齐（Memory alignment）：使用 `alignas` 关键字来指定数据的对齐方式，提高内存访问效率。
10. 智能指针（Smart pointers）：使用智能指针来管理动态内存，避免内存泄漏和手动释放资源的负担。

除了关键字，C++ 中还有一些常用的优化技术，例如循环优化、向量化、函数传参优化、内联汇编等，可以根据具体情况选择合适的方法来进行代码优化。此外，

使用性能分析工具和编译器选项也是优化代码的重要手段。

## 8.2代码优化技术

在进行代码优化时，以下是一些常见的关键字和概念：

1. 循环展开（Loop unrolling）：将循环的迭代次数减少，每次迭代处理多个元素，以减少循环开销和提高指令级并行性。
2. 向量化（Vectorization）：使用向量指令或并行处理单元同时操作多个数据元素，以加速数据密集型计算。
3. 内联（Inlining）：将函数调用处的代码直接插入到调用处，避免函数调用的开销，提高执行效率。
4. 常量折叠（Constant folding）：在编译时将表达式中的常量进行计算，并将结果替换回代码中，减少运行时的计算次数。
5. 简化表达式（Expression simplification）：对复杂的表达式进行简化，消除冗余的计算和无效的操作。
6. 删除无用代码（Dead code elimination）：移除永远不会执行的代码，减少程序的体积和执行时间。
7. 内存局部性优化（Memory locality optimization）：重排数据访问模式，使得访问的数据更加紧凑，减少缓存失效，提高内存访问效率。
8. 并行化（Parallelization）：将代码中的任务分解为多个独立的子任务，并利用多核或分布式系统并行执行以提高性能。
9. 数据流分析（Data flow analysis）：对数据的使用和传递进行分析，以识别潜在的优化机会和依赖关系。
10. 延迟计算（Lazy evaluation）：推迟计算直到需要的时候，减少不必要的计算和内存占用。

这些关键字和概念代表了代码优化过程中常用的技术和方法。在实际应用中，根据具体的编程语言、编译器和应用场景，可能还有其他针对特定优化目标的关键字和技术。



# 9.可重入函数和不可重入函数

```c
//文件名：rentry.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

int a = 0, b = 0;

int test()
{
    a++;
    sleep(1);
    b++;
    printf("%d + %d = %d\n", a, b, a + b);
}

void sigcb(int no)
{
    test();
}

int main()
{
    signal(SIGINT, sigcb);
    test();
    return 0;
}
```

![image-20230902014040214](C:\Users\19827\AppData\Roaming\Typora\typora-user-images\image-20230902014040214.png)

函数的重入：在不同的执行流程中（main和signal两个流程）同时进入一个函数进行执行。

不可重入：一个函数重入后，有可能会造成数据二义或者逻辑混乱。

可重入：一个函数重入后，不会出现问题。

函数是否可重入的重点：一个函数中是否对全局数据进行不受保护的非原子操作。



# 10.总结

概念：信号就是一个软件中断；

通知进程发生了某个事件，打断进程当前操作，去处理这个事件。

linux下信号种类：使用kill -l命令查看所有进程信号，一共有62钟，1到31号是非可靠信号，34到64号是可靠信号。

信号的生命周期：产生、注册、注销、处理。

产生：

硬件产生：ctrl + c（中断，发送的是终止信号（SIGINT））		ctrl + \（发送的是中断信号（SIGQUIT））	ctrl + z（停止，发送挂起信号（SIGTSTP），挂起

信号会暂时停止进程的执行，而不会立即终止或中断它。，会将当前正在运行的进程置于后台挂起状态）

中断信号（SIGQUIT）与终止信号（SIGINT）类似，都会导致进程终止。但是，中断信号还附带了一些特殊的处理机制，例如，它会导致进程生成一个核心转储文

件（core dump），可以用于调试。

需要注意的是，不同的终端程序和操作系统可能会对 "Ctrl + " 进行不同的处理。例如，在某些系统中，它可能导致终端程序退出并返回到父进程，而在其他系统

中，它可能会触发进程终止。

软件产生：kill命令，给指定的进程发送一个指定的信号，kill -sigpid。

kill杀死进程的原理，就是默认给进程发送了一个终止信号。







进程信号：信号不是信号量。

概念：一种软件中断，一种事件通知机制。

作用：通知进程发生了某个事件，打断进程当前操作，去处理这个事件。

种类：使用kill -l查看，一共有62种，1到31号是非可靠的，34到64号是可靠的。



信号的产生：

硬件产生：ctrl + c、ctrl + l、ctrl + z

软件产生：kill命令、kill()、raise()、alarm()、abort()

kill命令杀死进程原理：给进程发送一个信号，信号处理方式就是退出。



信号在进程中的注册：在pcb中标记（位图 + 链表）

非可靠：相同的信号只能注册一个。

可靠：不管信号有没有已经注册，都会注册一次。（添加一个链表节点。）



信号在进程中的注销：删除标记（位图 + 链表）

非可靠：删除节点，位图置0。

可靠：删除节点，确定没有相同节点，则位图置0。



信号的处理：执行信号的事件回调函数。

分类：默认处理-SIG_DFL	忽略处理-SIG_IGN	自定义处理

sighandler_t signal(int signum, sighandler handler);

自定义处理方式的信号捕捉流程：

程序运行可以通过中断、异常、系统调用从用户态运行切换到内核态。

信号是从程序运行从内存态返回用户态之前处理的。



信号的阻塞：标记哪些信号注册之后暂时不被处理。（位图）

int sigprocmask(int how, sigset_t* set, sigset_t* old);

how：SIG_BLOCK	SIG_UNBLOCK	SIG_SETMASK

int sigemptyset(sigset_t *set);							//清空set结合
int sigfillset(sigset_t *set);							//添加所有信号到set集合中
int sigaddset(sigset_t *set, int signum);				//添加指定信号signum信号到set集合中
int sigdelset(sigset_t *set, int signum);				//从set集合中移除signum信号（移除方式：把对应位置置0，是一个位图）
int sigismember(const sigset_t *set, int signum);		//判断signum信号是否在set集合中



特殊信号：SIGKILL -9 / SIGSTOP -19	无法被阻塞，无法被修改处理方式。

信号的应用：SIGCHLD，SIGPIPE。



关键字：volatile

作用：用于修饰一个变量，表示保持变量的内存可见性。

表示cpu每次访问变量都需要重新从内存中加载最新数据，防止编译器过度优化。



函数的可重入与不可重入：

重入：在多个执行流中同时进入同一个函数运行。

可重入：函数重入之后，不会出现预期之外的问题。

不可重入：函数重入后，有可能会出现预期之外的问题，数据二义性。

判断基准：在函数内部是否对全局数据进行了不受保护的非原子操作。

原子操作：原子性的操作，是不可分割的操作，要么一次完成要么不做。

SIGCHLD：因为有可能丢失事件，因此尽可能在一次回调中处理完所有退出。

waitpid()	有子进程退出返回值 > 0，没有子进程退出返回值 == 0，出错 < 0。

while(waitpid(-1, NULL, WNOHGANG) > 0);



修改处理方式另外一个高大尚的接口。（修改结构体，这个操作方式比较复杂，一般不会使用，了解一下）

```c
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```

